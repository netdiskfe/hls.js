(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _ewmaBandwidthEstimator = require('./ewma-bandwidth-estimator');

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._autoLevelCapping = -1;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.onCheck = _this.abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.timer = setInterval(this.onCheck, 100);
        }
        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this.bwEstimator) {
          var hls = this.hls,
              level = data.frag.level,
              isLive = hls.levels[level].details.live,
              config = hls.config,
              ewmaFast = void 0,
              ewmaSlow = void 0;

          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this.bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
        this.fragCurrent = frag;
      }
    }
  }, {
    key: 'abandonRulesCheck',
    value: function abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls,
          v = hls.media,
          frag = this.fragCurrent,
          loader = frag.loader;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRulesCheck');
        this.clearTimer();
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(v.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levels[frag.level].bitrate / 8)),
              pos = v.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel >= 0; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              fragLevelNextLoadedDelay = frag.duration * levels[nextLoadLevel].bitrate / (8 * 0.8 * loadRate);
              _logger.logger.log('fragLoadedDelay/bufferStarvationDelay/fragLevelNextLoadedDelay[' + nextLoadLevel + '] :' + fragLoadedDelay.toFixed(1) + '/' + bufferStarvationDelay.toFixed(1) + '/' + fragLevelNextLoadedDelay.toFixed(1));
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              // ensure nextLoadLevel is not negative
              nextLoadLevel = Math.max(0, nextLoadLevel);
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this.bwEstimator.sample(requestDelay, stats.loaded);
              // abort fragment loading ...
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel);
              //abort fragment loading
              frag.loader.abort();
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        var stats = data.stats;
        // only update stats on first frag loading
        // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
        // and leading to wrong bw estimation
        if (stats.aborted === undefined && frag.loadCounter === 1) {
          this.bwEstimator.sample(performance.now() - stats.trequest, stats.loaded);
        }

        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      this._autoLevelCapping = newLevel;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this.hls,
          config = hls.config,
          levels = hls.levels,
          v = hls.media,
          i = void 0,
          maxAutoLevel = void 0;
      if (this._autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = this._autoLevelCapping;
      }

      // in case next auto level has been forced, return it straight-away (but capped)
      if (this._nextAutoLevel !== -1) {
        return Math.min(this._nextAutoLevel, maxAutoLevel);
      }
      var playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() / playbackRate : config.abrEwmaDefaultEstimate / playbackRate,
          adjustedbw = void 0;
      // follow algorithm captured from stagefright :
      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
      // Pick the highest bandwidth stream below or equal to estimated bandwidth.
      for (i = 0; i <= maxAutoLevel; i++) {
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= this.lastLoadedFragLevel) {
          adjustedbw = config.abrBandWidthFactor * avgbw;
        } else {
          adjustedbw = config.abrBandWidthUpFactor * avgbw;
        }
        if (adjustedbw < levels[i].bitrate) {
          return Math.max(0, i - 1);
        }
      }
      return i - 1;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

},{"../errors":27,"../event-handler":28,"../events":29,"../helper/buffer-helper":31,"../utils/logger":46,"./ewma-bandwidth-estimator":8}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var AudioStreamController = function (_EventHandler) {
  _inherits(AudioStreamController, _EventHandler);

  function AudioStreamController(hls) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(AudioStreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var media = this.media,
            lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.fragLoadError = 0;
        if (media && lastCurrentTime) {
          _logger.logger.log('configure startPosition @' + lastCurrentTime);
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos,
          track,
          trackDetails,
          hls = this.hls,
          config = hls.config;
      //logger.log('audioStream:' + this.state);
      switch (this.state) {
        case State.ERROR:
        //don't do anything in error state to avoid breaking further ...
        case State.PAUSED:
          //don't do anything in paused state either ...
          break;
        case State.STARTING:
          this.state = State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case State.IDLE:
          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }
          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,
              maxBufLen = config.maxMaxBufferLength;

          // if buffer length is less than maxBufLen try to load a new fragment
          if (bufferLen < maxBufLen && this.trackId < this.tracks.length) {
            trackDetails = this.tracks[this.trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = State.WAITING_TRACK;
              break;
            }

            // we just got done loading the final fragment, check if we need to finalize media stream
            if (!trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
              // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
              // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
              // between different renditions. using half frag duration should help cope with these cases.
              if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
                // Finalize the media stream
                this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                this.state = State.ENDED;
                break;
              }
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // if bufferEnd before start of playlist, load first fragment
            if (bufferEnd < start) {
              frag = fragments[0];
            } else {
              (function () {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }
                  foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
                    // offset should be within fragment boundary - config.maxFragLookUpTolerance
                    // this is to cope with situations like
                    // bufferEnd = 9.991
                    // frag[Ø] : [0,10]
                    // frag[1] : [10,20]
                    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                    //              frag start               frag start+duration
                    //                  |-----------------------------|
                    //              <--->                         <--->
                    //  ...--------><-----------------------------><---------....
                    // previous frag         matching fragment         next frag
                    //  return -1             return 0                 return 1
                    //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                    if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
                      return 1;
                    } else if (candidate.start - maxFragLookUpTolerance > bufferEnd) {
                      return -1;
                    }
                    return 0;
                  });
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              })();
            }
            if (frag) {
              //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId);
                this.state = State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // ensure that we are not reloading the same fragments in loop ...
                if (this.fragLoadIdx !== undefined) {
                  this.fragLoadIdx++;
                } else {
                  this.fragLoadIdx = 0;
                }
                if (frag.loadCounter) {
                  frag.loadCounter++;
                  var maxThreshold = config.fragLoadingLoopThreshold;
                  // if this frag has already been loaded 3 times, and if it has been reloaded recently
                  if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                    return;
                  }
                } else {
                  frag.loadCounter = 1;
                }
                frag.loadIdx = this.fragLoadIdx;
                this.fragCurrent = frag;
                this.startFragRequested = true;
                hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                this.state = State.FRAG_LOADING;
              }
            }
          }
          break;
        case State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var tracks = this.tracks;
      if (tracks) {
        // reset fragment load counter
        tracks.forEach(function (track) {
          if (track.details) {
            track.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (this.media) {
        this.lastCurrentTime = this.media.currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitch',
    value: function onAudioTrackSwitch(data) {
      this.trackId = data.id;
      this.state = State.IDLE;

      this.fragCurrent = null;
      this.state = State.PAUSED;
      // destroy useless demuxer when switching audio to main
      if (data.type === 'main') {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
      }
      // flush audio source buffer
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var details = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = details.totalduration;

      _logger.logger.log('track ' + trackId + ' loaded [' + details.startSN + ',' + details.endSN + '],duration:' + duration);
      details.PTSKnown = false;
      track.details = details;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = details.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === State.WAITING_TRACK) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'audio' && data.frag.level === fragCurrent.level && data.frag.sn === fragCurrent.sn) {
        this.state = State.PARSING;
        // transmux the MPEG-TS data to ISO-BMFF segments
        this.stats = data.stats;
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            start = fragCurrent.start,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec;
        this.pendingAppending = 0;
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'audio');
        }
        _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
        this.demuxer.push(data.payload, audioCodec, null, start, fragCurrent.cc, trackId, sn, duration, fragCurrent.decryptdata);
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = 'mp4a.40.2';
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.pendingAppending++;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' });
          }
          //trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var track = this.tracks[this.trackId],
            frag = this.fragCurrent;

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        _levelHelper2.default.updateFragPTSDTS(track.details, frag.sn, data.startPTS, data.endPTS);

        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer) {
            _this2.pendingAppending++;
            _this2.hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'audio', content: 'data' });
          }
        });
        this.nextLoadPosition = data.endPTS;
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        switch (this.state) {
          case State.PARSING:
          case State.PARSED:
            this.pendingAppending--;
            this._checkAppendedParsed();
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && this.pendingAppending === 0) {
        var frag = this.fragCurrent,
            stats = this.stats;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            if (loadError <= this.config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to 64s
              var delay = Math.min(Math.pow(2, loadError - 1) * this.config.fragLoadingRetryDelay, 64000);
              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
      this.tick();
    }
  }]);

  return AudioStreamController;
}(_eventHandler2.default);

exports.default = AudioStreamController;

},{"../demux/demuxer":20,"../errors":27,"../event-handler":28,"../events":29,"../helper/buffer-helper":31,"../helper/level-helper":32,"../utils/binary-search":42,"../utils/logger":46,"../utils/timeRanges":48}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    return _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));
  }

  _createClass(AudioTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset audio tracks on manifest loading
      this.tracks = [];
      this.trackId = -1;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.audioTracks || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
      // loop through available audio tracks and autoselect default if needed
      var id = 0;
      tracks.forEach(function (track) {
        if (track.default) {
          _this2.audioTrack = id;
          defaultFound = true;
          return;
        }
        id++;
      });
      if (defaultFound === false && tracks.length) {
        _logger.logger.log('no default audio track defined, use first audio track as default');
        this.audioTrack = 0;
      }
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id < this.tracks.length) {
        _logger.logger.log('audioTrack ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'setAudioTrackInternal',
    value: function setAudioTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            type = audioTrack.type;
        this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, { id: newId, type: type });
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (type !== 'main' && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: audioTrack.url, id: newId });
        }
      }
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

},{"../event-handler":28,"../events":29,"../utils/logger":46}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var audioExpected = data.audio,
          videoExpected = data.video,
          sourceBufferNb = 0;
      if (audioExpected || videoExpected) {
        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
      }
      this.sourceBufferNb = sourceBufferNb;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        //Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = URL.createObjectURL(ms);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          this.media.removeAttribute('src');
          this.media.load();
        }

        this.mediaSource = null;
        this.media = null;
        this.pendingTracks = {};
        this.sourceBuffer = {};
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      // if any buffer codecs pending, check if we have enough to create sourceBuffers
      var pendingTracks = this.pendingTracks,
          pendingTracksNb = Object.keys(pendingTracks).length;
      // if any pending tracks and (if nb of pending tracks matching expected nb or if unknoown expected nb)
      if (pendingTracksNb && (this.sourceBufferNb === pendingTracksNb || this.sourceBufferNb === 0)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }
      this.appending = false;
      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: this.parent });

      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:' + event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      if (Object.keys(this.sourceBuffer).length === 0) {
        for (var trackName in tracks) {
          this.pendingTracks[trackName] = tracks[trackName];
        }
        var mediaSource = this.mediaSource;
        if (mediaSource && mediaSource.readyState === 'open') {
          // try to create sourcebuffers if mediasource opened
          this.checkPendingTracks();
        }
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;

      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer with mimeType:' + mimeType);
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            track.buffer = sb;
          } catch (err) {
            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
          }
        }
      }
      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }
        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:' + data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false, frag: this.fragCurrent });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        if (!sb[type].ended) {
          return;
        }
        if (sb[type].updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
      //Notify the media element that it now has all of the media data
      mediaSource.endOfStream();
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediatly
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(event) {
      var details = event.details;
      if (details.fragments.length === 0) {
        return;
      }
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this.updateMediaElementDuration();
    }

    // https://github.com/dailymotion/hls.js/issues/355

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      if (this._levelDuration === null) {
        return;
      }
      var media = this.media,
          mediaSource = this.mediaSource,
          sourceBuffer = this.sourceBuffer;
      if (!media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
        return;
      }
      for (var type in sourceBuffer) {
        if (sourceBuffer[type].updating) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }
      if (this._msDuration === null) {
        // initialise to the value that the media source is reporting
        this._msDuration = mediaSource.duration;
      }
      // this._levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update mediasource duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level, as they
      if (this._levelDuration > this._msDuration) {
        _logger.logger.log('Updating mediasource duration to ' + this._levelDuration);
        mediaSource.duration = this._levelDuration;
        this._msDuration = this._levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        for (var type in sourceBuffer) {
          appended += sourceBuffer[type].buffered.length;
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          sourceBuffer = this.sourceBuffer,
          segments = this.segments;
      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          //logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type;
            if (sourceBuffer[type]) {
              // reset sourceBuffer ended flag before appending segment
              sourceBuffer[type].ended = false;
              //logger.log(`appending ${segment.content} ${segment.type} SB, size:${segment.data.length}, ${segment.parent}`);
              this.parent = segment.parent;
              sourceBuffer[type].appendBuffer(segment.data);
              this.appendError = 0;
              this.appended++;
              this.appending = true;
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }
              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              event.frag = this.fragCurrent;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
                return;
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              hls.trigger(_events2.default.ERROR, event);
              return;
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb,
          i,
          bufStart,
          bufEnd,
          flushStart,
          flushEnd,
          sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }
            sb = sourceBuffer[type];
            if (!sb.updating) {
              for (i = 0; i < sb.buffered.length; i++) {
                bufStart = sb.buffered.start(i);
                bufEnd = sb.buffered.end(i);
                // workaround firefox not able to properly flush multiple buffered range.
                if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                  flushStart = startOffset;
                  flushEnd = endOffset;
                } else {
                  flushStart = Math.max(bufStart, startOffset);
                  flushEnd = Math.min(bufEnd, endOffset);
                }
                /* sometimes sourcebuffer.remove() does not flush
                   the exact expected time range.
                   to avoid rounding issues/infinite loop,
                   only flush buffer range of length greater than 500ms.
                */
                if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                  this.flushBufferCounter++;
                  _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                  sb.remove(flushStart, flushEnd);
                  return false;
                }
              }
            } else {
              //logger.log('abort ' + type + ' append in progress');
              // this will abort any appending in progress
              //sb.abort();
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = this.restrictedLevels = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          this.timer = clearInterval(this.timer);
        }
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      if (!this.restrictedLevels) {
        this.restrictedLevels = [];
      }
      if (!this.isLevelRestricted(data.droppedLevel)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (this.hls.config.capLevelToPlayerSize) {
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.levels = data.levels;
        this.hls.firstLevel = this.getMaxLevel(data.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
      }
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          this.hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (this.hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            this.hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = this.hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var result = 0,
          i = void 0,
          level = void 0,
          mWidth = this.mediaWidth,
          mHeight = this.mediaHeight,
          lWidth = 0,
          lHeight = 0;

      for (i = 0; i <= capLevelIndex; i++) {
        level = this.levels[i];
        if (this.isLevelRestricted(i)) {
          break;
        }
        result = i;
        lWidth = level.width;
        lHeight = level.height;
        if (mWidth <= lWidth || mHeight <= lHeight) {
          break;
        }
      }
      return result;
    }
  }, {
    key: 'isLevelRestricted',
    value: function isLevelRestricted(level) {
      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      if (this.media) {
        width = this.media.width || this.media.clientWidth || this.media.offsetWidth;
        width *= this.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      if (this.media) {
        height = this.media.height || this.media.clientHeight || this.media.offsetHeight;
        height *= this.contentScaleFactor;
      }
      return height;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

},{"../event-handler":28,"../events":29}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = require('../utils/ewma');

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      //console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (!this.fast_ || !this.slow_ || this.fast_.getTotalWeight() < this.minWeight_) {
        return this.defaultEstimate_;
      }
      //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
      //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
      // Take the minimum of these two estimates.  This should have the effect of
      // adapting down quickly, but up more slowly.
      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

},{"../utils/ewma":45}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      if (this.hls.config.capLevelOnFPSDrop) {
        this.video = data.media instanceof HTMLVideoElement ? data.media : null;
        if (typeof this.video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), this.hls.config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod;
          this.hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > this.hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = this.hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (this.hls.autoLevelCapping === -1 || this.hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                this.hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: this.hls.currentLevel });
                this.hls.autoLevelCapping = currentLevel;
                this.hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      if (this.video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = this.video.getVideoPlaybackQuality();
          this.checkFPS(this.video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(this.video, this.video.webkitDecodedFrameCount, this.video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

},{"../event-handler":28,"../events":29,"../utils/logger":46}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

    _this.ontick = _this.tick.bind(_this);
    _this._manualLevel = _this._autoLevelCapping = -1;
    return _this;
  }

  _createClass(LevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this._manualLevel = -1;
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.canload = true;
      // speed up live playlist refresh if timer exists
      if (this.timer) {
        this.tick();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels0 = [],
          levels = [],
          bitrateStart,
          i,
          bitrateSet = {},
          videoCodecFound = false,
          audioCodecFound = false,
          hls = this.hls;

      // regroup redundant level together
      data.levels.forEach(function (level) {
        if (level.videoCodec) {
          videoCodecFound = true;
        }
        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
          audioCodecFound = true;
        }
        var redundantLevelId = bitrateSet[level.bitrate];
        if (redundantLevelId === undefined) {
          bitrateSet[level.bitrate] = levels0.length;
          level.url = [level.url];
          level.urlId = 0;
          levels0.push(level);
        } else {
          levels0[redundantLevelId].url.push(level.url);
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels0.forEach(function (level) {
          if (level.videoCodec) {
            levels.push(level);
          }
        });
      } else {
        levels = levels0;
      }

      // only keep level with supported audio/video codecs
      levels = levels.filter(function (level) {
        var checkSupportedAudio = function checkSupportedAudio(codec) {
          return MediaSource.isTypeSupported('audio/mp4;codecs=' + codec);
        };
        var checkSupportedVideo = function checkSupportedVideo(codec) {
          return MediaSource.isTypeSupported('video/mp4;codecs=' + codec);
        };
        var audioCodec = level.audioCodec,
            videoCodec = level.videoCodec;

        return (!audioCodec || checkSupportedAudio(audioCodec)) && (!videoCodec || checkSupportedVideo(videoCodec));
      });

      if (levels.length) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }
        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: this._levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound });
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
      }
      return;
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this._level = newLevel;
        _logger.logger.log('switching to level ' + newLevel);
        this.hls.trigger(_events2.default.LEVEL_SWITCH, { level: newLevel });
        var level = levels[newLevel],
            levelDetails = level.details;
        // check if we need to load playlist for this level. don't reload live playlist more than once per second
        if (!levelDetails || levelDetails.live === true && performance.now() - levelDetails.tload > 1000) {
          // level not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for level ' + newLevel);
          var urlId = level.urlId;
          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        return;
      }

      var details = data.details,
          hls = this.hls,
          levelId = void 0,
          level = void 0,
          levelError = false;
      // try to recover not fatal errors
      switch (details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelId = data.frag.level;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelId = data.context.level;
          levelError = true;
          break;
        default:
          break;
      }
      /* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       * don't raise FRAG_LOAD_ERROR and FRAG_LOAD_TIMEOUT as fatal, as it is handled by mediaController
       */
      if (levelId !== undefined) {
        level = this._levels[levelId];
        if (level.urlId < level.url.length - 1) {
          level.urlId++;
          level.details = undefined;
          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
        } else {
          // we could try to recover if in auto mode and current level not lowest level (0)
          var recoverable = this._manualLevel === -1 && levelId;
          if (recoverable) {
            _logger.logger.warn('level controller,' + details + ': emergency switch-down for next fragment');
            hls.abrController.nextAutoLevel = 0;
          } else if (level && level.details && level.details.live) {
            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
            if (levelError) {
              // reset this._level so that another call to set level() will retrigger a frag load
              this._level = undefined;
            }
            // FRAG_LOAD_ERROR and FRAG_LOAD_TIMEOUT are handled by mediaController
          } else if (details !== _errors.ErrorDetails.FRAG_LOAD_ERROR && details !== _errors.ErrorDetails.FRAG_LOAD_TIMEOUT) {
            _logger.logger.error('cannot recover ' + details + ' error');
            this._level = undefined;
            // stopping live reloading timer if any
            if (this.timer) {
              clearTimeout(this.timer);
              this.timer = null;
            }
            // redispatch same error but with fatal set to true
            data.fatal = true;
            hls.trigger(_events2.default.ERROR, data);
          }
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      // only process level loaded events matching with expected level
      if (data.level === this._level) {
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
              curLevel = this._levels[data.level],
              curDetails = curLevel.details;
          if (curDetails && newDetails.endSN === curDetails.endSN) {
            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
            // changed then it MUST wait for a period of one-half the target
            // duration before retrying.
            reloadInterval /= 2;
            _logger.logger.log('same live playlist, reload twice faster');
          }
          // decrement reloadInterval with level loading delay
          reloadInterval -= performance.now() - data.stats.trequest;
          // in any case, don't reload more than every second
          reloadInterval = Math.max(1000, Math.round(reloadInterval));
          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
          this.timer = setTimeout(this.ontick, reloadInterval);
        } else {
          this.timer = null;
        }
      }
    }
  }, {
    key: 'tick',
    value: function tick() {
      var levelId = this._level;
      if (levelId !== undefined && this.canload) {
        var level = this._levels[levelId],
            urlId = level.urlId;
        this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels && levels.length > newLevel) {
        if (this._level !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this._manualLevel;
    },
    set: function set(newLevel) {
      this._manualLevel = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      if (this._startLevel === undefined) {
        return this._firstLevel;
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this._manualLevel !== -1) {
        return this._manualLevel;
      } else {
        return this.hls.abrController.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this._manualLevel === -1) {
        this.hls.abrController.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var StreamController = function (_EventHandler) {
  _inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(StreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var media = this.media,
            lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.demuxer = new _demuxer2.default(this.hls, 'main');
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.level = -1;
        this.fragLoadError = 0;
        if (media && lastCurrentTime > 0) {
          _logger.logger.log('configure startPosition @' + lastCurrentTime);
          if (!this.lastPaused) {
            _logger.logger.log('resuming video');
            media.play();
          }
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        _logger.logger.warn('cannot start loading as manifest not parsed yet');
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case State.STARTING:
          var hls = this.hls;
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.fragBitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.state = State.WAITING_LEVEL;
          this.loadedmetadata = false;
          break;
        case State.IDLE:
          // when this returns false there was an error and we shall return immediatly
          // from current tick
          if (!this._doTickIdle()) {
            return;
          }
          break;
        case State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.ERROR:
        case State.PAUSED:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if video not attached AND
      // start fragment already requested OR start frag prefetch disable
      // exit loop
      // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
        return true;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }
      // determine next load level
      var level = hls.nextLoadLevel;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      var maxBufLen = void 0;
      if (this.levels[level].hasOwnProperty('bitrate')) {
        maxBufLen = Math.max(8 * config.maxBufferSize / this.levels[level].bitrate, config.maxBufferLength);
        maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return true;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      hls.nextLoadLevel = level;
      this.level = level;

      var levelDetails = this.levels[level].details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = State.WAITING_LEVEL;
        return true;
      }

      // we just got done loading the final fragment, check if we need to finalize media stream
      var fragPrevious = this.fragPrevious;
      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
        // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
        // between different renditions. using half frag duration should help cope with these cases.
        if (!media.seeking || media.duration - bufferInfo.end <= fragPrevious.duration / 2) {
          // Finalize the media stream
          var data = {};
          if (this.audioTrackType === 'AUDIO') {
            data.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_EOS, data);
          this.state = State.ENDED;
          return true;
        }
      }

      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      return this._fetchPayloadOrEos({ pos: pos, bufferInfo: bufferInfo, levelDetails: levelDetails });
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(_ref) {
      var pos = _ref.pos;
      var bufferInfo = _ref.bufferInfo;
      var levelDetails = _ref.levelDetails;

      var fragPrevious = this.fragPrevious,
          level = this.level;

      // find fragment index, contiguous with end of buffer position
      var fragments = levelDetails.fragments,
          fragLen = fragments.length,
          start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      // in case of live playlist we need to ensure that requested position is not located before playlist start
      if (levelDetails.live) {
        frag = this._ensureFragmentAtLivePoint({ levelDetails: levelDetails, bufferEnd: bufferEnd, start: start, end: end, fragPrevious: fragPrevious, fragments: fragments, fragLen: fragLen });
        // if it explicitely returns null don't load any fragment and exit function now
        if (frag === null) {
          return false;
        }
      } else {
        // VoD playlist: if bufferEnd before start of playlist, load first fragment
        if (bufferEnd < start) {
          frag = fragments[0];
        }
      }
      if (!frag) {
        frag = this._findFragment({ start: start, fragPrevious: fragPrevious, fragLen: fragLen, fragments: fragments, bufferEnd: bufferEnd, end: end, levelDetails: levelDetails });
      }
      if (frag) {
        return this._loadFragmentOrKey({ frag: frag, level: level, levelDetails: levelDetails, pos: pos, bufferEnd: bufferEnd });
      }
      return true;
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(_ref2) {
      var levelDetails = _ref2.levelDetails;
      var bufferEnd = _ref2.bufferEnd;
      var start = _ref2.start;
      var end = _ref2.end;
      var fragPrevious = _ref2.fragPrevious;
      var fragments = _ref2.fragments;
      var fragLen = _ref2.fragLen;

      var config = this.hls.config;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        var media = this.media;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      if (levelDetails.PTSKnown && bufferEnd > end) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          var targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            frag = fragments[targetSN - levelDetails.startSN];
            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }
      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(_ref3) {
      var start = _ref3.start;
      var fragPrevious = _ref3.fragPrevious;
      var fragLen = _ref3.fragLen;
      var fragments = _ref3.fragments;
      var bufferEnd = _ref3.bufferEnd;
      var end = _ref3.end;
      var levelDetails = _ref3.levelDetails;

      var config = this.hls.config;

      var frag = void 0,
          foundFrag = void 0,
          maxFragLookUpTolerance = config.maxFragLookUpTolerance;

      if (bufferEnd < end) {
        if (bufferEnd > end - maxFragLookUpTolerance) {
          maxFragLookUpTolerance = 0;
        }
        foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
          // offset should be within fragment boundary - config.maxFragLookUpTolerance
          // this is to cope with situations like
          // bufferEnd = 9.991
          // frag[Ø] : [0,10]
          // frag[1] : [10,20]
          // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
          //              frag start               frag start+duration
          //                  |-----------------------------|
          //              <--->                         <--->
          //  ...--------><-----------------------------><---------....
          // previous frag         matching fragment         next frag
          //  return -1             return 0                 return 1
          //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
          if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
            return 1;
          } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
          else if (candidate.start - maxFragLookUpTolerance > bufferEnd && candidate.start) {
              return -1;
            }
          return 0;
        });
      } else {
        // reach end of playlist
        foundFrag = fragments[fragLen - 1];
      }
      if (foundFrag) {
        frag = foundFrag;
        start = foundFrag.start;
        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
          if (frag.sn < levelDetails.endSN) {
            var deltaPTS = fragPrevious.deltaPTS,
                curSNIdx = frag.sn - levelDetails.startSN;
            // if there is a significant delta between audio and video, larger than max allowed hole,
            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
            // let's try to load previous fragment again to get last keyframe
            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
              frag = fragments[curSNIdx - 1];
              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
              fragPrevious.loadCounter--;
            } else {
              frag = fragments[curSNIdx + 1];
              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
            }
          } else {
            frag = null;
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadFragmentOrKey',
    value: function _loadFragmentOrKey(_ref4) {
      var frag = _ref4.frag;
      var level = _ref4.level;
      var levelDetails = _ref4.levelDetails;
      var pos = _ref4.pos;
      var bufferEnd = _ref4.bufferEnd;

      var hls = this.hls,
          config = hls.config;

      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
      if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
        this.state = State.KEY_LOADING;
        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
      } else {
        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
        // ensure that we are not reloading the same fragments in loop ...
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx++;
        } else {
          this.fragLoadIdx = 0;
        }
        if (frag.loadCounter) {
          frag.loadCounter++;
          var maxThreshold = config.fragLoadingLoopThreshold;
          // if this frag has already been loaded 3 times, and if it has been reloaded recently
          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
            return false;
          }
        } else {
          frag.loadCounter = 1;
        }
        frag.loadIdx = this.fragLoadIdx;
        frag.autoLevel = hls.autoLevelEnabled;
        this.fragCurrent = frag;
        this.startFragRequested = true;
        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        this.state = State.FRAG_LOADING;
        return true;
      }
    }
  }, {
    key: 'getBufferRange',
    value: function getBufferRange(position) {
      var i,
          range,
          bufferRange = this.bufferRange;
      if (bufferRange) {
        for (i = bufferRange.length - 1; i >= 0; i--) {
          range = bufferRange[i];
          if (position >= range.start && position <= range.end) {
            return range;
          }
        }
      }
      return null;
    }
  }, {
    key: 'followingBufferRange',
    value: function followingBufferRange(range) {
      if (range) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferRange(range.end + 0.5);
      }
      return null;
    }
  }, {
    key: 'isBuffered',
    value: function isBuffered(position) {
      var media = this.media;
      if (media) {
        var buffered = media.buffered;
        for (var i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var rangeCurrent,
          currentTime,
          video = this.media;
      if (video && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > video.playbackRate * this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }
        if (this.isBuffered(currentTime)) {
          rangeCurrent = this.getBufferRange(currentTime);
        } else if (this.isBuffered(currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          rangeCurrent = this.getBufferRange(currentTime + 0.1);
        }
        if (rangeCurrent) {
          var fragPlaying = rangeCurrent.frag;
          if (fragPlaying !== this.fragPlaying) {
            this.fragPlaying = fragPlaying;
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }
      this.fragCurrent = null;
      this.state = State.PAUSED;
      // flush everything
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY });
    }

    /*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (this.isBuffered(media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }
  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      /* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            currentRange = void 0,
            nextRange = void 0;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        currentRange = this.getBufferRange(media.currentTime);
        if (currentRange && currentRange.start > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.state = State.PAUSED;
          this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: currentRange.start - 1 });
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        //logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextRange = this.getBufferRange(media.currentTime + fetchdelay);
        if (nextRange) {
          // we can flush buffer range following this one without stalling playback
          nextRange = this.followingBufferRange(nextRange);
          if (nextRange) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            // flush position is the start position of this new buffer
            this.state = State.PAUSED;
            this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: nextRange.start, endOffset: Number.POSITIVE_INFINITY });
          }
        }
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var levels = this.levels;
      if (levels) {
        // reset fragment load counter
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      _logger.logger.log('media seeking to ' + currentTime);
      if (this.state === State.FRAG_LOADING) {
        var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, this.config.maxBufferHole),
            fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = this.config.maxFragLookUpTolerance,
              fragStartOffset = fragCurrent.start - tolerance,
              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      _logger.logger.log('media seeked to ' + this.media.currentTime);
      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      _logger.logger.log('media ended');
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.bufferRange = [];
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }
          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startLevelLoaded = false;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details,
          newLevelId = data.level,
          curLevel = this.levels[newLevelId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
      this.levelLastLoaded = newLevelId;

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'main' && data.frag.level === fragCurrent.level && data.frag.sn === fragCurrent.sn) {
        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of level ' + fragCurrent.level);
        if (this.fragBitrateTest === true) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = State.IDLE;
          this.fragBitrateTest = false;
          this.startFragRequested = false;
          data.stats.tparsed = data.stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: data.stats, frag: fragCurrent, id: 'main' });
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.stats = data.stats;
          var currentLevel = this.levels[this.level],
              details = currentLevel.details,
              duration = details.totalduration,
              start = fragCurrent.startDTS !== undefined ? fragCurrent.startDTS : fragCurrent.start,
              level = fragCurrent.level,
              sn = fragCurrent.sn,
              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec === undefined) {
              audioCodec = this.lastAudioCodec;
            }
            if (audioCodec) {
              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                audioCodec = 'mp4a.40.2';
              } else {
                audioCodec = 'mp4a.40.5';
              }
            }
          }
          this.pendingAppending = 0;
          _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
          var demuxer = this.demuxer;
          if (!demuxer) {
            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
          }
          demuxer.push(data.payload, audioCodec, currentLevel.videoCodec, start, fragCurrent.cc, level, sn, duration, fragCurrent.decryptdata);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            trackName,
            track;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.audioTrackType === 'AUDIO') {
          delete tracks.audio;
        }
        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1) {
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }

        // if remuxer specify that a unique track needs to generated,
        // let's merge all tracks together
        if (data.unique) {
          var mergedTrack = {
            codec: '',
            levelCodec: ''
          };
          for (trackName in data.tracks) {
            track = tracks[trackName];
            mergedTrack.container = track.container;
            if (mergedTrack.codec) {
              mergedTrack.codec += ',';
              mergedTrack.levelCodec += ',';
            }
            if (track.codec) {
              mergedTrack.codec += track.codec;
            }
            if (track.levelCodec) {
              mergedTrack.levelCodec += track.levelCodec;
            }
          }
          tracks = { audiovideo: mergedTrack };
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.pendingAppending++;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && (data.type !== 'audio' || this.audioTrackType !== 'AUDIO') && // filter out main audio if audio track is loaded through audio stream controller
      this.state === State.PARSING) {
        var level = this.levels[this.level],
            frag = this.fragCurrent;

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift });

        // has remuxer dropped video frames located before first keyframe ?
        if (data.type === 'video') {
          frag.dropped = data.dropped;
        }

        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer) {
            _this2.pendingAppending++;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });

        this.nextLoadPosition = data.endPTS;
        this.bufferRange.push({ type: data.type, start: data.startPTS, end: data.endPTS, frag: frag });

        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitch',
    value: function onAudioTrackSwitch(data) {
      var audioTrackType = data.type;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      if (audioTrackType === 'main') {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        }
      } else {
        // if we switch on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (this.videoBuffer && this.mediaBuffer !== this.videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = this.videoBuffer;
        }
      }
      this.audioTrackType = audioTrackType;
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        switch (this.state) {
          case State.PARSING:
          case State.PARSED:
            this.pendingAppending--;
            this._checkAppendedParsed();
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && this.pendingAppending === 0) {
        var frag = this.fragCurrent,
            stats = this.stats;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            if (loadError <= this.config.fragLoadingMaxRetry ||
            // keep retrying / don't raise fatal network error if current position is buffered
            this.media && this.isBuffered(this.media.currentTime)) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to 64s
              var delay = Math.min(Math.pow(2, loadError - 1) * this.config.fragLoadingRetryDelay, 64000);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('mediaController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // only reduce max buf len if in appending state
          if (this.state === State.PARSING || this.state === State.PARSED) {
            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
            this.config.maxMaxBufferLength /= 2;
            _logger.logger.warn('reduce max buffer length to ' + this.config.maxMaxBufferLength + 's and switch to IDLE state');
            // increase fragment load Index to avoid frag loop loading error after buffer flush
            this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
            this.state = State.IDLE;
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;
      var vendor = navigator.vendor,
          userAgent = navigator.userAgent;
      var isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
      if (media && media.readyState) {
        var currentTime = media.currentTime,
            buffered = media.buffered;
        // adjust currentTime to start position on loaded metadata
        if (!this.loadedmetadata && buffered.length) {
          this.loadedmetadata = true;
          // only adjust currentTime if different from startPosition or if startPosition not buffered
          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
          var startPosition = this.startPosition,
              startPositionBuffered = this.isBuffered(startPosition);
          // if currentTime not matching with expected startPosition or startPosition not buffered
          if (currentTime !== startPosition || !startPositionBuffered) {
            _logger.logger.log('target start position:' + startPosition);
            // if startPosition not buffered, let's seek to buffered.start(0)
            if (!startPositionBuffered) {
              startPosition = buffered.start(0);
              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
            }
            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
            // readyState <= 2 can not successfully seek in safari
            if (!isSafari || media.readyState > 2) {
              media.currentTime = startPosition;
            }
          }
        } else if (this.immediateSwitch) {
          this.immediateLevelSwitchEnd();
        } else {
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
              expectedPlaying = !(media.paused || // not playing when media is paused
          media.ended || // not playing when media is ended
          media.buffered.length === 0),
              // not playing if nothing buffered
          jumpThreshold = 0.4,
              // tolerance needed as some browsers stalls playback before reaching buffered range end
          playheadMoving = currentTime > media.playbackRate * this.lastCurrentTime;

          if (this.stalled && playheadMoving) {
            this.stalled = false;
            _logger.logger.log('playback not stuck anymore @' + currentTime);
          }
          // check buffer upfront
          // if less than jumpThreshold second is buffered, let's check in more details
          if (expectedPlaying && bufferInfo.len <= jumpThreshold) {
            if (playheadMoving) {
              // playhead moving
              jumpThreshold = 0;
              this.seekHoleNudgeDuration = 0;
            } else {
              // playhead not moving AND media expected to play
              if (!this.stalled) {
                this.seekHoleNudgeDuration = 0;
                _logger.logger.log('playback seems stuck @' + currentTime);
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false });
                this.stalled = true;
              } else {
                this.seekHoleNudgeDuration += this.config.seekHoleNudgeDuration;
              }
            }
            // if we are below threshold, try to jump to start of next buffer range if close
            if (bufferInfo.len <= jumpThreshold) {
              // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
              var nextBufferStart = bufferInfo.nextStart,
                  delta = nextBufferStart - currentTime;
              if (nextBufferStart && delta < this.config.maxSeekHole && delta > 0) {
                // next buffer is close ! adjust currentTime to nextBufferStart
                // this will ensure effective video decoding
                _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + this.seekHoleNudgeDuration);
                var hole = nextBufferStart + this.seekHoleNudgeDuration - media.currentTime;
                // frequently seeking may cause frequently flicker in safari
                if (!isSafari || this.seekHoleNudgeDuration && this.seekHoleNudgeDuration % (10 * this.config.seekHoleNudgeDuration) < this.config.seekHoleNudgeDuration) {
                  media.currentTime = nextBufferStart + this.seekHoleNudgeDuration;
                }
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: hole });
              }
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, rebuild buffer Range array
        loop through existing buffer range and check if
        corresponding range is still buffered. only push to new array already buffered range
      */
      var newRange = [],
          range,
          i;
      for (i = 0; i < this.bufferRange.length; i++) {
        range = this.bufferRange[i];
        if (this.isBuffered((range.start + range.end) / 2)) {
          newRange.push(range);
        }
      }
      this.bufferRange = newRange;

      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('engine state transition from ' + previousState + ' to ' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      if (this.media) {
        var range = this.getBufferRange(this.media.currentTime);
        if (range) {
          return range.frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferRange',
    get: function get() {
      if (this.media) {
        // first get end range of current fragment
        return this.followingBufferRange(this.getBufferRange(this.media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var range = this.nextBufferRange;
      if (range) {
        return range.frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_eventHandler2.default);

exports.default = StreamController;

},{"../demux/demuxer":20,"../errors":27,"../event-handler":28,"../events":29,"../helper/buffer-helper":31,"../helper/level-helper":32,"../utils/binary-search":42,"../utils/logger":46,"../utils/timeRanges":48}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = require('../utils/cea-608-parser');

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCH));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;

    if (_this.config.enableCEA708Captions) {
      var self = _this;

      var channel1 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack1) {
            self.textTrack1 = self.createTextTrack('captions', 'Unknown CC1', 'en');
            //            self.textTrack1.mode = 'showing';
          }

          self.Cues.newCue(self.textTrack1, startTime, endTime, screen);
        }
      };

      var channel2 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack2) {
            self.textTrack2 = self.createTextTrack('captions', 'Unknown CC2', 'es');
          }

          self.Cues.newCue(self.textTrack2, startTime, endTime, screen);
        }
      };

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'clearCurrentCues',
    value: function clearCurrentCues(track) {
      if (track && track.cues) {
        while (track.cues.length > 0) {
          track.removeCue(track.cues[0]);
        }
      }
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      if (this.media) {
        return this.media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {}
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastPts = Number.NEGATIVE_INFINITY;
    }
  }, {
    key: 'onLevelSwitch',
    value: function onLevelSwitch() {
      if (this.hls.currentLevel.closedCaptions === 'NONE') {
        this.enabled = false;
      } else {
        this.enabled = true;
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      if (data.frag.type === 'main') {
        var pts = data.frag.start; //Number.POSITIVE_INFINITY;
        // if this is a frag for a previously loaded timerange, remove all captions
        // TODO: consider just removing captions for the timerange
        if (pts <= this.lastPts) {
          this.clearCurrentCues(this.textTrack1);
          this.clearCurrentCues(this.textTrack2);
        }
        this.lastPts = pts;
      }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) === 0 ? false : true;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) // || ccType === 1
            {
              actualCCBytes.push(ccbyte1);
              actualCCBytes.push(ccbyte2);
            }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

},{"../event-handler":28,"../events":29,"../utils/cea-608-parser":43}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 *
 * This file contains an adaptation of the AES decryption algorithm
 * from the Standford Javascript Cryptography Library. That work is
 * covered by the following copyright and permissions notice:
 *
 * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the authors.
 */
var AES = function () {

  /**
   * Schedule out an AES key for both encryption and decryption. This
   * is a low-level class. Use a cipher mode to do bulk encryption.
   *
   * @constructor
   * @param key {Array} The key as an array of 4, 6 or 8 words.
   */
  function AES(key) {
    _classCallCheck(this, AES);

    /**
     * The expanded S-box and inverse S-box tables. These will be computed
     * on the client so that we don't have to send them down the wire.
     *
     * There are two tables, _tables[0] is for encryption and
     * _tables[1] is for decryption.
     *
     * The first 4 sub-tables are the expanded S-box with MixColumns. The
     * last (_tables[01][4]) is the S-box itself.
     *
     * @private
     */
    this._tables = [[[], [], [], [], []], [[], [], [], [], []]];

    this._precompute();

    var i,
        j,
        tmp,
        encKey,
        decKey,
        sbox = this._tables[0][4],
        decTable = this._tables[1],
        keyLen = key.length,
        rcon = 1;

    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
      throw new Error('Invalid aes key size=' + keyLen);
    }

    encKey = key.slice(0);
    decKey = [];
    this._key = [encKey, decKey];

    // schedule encryption keys
    for (i = keyLen; i < 4 * keyLen + 28; i++) {
      tmp = encKey[i - 1];

      // apply sbox
      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];

        // shift rows and add rcon
        if (i % keyLen === 0) {
          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
          rcon = rcon << 1 ^ (rcon >> 7) * 283;
        }
      }

      encKey[i] = encKey[i - keyLen] ^ tmp;
    }

    // schedule decryption keys
    for (j = 0; i; j++, i--) {
      tmp = encKey[j & 3 ? i : i - 4];
      if (i <= 4 || j < 4) {
        decKey[j] = tmp;
      } else {
        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
      }
    }
  }

  /**
   * Expand the S-box tables.
   *
   * @private
   */


  _createClass(AES, [{
    key: '_precompute',
    value: function _precompute() {
      var encTable = this._tables[0],
          decTable = this._tables[1],
          sbox = encTable[4],
          sboxInv = decTable[4],
          i,
          x,
          xInv,
          d = [],
          th = [],
          x2,
          x4,
          x8,
          s,
          tEnc,
          tDec;

      // Compute double and third tables
      for (i = 0; i < 256; i++) {
        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
      }

      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
        // Compute sbox
        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
        s = s >> 8 ^ s & 255 ^ 99;
        sbox[x] = s;
        sboxInv[s] = x;

        // Compute MixColumns
        x8 = d[x4 = d[x2 = d[x]]];
        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        tEnc = d[s] * 0x101 ^ s * 0x1010100;

        for (i = 0; i < 4; i++) {
          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
        }
      }

      // Compactify. Considerable speedup on Firefox.
      for (i = 0; i < 5; i++) {
        encTable[i] = encTable[i].slice(0);
        decTable[i] = decTable[i].slice(0);
      }
    }

    /**
     * Decrypt 16 bytes, specified as four 32-bit words.
     * @param encrypted0 {number} the first word to decrypt
     * @param encrypted1 {number} the second word to decrypt
     * @param encrypted2 {number} the third word to decrypt
     * @param encrypted3 {number} the fourth word to decrypt
     * @param out {Int32Array} the array to write the decrypted words
     * into
     * @param offset {number} the offset into the output array to start
     * writing results
     * @return {Array} The plaintext.
     */

  }, {
    key: 'decrypt',
    value: function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
      var key = this._key[1],

      // state variables a,b,c,d are loaded with pre-whitened data
      a = encrypted0 ^ key[0],
          b = encrypted3 ^ key[1],
          c = encrypted2 ^ key[2],
          d = encrypted1 ^ key[3],
          a2,
          b2,
          c2,
          nInnerRounds = key.length / 4 - 2,
          // key.length === 2 ?
      i,
          kIndex = 4,
          table = this._tables[1],


      // load up the tables
      table0 = table[0],
          table1 = table[1],
          table2 = table[2],
          table3 = table[3],
          sbox = table[4];

      // Inner rounds. Cribbed from OpenSSL.
      for (i = 0; i < nInnerRounds; i++) {
        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
        kIndex += 4;
        a = a2;b = b2;c = c2;
      }

      // Last round.
      for (i = 0; i < 4; i++) {
        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
        a2 = a;a = b;b = c;c = d;d = a2;
      }
    }
  }]);

  return AES;
}();

exports.default = AES;

},{}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file contains an adaptation of the AES decryption algorithm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * from the Standford Javascript Cryptography Library. That work is
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * covered by the following copyright and permissions notice:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * modification, are permitted provided that the following conditions are
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 1. Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 2. Redistributions in binary form must reproduce the above
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    copyright notice, this list of conditions and the following
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    disclaimer in the documentation and/or other materials provided
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The views and conclusions contained in the software and documentation
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * are those of the authors and should not be interpreted as representing
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * official policies, either expressed or implied, of the authors.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _aes = require('./aes');

var _aes2 = _interopRequireDefault(_aes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AES128Decrypter = function () {
  function AES128Decrypter(key, initVector) {
    _classCallCheck(this, AES128Decrypter);

    this.key = key;
    this.iv = initVector;
  }

  /**
   * Convert network-order (big-endian) bytes into their little-endian
   * representation.
   */


  _createClass(AES128Decrypter, [{
    key: 'ntoh',
    value: function ntoh(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }

    /**
     * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.
     * @param encrypted {Uint8Array} the encrypted bytes
     * @param key {Uint32Array} the bytes of the decryption key
     * @param initVector {Uint32Array} the initialization vector (IV) to
     * use for the first round of CBC.
     * @return {Uint8Array} the decrypted bytes
     *
     * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard
     * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29
     * @see https://tools.ietf.org/html/rfc2315
     */

  }, {
    key: 'doDecrypt',
    value: function doDecrypt(encrypted, key, initVector) {
      var
      // word-level access to the encrypted bytes
      encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2),
          decipher = new _aes2.default(Array.prototype.slice.call(key)),


      // byte and word-level access for the decrypted output
      decrypted = new Uint8Array(encrypted.byteLength),
          decrypted32 = new Int32Array(decrypted.buffer),


      // temporary variables for working with the IV, encrypted, and
      // decrypted data
      init0,
          init1,
          init2,
          init3,
          encrypted0,
          encrypted1,
          encrypted2,
          encrypted3,


      // iteration variable
      wordIx;

      // pull out the words of the IV to ensure we don't modify the
      // passed-in reference and easier access
      init0 = ~~initVector[0];
      init1 = ~~initVector[1];
      init2 = ~~initVector[2];
      init3 = ~~initVector[3];

      // decrypt four word sequences, applying cipher-block chaining (CBC)
      // to each decrypted block
      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
        // convert big-endian (network order) words into little-endian
        // (javascript order)
        encrypted0 = ~~this.ntoh(encrypted32[wordIx]);
        encrypted1 = ~~this.ntoh(encrypted32[wordIx + 1]);
        encrypted2 = ~~this.ntoh(encrypted32[wordIx + 2]);
        encrypted3 = ~~this.ntoh(encrypted32[wordIx + 3]);

        // decrypt the block
        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);

        // XOR with the IV, and restore network byte-order to obtain the
        // plaintext
        decrypted32[wordIx] = this.ntoh(decrypted32[wordIx] ^ init0);
        decrypted32[wordIx + 1] = this.ntoh(decrypted32[wordIx + 1] ^ init1);
        decrypted32[wordIx + 2] = this.ntoh(decrypted32[wordIx + 2] ^ init2);
        decrypted32[wordIx + 3] = this.ntoh(decrypted32[wordIx + 3] ^ init3);

        // setup the IV for the next round
        init0 = encrypted0;
        init1 = encrypted1;
        init2 = encrypted2;
        init3 = encrypted3;
      }

      return decrypted;
    }
  }, {
    key: 'localDecrypt',
    value: function localDecrypt(encrypted, key, initVector, decrypted) {
      var bytes = this.doDecrypt(encrypted, key, initVector);
      decrypted.set(bytes, encrypted.byteOffset);
    }
  }, {
    key: 'decrypt',
    value: function decrypt(encrypted) {
      var step = 4 * 8000,

      //encrypted32 = new Int32Array(encrypted.buffer),
      encrypted32 = new Int32Array(encrypted),
          decrypted = new Uint8Array(encrypted.byteLength),
          i = 0;

      // split up the encryption job and do the individual chunks asynchronously
      var key = this.key;
      var initVector = this.iv;
      this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);

      for (i = step; i < encrypted32.length; i += step) {
        initVector = new Uint32Array([this.ntoh(encrypted32[i - 4]), this.ntoh(encrypted32[i - 3]), this.ntoh(encrypted32[i - 2]), this.ntoh(encrypted32[i - 1])]);
        this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);
      }

      return decrypted;
    }
  }]);

  return AES128Decrypter;
}();

exports.default = AES128Decrypter;

},{"./aes":13}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AES128 decryption.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _aes128Decrypter = require('./aes128-decrypter');

var _aes128Decrypter2 = _interopRequireDefault(_aes128Decrypter);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Decrypter = function () {
  function Decrypter(hls) {
    _classCallCheck(this, Decrypter);

    this.hls = hls;
    try {
      var browserCrypto = window ? window.crypto : crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
      this.disableWebCrypto = !this.subtle;
    } catch (e) {
      this.disableWebCrypto = true;
    }
  }

  _createClass(Decrypter, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      if (this.disableWebCrypto && this.hls.config.enableSoftwareAES) {
        this.decryptBySoftware(data, key, iv, callback);
      } else {
        this.decryptByWebCrypto(data, key, iv, callback);
      }
    }
  }, {
    key: 'decryptByWebCrypto',
    value: function decryptByWebCrypto(data, key, iv, callback) {
      var _this = this;

      _logger.logger.log('decrypting by WebCrypto API');

      this.subtle.importKey('raw', key, { name: 'AES-CBC', length: 128 }, false, ['decrypt']).then(function (importedKey) {
        _this.subtle.decrypt({ name: 'AES-CBC', iv: iv.buffer }, importedKey, data).then(callback).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }).catch(function (err) {
        _this.onWebCryptoError(err, data, key, iv, callback);
      });
    }
  }, {
    key: 'decryptBySoftware',
    value: function decryptBySoftware(data, key8, iv8, callback) {
      _logger.logger.log('decrypting by JavaScript Implementation');

      var view = new DataView(key8.buffer);
      var key = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);

      view = new DataView(iv8.buffer);
      var iv = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);

      var decrypter = new _aes128Decrypter2.default(key, iv);
      callback(decrypter.decrypt(data).buffer);
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.hls.config.enableSoftwareAES) {
        _logger.logger.log('disabling to use WebCrypto API');
        this.disableWebCrypto = true;
        this.decryptBySoftware(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.hls.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;

},{"../errors":27,"../utils/logger":46,"./aes128-decrypter":14}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _logger = require('../utils/logger');

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, id, remuxerClass, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.remuxer = new this.remuxerClass(observer, id, config);
    this.insertDiscontinuity();
  }

  _createClass(AACDemuxer, [{
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
    }
  }, {
    key: 'push',


    // feed incoming data to the front of the parsing pipeline
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var track,
          id3 = new _id2.default(data),
          pts = 90 * id3.timeStamp,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;

      var contiguous = false;
      if (cc !== this.lastCC) {
        _logger.logger.log(this.id + ' discontinuity detected');
        this.lastCC = cc;
        this.insertDiscontinuity();
        this.remuxer.switchLevel();
        this.remuxer.insertDiscontinuity();
      } else if (level !== this.lastLevel) {
        _logger.logger.log('audio track switch detected');
        this.lastLevel = level;
        this.remuxer.switchLevel();
        this.insertDiscontinuity();
      } else if (sn === this.lastSN + 1) {
        contiguous = true;
      }
      track = this._aacTrack;
      this.lastSN = sn;
      this.lastLevel = level;

      // look for ADTS header (0xFFFx)
      for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }

      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;
      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      this.remuxer.remux(level, sn, this._aacTrack, { samples: [] }, { samples: [{ pts: pts, dts: pts, unit: id3.payload }] }, { samples: [] }, timeOffset, contiguous);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and ADTS sync worc
      var id3 = new _id2.default(data),
          offset,
          len;
      if (id3.hasTimeStamp) {
        // look for ADTS header (0xFFFx)
        for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
          if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
            //logger.log('ADTS sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;

},{"../demux/id3":25,"../utils/logger":46,"./adts":17}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  ADTS parser helper
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

var _errors = require('../errors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ADTS = function () {
  function ADTS() {
    _classCallCheck(this, ADTS);
  }

  _createClass(ADTS, null, [{
    key: 'getAudioConfig',
    value: function getAudioConfig(observer, data, offset, audioCodec) {
      var adtsObjectType,
          // :int
      adtsSampleingIndex,
          // :int
      adtsExtensionSampleingIndex,
          // :int
      adtsChanelConfig,
          // :int
      config,
          userAgent = navigator.userAgent.toLowerCase(),
          adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
      // byte 2
      adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
      adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
      if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
        observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
        return;
      }
      adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
      // byte 3
      adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
      _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
      // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
      if (userAgent.indexOf('firefox') !== -1) {
        if (adtsSampleingIndex >= 6) {
          adtsObjectType = 5;
          config = new Array(4);
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          adtsObjectType = 2;
          config = new Array(2);
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
        // Android : always use AAC
      } else if (userAgent.indexOf('android') !== -1) {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      } else {
        /*  for other browsers (chrome ...)
            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
        */
        adtsObjectType = 5;
        config = new Array(4);
        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
            adtsObjectType = 2;
            config = new Array(2);
          }
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
      }
      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
          ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
        Audio Profile / Audio Object Type
        0: Null
        1: AAC Main
        2: AAC LC (Low Complexity)
        3: AAC SSR (Scalable Sample Rate)
        4: AAC LTP (Long Term Prediction)
        5: SBR (Spectral Band Replication)
        6: AAC Scalable
       sampling freq
        0: 96000 Hz
        1: 88200 Hz
        2: 64000 Hz
        3: 48000 Hz
        4: 44100 Hz
        5: 32000 Hz
        6: 24000 Hz
        7: 22050 Hz
        8: 16000 Hz
        9: 12000 Hz
        10: 11025 Hz
        11: 8000 Hz
        12: 7350 Hz
        13: Reserved
        14: Reserved
        15: frequency is written explictly
        Channel Configurations
        These are the channel configurations:
        0: Defined in AOT Specifc Config
        1: 1 channel: front-center
        2: 2 channels: front-left, front-right
      */
      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
      config[0] = adtsObjectType << 3;
      // samplingFrequencyIndex
      config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
      config[1] |= (adtsSampleingIndex & 0x01) << 7;
      // channelConfiguration
      config[1] |= adtsChanelConfig << 3;
      if (adtsObjectType === 5) {
        // adtsExtensionSampleingIndex
        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
        config[2] |= 2 << 2;
        config[3] = 0;
      }
      return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType };
    }
  }]);

  return ADTS;
}();

exports.default = ADTS;

},{"../errors":27,"../utils/logger":46}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('../errors');

var _aacdemuxer = require('../demux/aacdemuxer');

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _tsdemuxer = require('../demux/tsdemuxer');

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _flvdemuxer = require('../demux/flvdemuxer');

var _flvdemuxer2 = _interopRequireDefault(_flvdemuxer);

var _mp4Remuxer = require('../remux/mp4-remuxer');

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = require('../remux/passthrough-remuxer');

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DemuxerInline = function () {
  function DemuxerInline(hls, id, typeSupported) {
    var config = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

    _classCallCheck(this, DemuxerInline);

    this.hls = hls;
    this.id = id;
    this.config = this.hls.config || config;
    this.typeSupported = typeSupported;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var demuxer = this.demuxer;
      if (!demuxer) {
        var hls = this.hls,
            id = this.id;
        // probe for content type
        if (_flvdemuxer2.default.probe(data)) {
          demuxer = new _flvdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
        } else if (_tsdemuxer2.default.probe(data)) {
          if (this.typeSupported.mp2t === true) {
            demuxer = new _tsdemuxer2.default(hls, id, _passthroughRemuxer2.default, this.config);
          } else {
            demuxer = new _tsdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
          }
        } else if (_aacdemuxer2.default.probe(data)) {
          demuxer = new _aacdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
        } else {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      demuxer.push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;

},{"../demux/aacdemuxer":16,"../demux/flvdemuxer":24,"../demux/tsdemuxer":26,"../errors":27,"../events":29,"../remux/mp4-remuxer":39,"../remux/passthrough-remuxer":40}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };
  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        self.demuxer = new _demuxerInline2.default(observer, data.id, data.typeSupported, JSON.parse(data.config));
        break;
      case 'demux':
        self.demuxer.push(new Uint8Array(data.data), data.audioCodec, data.videoCodec, data.timeOffset, data.cc, data.level, data.sn, data.duration);
        break;
      default:
        break;
    }
  });

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  // forward events to main thread
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var data1 = data.data1.buffer,
        data2 = data.data2.buffer;
    // remove data1 and data2 reference from data to avoid copying them ...
    delete data.data1;
    delete data.data2;
    self.postMessage({ event: ev, data: data, data1: data1, data2: data2 }, [data1, data2]);
  });
}; /* demuxer web worker.
    *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
    *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
    */

exports.default = DemuxerWorker;

},{"../demux/demuxer-inline":18,"../events":29,"events":1}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = require('../demux/demuxer-worker');

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = require('../utils/logger');

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mp2t: hls.config.enableMP2TPassThrough && MediaSource.isTypeSupported('video/mp2t')
    };
    if (hls.config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      try {
        var work = require('webworkify');
        var w = this.w = work(_demuxerWorker2.default);
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, id: id, config: JSON.stringify(hls.config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
      }
    } else {
      this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
    }
    this.demuxInitialized = true;
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var decrypter = this.decrypter;
      if (decrypter) {
        decrypter.destroy();
        this.decrypter = null;
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var w = this.w;
      if (w) {
        // post fragment payload as transferable objects (no copy)
        w.postMessage({ cmd: 'demux', data: data, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, cc: cc, level: level, sn: sn, duration: duration }, [data]);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(new Uint8Array(data), audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
        }
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, decryptdata) {
      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        if (this.decrypter == null) {
          this.decrypter = new _decrypter2.default(this.hls);
        }

        var localthis = this;
        this.decrypter.decrypt(data, decryptdata.key, decryptdata.iv, function (decryptedData) {
          localthis.pushDecrypted(decryptedData, audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
        });
      } else {
        this.pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      //console.log('onWorkerMessage:' + data.event);
      switch (data.event) {
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events2.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          data.data.data2 = new Uint8Array(data.data2);
        /* falls through */
        default:
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;

},{"../crypt/decrypter":15,"../demux/demuxer-inline":18,"../demux/demuxer-worker":19,"../errors":27,"../events":29,"../utils/logger":46,"webworkify":2}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = this.data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var position = this.data.byteLength - this.bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, this.bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(this.data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return 1 === this.readBits(1);
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j,
          deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          sarScale = 1,
          profileIdc,
          profileCompat,
          levelIdc,
          numRefFramesInPicOrderCntCycle,
          picWidthInMbsMinus1,
          picHeightInMapUnitsMinus1,
          frameMbsOnlyFlag,
          scalingListCount,
          i;
      this.readUByte();
      profileIdc = this.readUByte(); // profile_idc
      profileCompat = this.readBits(5); // constraint_set[0-4]_flag, u(5)
      this.skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = this.readUByte(); //level_idc u(8)
      this.skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = this.readUEG();
        if (chromaFormatIdc === 3) {
          this.skipBits(1); // separate_colour_plane_flag
        }
        this.skipUEG(); // bit_depth_luma_minus8
        this.skipUEG(); // bit_depth_chroma_minus8
        this.skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (this.readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (this.readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                this.skipScalingList(16);
              } else {
                this.skipScalingList(64);
              }
            }
          }
        }
      }
      this.skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = this.readUEG();
      if (picOrderCntType === 0) {
        this.readUEG(); //log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        this.skipBits(1); // delta_pic_order_always_zero_flag
        this.skipEG(); // offset_for_non_ref_pic
        this.skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = this.readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          this.skipEG(); // offset_for_ref_frame[ i ]
        }
      }
      this.skipUEG(); // max_num_ref_frames
      this.skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = this.readUEG();
      picHeightInMapUnitsMinus1 = this.readUEG();
      frameMbsOnlyFlag = this.readBits(1);
      if (frameMbsOnlyFlag === 0) {
        this.skipBits(1); // mb_adaptive_frame_field_flag
      }
      this.skipBits(1); // direct_8x8_inference_flag
      if (this.readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = this.readUEG();
        frameCropRightOffset = this.readUEG();
        frameCropTopOffset = this.readUEG();
        frameCropBottomOffset = this.readUEG();
      }
      if (this.readBoolean()) {
        // vui_parameters_present_flag
        if (this.readBoolean()) {
          // aspect_ratio_info_present_flag
          var sarRatio = void 0;
          var aspectRatioIdc = this.readUByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];break;
            case 2:
              sarRatio = [12, 11];break;
            case 3:
              sarRatio = [10, 11];break;
            case 4:
              sarRatio = [16, 11];break;
            case 5:
              sarRatio = [40, 33];break;
            case 6:
              sarRatio = [24, 11];break;
            case 7:
              sarRatio = [20, 11];break;
            case 8:
              sarRatio = [32, 11];break;
            case 9:
              sarRatio = [80, 33];break;
            case 10:
              sarRatio = [18, 11];break;
            case 11:
              sarRatio = [15, 11];break;
            case 12:
              sarRatio = [64, 33];break;
            case 13:
              sarRatio = [160, 99];break;
            case 14:
              sarRatio = [4, 3];break;
            case 15:
              sarRatio = [3, 2];break;
            case 16:
              sarRatio = [2, 1];break;
            case 255:
              {
                sarRatio = [this.readUByte() << 8 | this.readUByte(), this.readUByte() << 8 | this.readUByte()];
                break;
              }
          }
          if (sarRatio) {
            sarScale = sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        width: Math.ceil(((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;

},{"../utils/logger":46}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @file:   flv-parser.js
 * @author: tanshaohui
 * @email:  tanshaohui@baidu.com
 * @date:   2016-09-07 15:06:41
 * @last modified by:   tanshaohui
 * @last modified time: 2016-09-07 16:03:45
 */

var FLVParser = function () {
    function FLVParser(data) {
        _classCallCheck(this, FLVParser);

        this.hasAudioTags = true;
        this.hasVideoTags = true;
        this.bodyOffset = 0;
        if (data) {
            this.readFileHeader(data);
        }
    }

    _createClass(FLVParser, [{
        key: 'readFileHeader',
        value: function readFileHeader(data) {
            if (data.length < FLVParser.MIN_FILE_HEADER_BYTE_COUNT) {
                throw new Error('data too short');
            }

            if (data[0] !== 0x46) {
                throw new Error('FLVHeader Signature[0] not "F"');
            }

            if (data[1] !== 0x4C) {
                throw new Error('FLVHeader Signature[1] not "L"');
            }

            if (data[2] !== 0x56) {
                throw new Error('FLVHeader Signature[2] not "V"');
            }

            if (data[3] !== 0x01) {
                throw new Error('FLVHeader Version not 0x01');
            }

            var flags = data[4];
            this.hasAudioTags = flags & 0x04 ? true : false;
            this.hasVideoTags = flags & 0x01 ? true : false;

            this.bodyOffset = new DataView(data.slice(5).buffer).getUint32(0);
            if (this.bodyOffset < FLVParser.MIN_FILE_HEADER_BYTE_COUNT) {
                throw new Error('FLVHeader bodyOffset smaller than minimum');
            }
        }
    }]);

    return FLVParser;
}();

FLVParser.MIN_FILE_HEADER_BYTE_COUNT = 9;
FLVParser.FILE_HEADER = 'fileHeader';
FLVParser.PREV_TAG = 'prevTag';
FLVParser.HEADER = 'header';
FLVParser.DATA = 'data';

exports.default = FLVParser;

},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @file:   flv-tag.js
 * @author: tanshaohui
 * @email:  tanshaohui@baidu.com
 * @date:   2016-09-07 12:56:09
 * @last modified by:   tanshaohui
 * @last modified time: 2016-09-07 20:44:18
 */

var FLVTag = function () {
    function FLVTag(data) {
        _classCallCheck(this, FLVTag);

        this.type = FLVTag.TAG_TYPE_SCRIPTDATAOBJECT;
        this.tagDataSize = 0;
        if (data) {
            this.readHeader(data);
        }
    }

    _createClass(FLVTag, [{
        key: 'readPrevTagSize',
        value: function readPrevTagSize(data) {
            return new DataView(data.buffer).getUint32(0);
        }
    }, {
        key: 'readHeader',
        value: function readHeader(data) {
            var type = data[0];
            if (type === FLVTag.TAG_TYPE_AUDIO || type === FLVTag.TAG_TYPE_VIDEO || type === FLVTag.TAG_TYPE_SCRIPTDATAOBJECT) {
                this.type = type;
            } else {
                throw new Error('invalid FLVTagType');
            }

            this.tagDataSize = data[1] << 16 | data[2] << 8 | data[3];

            this.timestamp = data[7] << 24 | data[4] << 16 | data[5] << 8 | data[6];
        }
    }, {
        key: 'readData',
        value: function readData(data) {
            switch (this.type) {
                case FLVTag.TAG_TYPE_AUDIO:
                    return this.readAudioData(data);
                case FLVTag.TAG_TYPE_VIDEO:
                    return this.readVideoData(data);
                case FLVTag.TAG_TYPE_SCRIPTDATAOBJECT:
                    break;
                default:
                    throw new Error('invalid FLVTagType');
            }
        }
    }, {
        key: 'readAudioData',
        value: function readAudioData(data) {
            var tag = {
                type: 'audio',
                timestamp: this.timestamp
            };
            var audioHeader = data[0];
            var soundFormat = audioHeader >> 4 & 0x0f;
            var soundRate = 0;
            switch (audioHeader >> 2 & 0x03) {
                case 0:
                    soundRate = 5512.5;
                    break;
                case 1:
                    soundRate = 11025;
                    break;
                case 2:
                    soundRate = 22050;
                    break;
                case 3:
                    soundRate = 44100;
                    break;
                default:
                    throw new Error('invalid soundRate');
            }
            // AAC
            if (soundFormat === 10) {
                var packetType = data[1];
                tag.codec = 'aac';
                tag.pkt_type = packetType;
                tag.data = data.slice(2);
                return tag;
            }
        }
    }, {
        key: 'readVideoData',
        value: function readVideoData(data) {
            var tag = {
                type: 'video',
                timestamp: this.timestamp
            };
            var videoHeader = data[0];
            var codecID = videoHeader & 0x0f;
            // AVC 
            if (codecID === 7) {
                var packetType = data[1];
                tag.codec = 'avc';
                tag.pkt_type = packetType;
                if (packetType === 1) {
                    var compositionTime = data[2] << 16;
                    compositionTime |= data[3] << 8;
                    compositionTime |= data[4];
                    if (compositionTime & 0x00800000) {
                        compositionTime |= 0xff000000;
                    }
                }
                tag.data = data.slice(5);
                return tag;
            }
        }
    }]);

    return FLVTag;
}();

FLVTag.PREV_TAG_BYTE_COUNT = 4;
FLVTag.TAG_TYPE_AUDIO = 0x08;
FLVTag.TAG_TYPE_VIDEO = 0x09;
FLVTag.TAG_TYPE_SCRIPTDATAOBJECT = 0x12;
FLVTag.TAG_HEADER_BYTE_COUNT = 11;

exports.default = FLVTag;

},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file:   flvdemuxer.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author: tanshaohui
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @email:  tanshaohui@baidu.com
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @date:   2016-09-07 10:23:57
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @last modified by:   tanshaohui
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @last modified time: 2016-09-07 20:45:00
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _flvParser = require('./flv/flv-parser');

var _flvParser2 = _interopRequireDefault(_flvParser);

var _flvTag = require('./flv/flv-tag');

var _flvTag2 = _interopRequireDefault(_flvTag);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FLVDemuxer = function () {
    function FLVDemuxer(observer, id, remuxerClass, config) {
        _classCallCheck(this, FLVDemuxer);

        this.observer = observer;
        this.id = id;
        this.remuxerClass = remuxerClass;
        this.config = config;
        this.lastCC = 0;
        this.flvParser = new _flvParser2.default();
        this.remuxer = new this.remuxerClass(observer, id, config);
        this._flvParserState = _flvParser2.default.FILE_HEADER;
    }

    _createClass(FLVDemuxer, [{
        key: 'switchLevel',
        value: function switchLevel() {
            this._avcTrack = { container: 'video/x-flv', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, nbNalu: 0, dropped: 0 };
            this._aacTrack = { container: 'video/x-flv', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
            this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };
            this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };
            // flush any partial content
            this.aacOverFlow = null;
            this.aacLastPTS = null;
            this.avcNaluState = 0;
            this.remuxer.switchLevel();
        }
    }, {
        key: 'insertDiscontinuity',
        value: function insertDiscontinuity() {
            this.switchLevel();
            this.remuxer.insertDiscontinuity();
        }

        // feed incoming data to the front of the parsing pipeline

    }, {
        key: 'push',
        value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
            var start,
                len = data.length;
            var cTag = null;

            this.audioCodec = audioCodec;
            this.videoCodec = videoCodec;
            this.timeOffset = timeOffset;
            this.contiguous = false;
            this._flvParserState = _flvParser2.default.FILE_HEADER;
            this._duration = duration;

            if (cc !== this.lastCC) {
                _logger.logger.log('discontinuity detected');
                this.insertDiscontinuity();
                this.lastCC = cc;
            }
            if (level !== this.lastLevel) {
                _logger.logger.log('level switch detected');
                this.switchLevel();
                this.lastLevel = level;
            } else if (sn === this.lastSN + 1) {
                this.contiguous = true;
            }
            this.lastSN = sn;

            for (start = 0; start < len;) {
                switch (this._flvParserState) {
                    case _flvParser2.default.FILE_HEADER:
                        this.flvParser.readFileHeader(data.slice(start, start + _flvParser2.default.MIN_FILE_HEADER_BYTE_COUNT));
                        this._flvParserState = _flvParser2.default.PREV_TAG;
                        start += this.flvParser.bodyOffset;
                        break;
                    case _flvParser2.default.PREV_TAG:
                        cTag = new _flvTag2.default();
                        this._flvParserState = _flvParser2.default.HEADER;
                        start += _flvTag2.default.PREV_TAG_BYTE_COUNT;
                        break;
                    case _flvParser2.default.HEADER:
                        cTag.readHeader(data.slice(start, start + _flvTag2.default.TAG_HEADER_BYTE_COUNT));
                        this._flvParserState = _flvParser2.default.DATA;
                        start += _flvTag2.default.TAG_HEADER_BYTE_COUNT;
                        break;
                    case _flvParser2.default.DATA:
                        var tag = cTag.readData(data.slice(start, start + cTag.tagDataSize));
                        if (tag && tag.codec) {
                            if (tag.codec === 'aac') {
                                if (tag.pkt_type === 1) {
                                    this._parseAACTag(tag);
                                } else if (tag.pkt_type === 0) {
                                    this._aacTrack.config = [41, 145, 136, 0];
                                    this._aacTrack.audiosamplerate = 48000;
                                    this._aacTrack.channelCount = 2;
                                    this._aacTrack.codec = 'mp4a.40.5';
                                    this._aacTrack.duration = this._duration;
                                }
                            } else if (tag.codec === 'avc') {
                                if (tag.pkt_type === 1) {
                                    this._parseAVCTag(tag);
                                } else if (tag.pkt_type === 0) {}
                            }
                        }
                        this._flvParserState = _flvParser2.default.PREV_TAG;
                        start += cTag.tagDataSize;
                        break;
                    default:
                        throw new Error('invalid FLVParserState');
                }
            }

            this.remux(level, sn, null);
        }
    }, {
        key: 'remux',
        value: function remux(level, sn, data) {
            this.remuxer.remux(level, sn, this._aacTrack, this._avcTrack, this._id3Track, this._txtTrack, this.timeOffset, this.contiguous, data);
        }
    }, {
        key: 'destroy',
        value: function destroy() {}
    }, {
        key: '_parseAACTag',
        value: function _parseAACTag(tag) {
            var track = this._aacTrack;
            var pts = 0;
            var aacLastPTS = this.aacLastPTS;
            var frameDuration = 1024 * 90000 / track.audiosamplerate;
            if (aacLastPTS) {
                pts = aacLastPTS + frameDuration;
            } else {
                pts = tag.timestamp * frameDuration;
            }
            track.samples.push({
                dts: pts,
                pts: pts,
                unit: tag.data
            });
            track.len += tag.data.length;
            this.aacLastPTS = pts;
        }
    }, {
        key: '_parseAVCTag',
        value: function _parseAVCTag(tag) {
            var track = this._avcTrack;
            var units = this._parseAVCNALu(tag.data);
        }
    }, {
        key: '_parseAVCNALu',
        value: function _parseAVCNALu(array) {
            var i = 0,
                len = array.byteLength,
                value,
                overflow,
                state = this.avcNaluState;
            var units = [],
                unit,
                unitType,
                lastUnitStart,
                lastUnitType;
            while (i < len) {
                value = array[i++];
                // finding 3 or 4-byte start codes (00 00 01 OR 00 00 00 01)
                switch (state) {
                    case 0:
                        if (value === 0) {
                            state = 1;
                        }
                        break;
                    case 1:
                        if (value === 0) {
                            state = 2;
                        } else {
                            state = 0;
                        }
                        break;
                    case 2:
                    case 3:
                        if (value === 0) {
                            state = 3;
                        } else if (value === 1 && i < len) {
                            unitType = array[i] & 0x1f;
                            //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
                            if (lastUnitStart) {
                                unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                                //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
                                units.push(unit);
                            } else {
                                // lastUnitStart is undefined => this is the first start code found in this PES packet
                                // first check if start code delimiter is overlapping between 2 PES packets,
                                // ie it started in last packet (lastState not zero)
                                // and ended at the beginning of this PES packet (i <= 4 - lastState)
                                var lastState = this.avcNaluState;
                                if (lastState && i <= 4 - lastState) {
                                    // start delimiter overlapping between PES packets
                                    // strip start delimiter bytes from the end of last NAL unit
                                    var track = this._avcTrack,
                                        samples = track.samples;
                                    if (samples.length) {
                                        var lastavcSample = samples[samples.length - 1],
                                            lastUnits = lastavcSample.units.units,
                                            lastUnit = lastUnits[lastUnits.length - 1];
                                        // check if lastUnit had a state different from zero
                                        if (lastUnit.state) {
                                            // strip last bytes
                                            lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                                            lastavcSample.units.length -= lastState;
                                            track.len -= lastState;
                                        }
                                    }
                                }
                                // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
                                overflow = i - state - 1;
                                if (overflow > 0) {
                                    var _track = this._avcTrack,
                                        _samples = _track.samples;
                                    //logger.log('first NALU found with overflow:' + overflow);
                                    if (_samples.length) {
                                        var _lastavcSample = _samples[_samples.length - 1],
                                            _lastUnits = _lastavcSample.units.units,
                                            _lastUnit = _lastUnits[_lastUnits.length - 1],
                                            tmp = new Uint8Array(_lastUnit.data.byteLength + overflow);
                                        tmp.set(_lastUnit.data, 0);
                                        tmp.set(array.subarray(0, overflow), _lastUnit.data.byteLength);
                                        _lastUnit.data = tmp;
                                        _lastavcSample.units.length += overflow;
                                        _track.len += overflow;
                                    }
                                }
                            }
                            lastUnitStart = i;
                            lastUnitType = unitType;
                            state = 0;
                        } else {
                            state = 0;
                        }
                        break;
                    default:
                        break;
                }
            }
            if (lastUnitStart) {
                unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
                units.push(unit);
                //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
                this.avcNaluState = state;
            }
            return units;
        }
    }], [{
        key: 'probe',
        value: function probe(data) {
            // flv starting with 0x46 0x4C 0x56, 0x01
            if (data.length > _flvParser2.default.MIN_FILE_HEADER_BYTE_COUNT && data[0] === 0x46 && data[1] === 0x4C && data[2] === 0x56 && data[3] === 0x01) {
                return true;
            } else {
                return false;
            }
        }
    }]);

    return FLVDemuxer;
}();

exports.default = FLVDemuxer;

},{"../utils/logger":46,"./flv/flv-parser":22,"./flv/flv-tag":23}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import Hex from '../utils/hex';

var ID3 = function () {
  function ID3(data) {
    _classCallCheck(this, ID3);

    this._hasTimeStamp = false;
    var offset = 0,
        byte1,
        byte2,
        byte3,
        byte4,
        tagSize,
        endPos,
        header,
        len;
    do {
      header = this.readUTF(data, offset, 3);
      offset += 3;
      // first check for ID3 header
      if (header === 'ID3') {
        // skip 24 bits
        offset += 3;
        // retrieve tag(s) length
        byte1 = data[offset++] & 0x7f;
        byte2 = data[offset++] & 0x7f;
        byte3 = data[offset++] & 0x7f;
        byte4 = data[offset++] & 0x7f;
        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
        endPos = offset + tagSize;
        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);

        // read ID3 tags
        this._parseID3Frames(data, offset, endPos);
        offset = endPos;
      } else if (header === '3DI') {
        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
        offset += 7;
        _logger.logger.log('3DI footer found, end: ' + offset);
      } else {
        offset -= 3;
        len = offset;
        if (len) {
          //logger.log(`ID3 len: ${len}`);
          if (!this.hasTimeStamp) {
            _logger.logger.warn('ID3 tag found, but no timestamp');
          }
          this._length = len;
          this._payload = data.subarray(0, len);
        }
        return;
      }
    } while (true);
  }

  _createClass(ID3, [{
    key: 'readUTF',
    value: function readUTF(data, start, len) {

      var result = '',
          offset = start,
          end = start + len;
      do {
        result += String.fromCharCode(data[offset++]);
      } while (offset < end);
      return result;
    }
  }, {
    key: '_parseID3Frames',
    value: function _parseID3Frames(data, offset, endPos) {
      var tagId, tagLen, tagStart, tagFlags, timestamp;
      while (offset + 8 <= endPos) {
        tagId = this.readUTF(data, offset, 4);
        offset += 4;

        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];

        tagFlags = data[offset++] << 8 + data[offset++];

        tagStart = offset;
        //logger.log("ID3 tag id:" + tagId);
        switch (tagId) {
          case 'PRIV':
            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
            // owner should be "com.apple.streaming.transportStreamTimestamp"
            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
              offset += 44;
              // smelling even better ! we found the right descriptor
              // skip null character (string end) + 3 first bytes
              offset += 4;

              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
              var pts33Bit = data[offset++] & 0x1;
              this._hasTimeStamp = true;

              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;

              if (pts33Bit) {
                timestamp += 47721858.84; // 2^32 / 90
              }
              timestamp = Math.round(timestamp);
              _logger.logger.trace('ID3 timestamp found: ' + timestamp);
              this._timeStamp = timestamp;
            }
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: 'hasTimeStamp',
    get: function get() {
      return this._hasTimeStamp;
    }
  }, {
    key: 'timeStamp',
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._length;
    }
  }, {
    key: 'payload',
    get: function get() {
      return this._payload;
    }
  }]);

  return ID3;
}();

exports.default = ID3;

},{"../utils/logger":46}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TSDemuxer = function () {
  function TSDemuxer(observer, id, remuxerClass, config) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.lastCC = 0;
    this.remuxer = new this.remuxerClass(observer, id, config);
  }

  _createClass(TSDemuxer, [{
    key: 'switchLevel',
    value: function switchLevel() {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, nbNalu: 0, dropped: 0 };
      this._aacTrack = { container: 'video/mp2t', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcNaluState = 0;
      this.remuxer.switchLevel();
    }
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this.switchLevel();
      this.remuxer.insertDiscontinuity();
    }

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var avcData,
          aacData,
          id3Data,
          start,
          len = data.length,
          stt,
          pid,
          atf,
          offset,
          codecsOnly = this.remuxer.passthrough,
          unknownPIDs = false;

      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.timeOffset = timeOffset;
      this._duration = duration;
      this.contiguous = false;
      if (cc !== this.lastCC) {
        _logger.logger.log('discontinuity detected');
        this.insertDiscontinuity();
        this.lastCC = cc;
      }
      if (level !== this.lastLevel) {
        _logger.logger.log('level switch detected');
        this.switchLevel();
        this.lastLevel = level;
      } else if (sn === this.lastSN + 1) {
        this.contiguous = true;
      }
      this.lastSN = sn;

      var pmtParsed = this.pmtParsed,
          avcId = this._avcTrack.id,
          aacId = this._aacTrack.id,
          id3Id = this._id3Track.id,
          pmtId = this._pmtId;

      var parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      // don't parse last TS packet if incomplete
      len -= len % 188;
      // loop through TS packets
      for (start = 0; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData) {
                  parseAVCPES(parsePES(avcData));
                  if (codecsOnly) {
                    // if we have video codec info AND
                    // if audio PID is undefined OR if we have audio codec info,
                    // we have all codec info !
                    if (this._avcTrack.codec && (aacId === -1 || this._aacTrack.codec)) {
                      this.remux(level, sn, data);
                      return;
                    }
                  }
                }
                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case aacId:
              if (stt) {
                if (aacData) {
                  parseAACPES(parsePES(aacData));
                  if (codecsOnly) {
                    // here we now that we have audio codec info
                    // if video PID is undefined OR if we have video codec info,
                    // we have all codec infos !
                    if (this._aacTrack.codec && (avcId === -1 || this._avcTrack.codec)) {
                      this.remux(level, sn, data);
                      return;
                    }
                  }
                }
                aacData = { data: [], size: 0 };
              }
              if (aacData) {
                aacData.data.push(data.subarray(offset, start + 188));
                aacData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data) {
                  parseID3PES(parsePES(id3Data));
                }
                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }
              var parsedPIDs = parsePMT(data, offset);
              avcId = this._avcTrack.id = parsedPIDs.avc;
              aacId = this._aacTrack.id = parsedPIDs.aac;
              id3Id = this._id3Track.id = parsedPIDs.id3;
              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = -188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // parse last PES packet
      if (avcData) {
        parseAVCPES(parsePES(avcData));
      }
      if (aacData) {
        parseAACPES(parsePES(aacData));
      }
      if (id3Data) {
        parseID3PES(parsePES(id3Data));
      }
      this.remux(level, sn, null);
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, data) {
      this.remuxer.remux(level, sn, this._aacTrack, this._avcTrack, this._id3Track, this._txtTrack, this.timeOffset, this.contiguous, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.switchLevel();
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      //logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset) {
      var sectionLength,
          tableEnd,
          programInfoLength,
          pid,
          result = { aac: -1, avc: -1, id3: -1 };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            //logger.log('AAC PID:'  + pid);
            if (result.aac === -1) {
              result.aac = pid;
            }
            break;
          // Packetized metadata (ID3)
          case 0x15:
            //logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }
            break;
          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            //logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }
            break;
          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;
          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag,
          pesFlags,
          pesPrefix,
          pesLen,
          pesHdrLen,
          pesData,
          pesPts,
          pesDts,
          payloadStartOffset,
          data = stream.data;
      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      //retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        //reassemble PES packet
        pesData = new Uint8Array(stream.size);
        while (data.length) {
          frag = data.shift();
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes) {
      var _this = this;

      var track = this._avcTrack,
          samples = track.samples,
          units = this._parseAVCNALu(pes.data),
          units2 = [],
          debug = false,
          key = false,
          length = 0,
          expGolombDecoder,
          avcSample,
          push,
          i;
      // no NALu found
      if (units.length === 0 && samples.length > 0) {
        // append pes.data to previous NAL unit
        var lastavcSample = samples[samples.length - 1];
        var lastUnit = lastavcSample.units.units[lastavcSample.units.units.length - 1];
        var tmp = new Uint8Array(lastUnit.data.byteLength + pes.data.byteLength);
        tmp.set(lastUnit.data, 0);
        tmp.set(pes.data, lastUnit.data.byteLength);
        lastUnit.data = tmp;
        lastavcSample.units.length += pes.data.byteLength;
        track.len += pes.data.byteLength;
      }
      //free pes.data to save up some memory
      pes.data = null;
      var debugString = '';

      var pushAccesUnit = function () {
        if (units2.length) {
          // only push AVC sample if starting with a keyframe is not mandatory OR
          //    if keyframe already found in this fragment OR
          //       keyframe found in last fragment (track.sps) AND
          //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
          if (!this.config.forceKeyFrameOnDiscontinuity || key === true || track.sps && (samples.length || this.contiguous)) {
            avcSample = { units: { units: units2, length: length }, pts: pes.pts, dts: pes.dts, key: key };
            samples.push(avcSample);
            track.len += length;
            track.nbNalu += units2.length;
          } else {
            // dropped samples, track it
            track.dropped++;
          }
          units2 = [];
          length = 0;
        }
      }.bind(this);

      units.forEach(function (unit) {
        switch (unit.type) {
          //NDR
          case 1:
            push = true;
            if (debug) {
              debugString += 'NDR ';
            }
            break;
          //IDR
          case 5:
            push = true;
            if (debug) {
              debugString += 'IDR ';
            }
            key = true;
            break;
          //SEI
          case 6:
            push = true;
            if (debug) {
              debugString += 'SEI ';
            }
            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          //SPS
          case 7:
            push = true;
            if (debug) {
              debugString += 'SPS ';
            }
            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          //PPS
          case 8:
            push = true;
            if (debug) {
              debugString += 'PPS ';
            }
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          case 9:
            push = false;
            if (debug) {
              debugString += 'AUD ';
            }
            pushAccesUnit();
            break;
          default:
            push = false;
            debugString += 'unknown NAL ' + unit.type + ' ';
            break;
        }
        if (push) {
          units2.push(unit);
          length += unit.data.byteLength;
        }
      });
      if (debug || debugString.length) {
        _logger.logger.log(debugString);
      }
      pushAccesUnit();
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value,
          overflow,
          state = this.avcNaluState;
      var units = [],
          unit,
          unitType,
          lastUnitStart,
          lastUnitType;
      //logger.log('PES:' + Hex.hexDump(array));
      while (i < len) {
        value = array[i++];
        // finding 3 or 4-byte start codes (00 00 01 OR 00 00 00 01)
        switch (state) {
          case 0:
            if (value === 0) {
              state = 1;
            }
            break;
          case 1:
            if (value === 0) {
              state = 2;
            } else {
              state = 0;
            }
            break;
          case 2:
          case 3:
            if (value === 0) {
              state = 3;
            } else if (value === 1 && i < len) {
              unitType = array[i] & 0x1f;
              //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
              if (lastUnitStart) {
                unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
                units.push(unit);
              } else {
                // lastUnitStart is undefined => this is the first start code found in this PES packet
                // first check if start code delimiter is overlapping between 2 PES packets,
                // ie it started in last packet (lastState not zero)
                // and ended at the beginning of this PES packet (i <= 4 - lastState)
                var lastState = this.avcNaluState;
                if (lastState && i <= 4 - lastState) {
                  // start delimiter overlapping between PES packets
                  // strip start delimiter bytes from the end of last NAL unit
                  var track = this._avcTrack,
                      samples = track.samples;
                  if (samples.length) {
                    var lastavcSample = samples[samples.length - 1],
                        lastUnits = lastavcSample.units.units,
                        lastUnit = lastUnits[lastUnits.length - 1];
                    // check if lastUnit had a state different from zero
                    if (lastUnit.state) {
                      // strip last bytes
                      lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                      lastavcSample.units.length -= lastState;
                      track.len -= lastState;
                    }
                  }
                }
                // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
                overflow = i - state - 1;
                if (overflow > 0) {
                  var _track = this._avcTrack,
                      _samples = _track.samples;
                  //logger.log('first NALU found with overflow:' + overflow);
                  if (_samples.length) {
                    var _lastavcSample = _samples[_samples.length - 1],
                        _lastUnits = _lastavcSample.units.units,
                        _lastUnit = _lastUnits[_lastUnits.length - 1],
                        tmp = new Uint8Array(_lastUnit.data.byteLength + overflow);
                    tmp.set(_lastUnit.data, 0);
                    tmp.set(array.subarray(0, overflow), _lastUnit.data.byteLength);
                    _lastUnit.data = tmp;
                    _lastavcSample.units.length += overflow;
                    _track.len += overflow;
                  }
                }
              }
              lastUnitStart = i;
              lastUnitType = unitType;
              state = 0;
            } else {
              state = 0;
            }
            break;
          default:
            break;
        }
      }
      if (lastUnitStart) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
        this.avcNaluState = state;
      }
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength,
          newData;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._aacTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          duration = this._duration,
          audioCodec = this.audioCodec,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason, fatal;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }
      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        //logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }
      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;

},{"../errors":27,"../events":29,"../utils/logger":46,"./adts":17,"./exp-golomb":21}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = exports.ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: parsing error description
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: parsing error description
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('./utils/logger');

var _errors = require('./errors');

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.unregisterListeners();
    }
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (event === 'hlsEventGeneric') {
            throw new Error('Forbidden event name: ' + event);
          }
          this.hls.on(event, this.onEvent);
        }.bind(this));
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }.bind(this));
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }
        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;

},{"./errors":27,"./events":29,"./utils/logger":46}],29:[function(require,module,exports){
'use strict';

module.exports = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be resetted
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created data: { tracks : tracks}
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING }
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data {startOffset, endOffset}
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media has been flushed
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: {  id : audio track id}
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired when a fragment loading starts - data: { frag : fragment object}
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, moov : moov MP4 box, codecs : codecs found while parsing fragment}
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id; level : levelId, sn : sequence number, }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object}
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: {previousState, nextState}
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: "getSilentFrame",
    value: function getSilentFrame(channelCount) {
      if (channelCount === 1) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
      } else if (channelCount === 2) {
        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
      } else if (channelCount === 3) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
      } else if (channelCount === 4) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
      } else if (channelCount === 5) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
      } else if (channelCount === 6) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Buffer Helper class, providing methods dealing buffer length retrieval
*/

var BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      if (media) {
        var vbuffered = media.buffered,
            buffered = [],
            i;
        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
        }
        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      } else {
        return { len: 0, start: 0, end: 0, nextStart: undefined };
      }
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen,
          bufferStart,
          bufferEnd,
          bufferStartNext,
          i;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

exports.default = BufferHelper;

},{}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Level Helper class, providing methods dealing with playlist sliding and drift
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelHelper = function () {
  function LevelHelper() {
    _classCallCheck(this, LevelHelper);
  }

  _createClass(LevelHelper, null, [{
    key: 'mergeDetails',
    value: function mergeDetails(oldDetails, newDetails) {
      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
          end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
          delta = newDetails.startSN - oldDetails.startSN,
          oldfragments = oldDetails.fragments,
          newfragments = newDetails.fragments,
          ccOffset = 0,
          PTSFrag;

      // check if old/new playlists have fragments in common
      if (end < start) {
        newDetails.PTSKnown = false;
        return;
      }
      // loop through overlapping SN and update startPTS , cc, and duration if any found
      for (var i = start; i <= end; i++) {
        var oldFrag = oldfragments[delta + i],
            newFrag = newfragments[i];
        if (newFrag && oldFrag) {
          ccOffset = oldFrag.cc - newFrag.cc;
          if (!isNaN(oldFrag.startPTS)) {
            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
            newFrag.endPTS = oldFrag.endPTS;
            newFrag.duration = oldFrag.duration;
            PTSFrag = newFrag;
          }
        }
      }

      if (ccOffset) {
        _logger.logger.log('discontinuity sliding from playlist, take drift into account');
        for (i = 0; i < newfragments.length; i++) {
          newfragments[i].cc += ccOffset;
        }
      }

      // if at least one fragment contains PTS info, recompute PTS information for all fragments
      if (PTSFrag) {
        LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
      } else {
        // ensure that delta is within oldfragments range
        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
        // in that case we also need to adjust start offset of all fragments
        if (delta >= 0 && delta < oldfragments.length) {
          // adjust start by sliding offset
          var sliding = oldfragments[delta].start;
          for (i = 0; i < newfragments.length; i++) {
            newfragments[i].start += sliding;
          }
        }
      }
      // if we are here, it means we have fragments overlapping between
      // old and new level. reliable PTS info is thus relying on old level
      newDetails.PTSKnown = oldDetails.PTSKnown;
      return;
    }
  }, {
    key: 'updateFragPTSDTS',
    value: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {
      var fragIdx, fragments, frag, i;
      // exit if sn out of range
      if (sn < details.startSN || sn > details.endSN) {
        return 0;
      }
      fragIdx = sn - details.startSN;
      fragments = details.fragments;
      frag = fragments[fragIdx];
      if (!isNaN(frag.startPTS)) {
        // delta PTS between audio and video
        var deltaPTS = Math.abs(frag.startPTS - startPTS);
        if (isNaN(frag.deltaPTS)) {
          frag.deltaPTS = deltaPTS;
        } else {
          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
        }
        startPTS = Math.min(startPTS, frag.startPTS);
        endPTS = Math.max(endPTS, frag.endPTS);
        startDTS = Math.min(startDTS, frag.startDTS);
        endDTS = Math.max(endDTS, frag.endDTS);
      }

      var drift = startPTS - frag.start;

      frag.start = frag.startPTS = startPTS;
      frag.endPTS = endPTS;
      frag.startDTS = startDTS;
      frag.endDTS = endDTS;
      frag.duration = endPTS - startPTS;
      // adjust fragment PTS/duration from seqnum-1 to frag 0
      for (i = fragIdx; i > 0; i--) {
        LevelHelper.updatePTS(fragments, i, i - 1);
      }

      // adjust fragment PTS/duration from seqnum to last frag
      for (i = fragIdx; i < fragments.length - 1; i++) {
        LevelHelper.updatePTS(fragments, i, i + 1);
      }
      details.PTSKnown = true;
      //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

      return drift;
    }
  }, {
    key: 'updatePTS',
    value: function updatePTS(fragments, fromIdx, toIdx) {
      var fragFrom = fragments[fromIdx],
          fragTo = fragments[toIdx],
          fragToPTS = fragTo.startPTS;
      // if we know startPTS[toIdx]
      if (!isNaN(fragToPTS)) {
        // update fragment duration.
        // it helps to fix drifts between playlist reported duration and fragment real duration
        if (toIdx > fromIdx) {
          fragFrom.duration = fragToPTS - fragFrom.start;
          if (fragFrom.duration < 0) {
            _logger.logger.error('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
          }
        } else {
          fragTo.duration = fragFrom.start - fragToPTS;
          if (fragTo.duration < 0) {
            _logger.logger.error('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
          }
        }
      } else {
        // we dont know startPTS[toIdx]
        if (toIdx > fromIdx) {
          fragTo.start = fragFrom.start + fragFrom.duration;
        } else {
          fragTo.start = fragFrom.start - fragTo.duration;
        }
      }
    }
  }]);

  return LevelHelper;
}();

exports.default = LevelHelper;

},{"../utils/logger":46}],33:[function(require,module,exports){
/**
 * HLS interface
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
//import FetchLoader from './utils/fetch-loader';


var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('./errors');

var _playlistLoader = require('./loader/playlist-loader');

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = require('./loader/fragment-loader');

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _abrController = require('./controller/abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = require('./controller/buffer-controller');

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = require('./controller/cap-level-controller');

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _audioStreamController = require('./controller/audio-stream-controller');

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _streamController = require('./controller/stream-controller');

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = require('./controller/level-controller');

var _levelController2 = _interopRequireDefault(_levelController);

var _timelineController = require('./controller/timeline-controller');

var _timelineController2 = _interopRequireDefault(_timelineController);

var _fpsController = require('./controller/fps-controller');

var _fpsController2 = _interopRequireDefault(_fpsController);

var _audioTrackController = require('./controller/audio-track-controller');

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _logger = require('./utils/logger');

var _xhrLoader = require('./utils/xhr-loader');

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

var _keyLoader = require('./loader/key-loader');

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _cues = require('./utils/cues');

var _cues2 = _interopRequireDefault(_cues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = function () {
  _createClass(Hls, null, [{
    key: 'isSupported',
    value: function isSupported() {
      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    }
  }, {
    key: 'version',
    get: function get() {
      // replaced with browserify-versionify transform
      return '__VERSION__';
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        Hls.defaultConfig = {
          autoStartLoad: true,
          startPosition: -1,
          debug: false,
          capLevelOnFPSDrop: false,
          capLevelToPlayerSize: false,
          maxBufferLength: 30,
          maxBufferSize: 60 * 1000 * 1000,
          maxBufferHole: 0.5,
          maxSeekHole: 2,
          seekHoleNudgeDuration: 0.01,
          stalledInBufferedNudgeThreshold: 10,
          maxFragLookUpTolerance: 0.2,
          liveSyncDurationCount: 3,
          liveMaxLatencyDurationCount: Infinity,
          liveSyncDuration: undefined,
          liveMaxLatencyDuration: undefined,
          maxMaxBufferLength: 600,
          enableWorker: true,
          enableSoftwareAES: true,
          manifestLoadingTimeOut: 10000,
          manifestLoadingMaxRetry: 1,
          manifestLoadingRetryDelay: 1000,
          manifestLoadingMaxRetryTimeout: 64000,
          levelLoadingTimeOut: 10000,
          levelLoadingMaxRetry: 4,
          levelLoadingRetryDelay: 1000,
          levelLoadingMaxRetryTimeout: 64000,
          fragLoadingTimeOut: 20000,
          fragLoadingMaxRetry: 6,
          fragLoadingRetryDelay: 1000,
          fragLoadingMaxRetryTimeout: 64000,
          fragLoadingLoopThreshold: 3,
          startFragPrefetch: false,
          fpsDroppedMonitoringPeriod: 5000,
          fpsDroppedMonitoringThreshold: 0.2,
          appendErrorMaxRetry: 3,
          loader: _xhrLoader2.default,
          //loader: FetchLoader,
          fLoader: undefined,
          pLoader: undefined,
          abrController: _abrController2.default,
          bufferController: _bufferController2.default,
          capLevelController: _capLevelController2.default,
          fpsController: _fpsController2.default,
          streamController: _streamController2.default,
          audioStreamController: _audioStreamController2.default,
          timelineController: _timelineController2.default,
          cueHandler: _cues2.default,
          enableCEA708Captions: true,
          enableMP2TPassThrough: false,
          stretchShortVideoTrack: false,
          forceKeyFrameOnDiscontinuity: true,
          abrEwmaFastLive: 5,
          abrEwmaSlowLive: 9,
          abrEwmaFastVoD: 4,
          abrEwmaSlowVoD: 15,
          abrEwmaDefaultEstimate: 5e5, // 500 kbps
          abrBandWidthFactor: 0.8,
          abrBandWidthUpFactor: 0.7
        };
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    this.config = config;
    // observer setup
    var observer = this.observer = new _events4.default();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);
    this.playlistLoader = new _playlistLoader2.default(this);
    this.fragmentLoader = new _fragmentLoader2.default(this);
    this.levelController = new _levelController2.default(this);
    this.abrController = new config.abrController(this);
    this.bufferController = new config.bufferController(this);
    this.capLevelController = new config.capLevelController(this);
    this.fpsController = new config.fpsController(this);
    this.streamController = new config.streamController(this);
    this.audioStreamController = new config.audioStreamController(this);
    this.timelineController = new config.timelineController(this);
    this.audioTrackController = new _audioTrackController2.default(this);
    this.keyLoader = new _keyLoader2.default(this);
  }

  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.playlistLoader.destroy();
      this.fragmentLoader.destroy();
      this.levelController.destroy();
      this.abrController.destroy();
      this.bufferController.destroy();
      this.capLevelController.destroy();
      this.fpsController.destroy();
      this.streamController.destroy();
      this.audioStreamController.destroy();
      this.timelineController.destroy();
      this.audioTrackController.destroy();
      this.keyLoader.destroy();
      this.url = null;
      this.observer.removeAllListeners();
    }
  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }
  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }
  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

      _logger.logger.log('startLoad');
      this.levelController.startLoad();
      this.streamController.startLoad(startPosition);
      this.audioStreamController.startLoad(startPosition);
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.levelController.stopLoad();
      this.streamController.stopLoad();
      this.audioStreamController.stopLoad();
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }
  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /** Return all quality levels **/

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return this.levelController.firstLevel;
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      this.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this.abrController.autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this.abrController.autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      return this.audioTrackController.audioTracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.audioTrackController.audioTrack;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      this.audioTrackController.audioTrack = audioTrackId;
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }
  }]);

  return Hls;
}();

exports.default = Hls;

},{"./controller/abr-controller":3,"./controller/audio-stream-controller":4,"./controller/audio-track-controller":5,"./controller/buffer-controller":6,"./controller/cap-level-controller":7,"./controller/fps-controller":9,"./controller/level-controller":10,"./controller/stream-controller":11,"./controller/timeline-controller":12,"./errors":27,"./events":29,"./loader/fragment-loader":35,"./loader/key-loader":36,"./loader/playlist-loader":37,"./utils/cues":44,"./utils/logger":46,"./utils/xhr-loader":50,"events":1}],34:[function(require,module,exports){
'use strict';

// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports = require('./hls.js').default;

},{"./hls.js":33}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          config = this.hls.config;

      frag.loaded = 0;
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type:' + type);
        loader.abort();
      }
      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;
      if (!isNaN(start) && !isNaN(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous fragment loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _url = require('../utils/url');

var _url2 = _interopRequireDefault(_url);

var _attrList = require('../utils/attr-list');

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: 'manifest' });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: 'level', level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: 'audioTrack', id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var config = this.hls.config,
          retry,
          timeout,
          retryDelay,
          maxRetryDelay;
      if (context.type === 'manifest') {
        retry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeOut;
      } else {
        retry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeOut;
      }
      var loader = this.loaders[context.type];
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          _logger.logger.warn('playlist request ongoing');
          return;
        } else {
          _logger.logger.warn('abort previous loader for type:' + context.type);
          loader.abort();
        }
      }
      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
      context.url = url;
      context.responseType = '';

      var loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return _url2.default.buildAbsoluteURL(baseUrl, url);
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;

      // https://regex101.com is your friend
      var re = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
      while ((result = re.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = this.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        var codecs = attrs.CODECS;
        if (codecs) {
          codecs = codecs.split(',');
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            if (codec.indexOf('avc1') !== -1) {
              level.videoCodec = this.avc1toavcoti(codec);
            } else {
              level.audioCodec = codec;
            }
          }
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var result = void 0,
          medias = [];

      // https://regex101.com is your friend
      var re = /#EXT-X-MEDIA:(.*)/g;
      while ((result = re.exec(string)) != null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = this.resolve(attrs.URI, baseurl);
          }
          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }
          medias.push(media);
        }
      }
      return medias;
    }
    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */

  }, {
    key: 'createInitializationVector',
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = this.cloneObj(levelkey);
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'avc1toavcoti',
    value: function avc1toavcoti(codec) {
      var result,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'cloneObj',
    value: function cloneObj(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type) {
      var currentSN = 0,
          fragdecryptdata,
          totalduration = 0,
          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
          levelkey = { method: null, key: null, iv: null, uri: null },
          cc = 0,
          programDateTime = null,
          frag = null,
          result,
          regexp,
          duration = null,
          title = null,
          byteRangeEndOffset = null,
          byteRangeStartOffset = null,
          tagList = [];

      regexp = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE):(\d+))|(?:#EXT-X-(TARGETDURATION):(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT(INF):(\d+(?:\.\d+)?)(?:,(.*))?)|(?:(?!#)()(\S.+))|(?:#EXT-X-(BYTERANGE):(\d+(?:@\d+(?:\.\d+)?)?)|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(PROGRAM-DATE-TIME):(.+))|(?:#EXT-X-(VERSION):(\d+))|(?:(#)(.*):(.*))|(?:(#)(.*)))(?:.*)\r?\n?/g;
      while ((result = regexp.exec(string)) !== null) {
        result.shift();
        result = result.filter(function (n) {
          return n !== undefined;
        });
        switch (result[0]) {
          case 'PLAYLIST-TYPE':
            level.type = result[1].toUpperCase();
            break;
          case 'MEDIA-SEQUENCE':
            currentSN = level.startSN = parseInt(result[1]);
            break;
          case 'TARGETDURATION':
            level.targetduration = parseFloat(result[1]);
            break;
          case 'VERSION':
            level.version = parseInt(result[1]);
            break;
          case 'EXTM3U':
            break;
          case 'ENDLIST':
            level.live = false;
            break;
          case 'DIS':
            cc++;
            tagList.push(result);
            break;
          case 'BYTERANGE':
            var params = result[1].split('@');
            if (params.length === 1) {
              byteRangeStartOffset = byteRangeEndOffset;
            } else {
              byteRangeStartOffset = parseInt(params[1]);
            }
            byteRangeEndOffset = parseInt(params[0]) + byteRangeStartOffset;
            break;
          case 'INF':
            duration = parseFloat(result[1]);
            title = result[2] ? result[2] : null;
            tagList.push(result);
            break;
          case '':
            // url
            if (!isNaN(duration)) {
              var sn = currentSN++;
              fragdecryptdata = this.fragmentDecryptdataFromLevelkey(levelkey, sn);
              var url = result[1] ? this.resolve(result[1], baseurl) : null;
              frag = { url: url,
                type: type,
                duration: duration,
                title: title,
                start: totalduration,
                sn: sn,
                level: id,
                cc: cc,
                decryptdata: fragdecryptdata,
                programDateTime: programDateTime,
                tagList: tagList };
              // only include byte range options if used/needed
              if (byteRangeStartOffset !== null) {
                frag.byteRangeStartOffset = byteRangeStartOffset;
                frag.byteRangeEndOffset = byteRangeEndOffset;
              }
              level.fragments.push(frag);
              totalduration += duration;
              duration = null;
              title = null;
              byteRangeStartOffset = null;
              programDateTime = null;
              tagList = [];
            }
            break;
          case 'KEY':
            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
            var decryptparams = result[1];
            var keyAttrs = new _attrList2.default(decryptparams);
            var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                decrypturi = keyAttrs.URI,
                decryptiv = keyAttrs.hexadecimalInteger('IV');
            if (decryptmethod) {
              levelkey = { method: null, key: null, iv: null, uri: null };
              if (decrypturi && decryptmethod === 'AES-128') {
                levelkey.method = decryptmethod;
                // URI to get the key
                levelkey.uri = this.resolve(decrypturi, baseurl);
                levelkey.key = null;
                // Initialization Vector (IV)
                levelkey.iv = decryptiv;
              }
            }
            break;
          case 'START':
            var startParams = result[1];
            var startAttrs = new _attrList2.default(startParams);
            var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
            if (startTimeOffset) {
              level.startTimeOffset = startTimeOffset;
            }
            break;
          case 'PROGRAM-DATE-TIME':
            programDateTime = new Date(Date.parse(result[1]));
            tagList.push(result);
            break;
          case '#':
            result.shift();
            tagList.push(result);
            break;
          default:
            _logger.logger.warn('line parsed but not handled: ' + result);
            break;
        }
      }
      //logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.url) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      return level;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var string = response.data,
          url = response.url,
          type = context.type,
          id = context.id,
          level = context.level,
          hls = this.hls;

      this.loaders[type] = undefined;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      stats.tload = performance.now();
      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
      if (string.indexOf('#EXTM3U') === 0) {
        if (string.indexOf('#EXTINF:') > 0) {
          var isLevel = type !== 'audioTrack',
              levelDetails = this.parseLevelPlaylist(string, url, level || id || 0, isLevel ? 'main' : 'audio');
          levelDetails.tload = stats.tload;
          if (type === 'manifest') {
            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], url: url, stats: stats });
          }
          stats.tparsed = performance.now();
          if (isLevel) {
            hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
          } else {
            hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
          }
        } else {
          var levels = this.parseMasterPlaylist(string, url);
          // multi level playlist, parse level info
          if (levels.length) {
            var audiotracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
            if (audiotracks.length) {
              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
              var embeddedAudioFound = false;
              audiotracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                  embeddedAudioFound = true;
                }
              });
              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audiotracks.unshift({ type: 'main', name: 'main' });
              }
            }
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audiotracks, url: url, stats: stats });
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });
          }
        }
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/attr-list":41,"../utils/logger":46,"../utils/url":49}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';
var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        mvex: [],
        mvhd: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var bytes = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // creation_time
      0x00, 0x00, 0x00, 0x02, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24 & 0xFF, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i,
          data,
          len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);
        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);
        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height;
      //console.log('avcc:' + Hex.hexDump(avcc));
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate
      );
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, //es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, //codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var audiosamplerate = track.audiosamplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height;
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, // creation_time
      0x00, 0x00, 0x00, 0x00, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id;
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      baseMediaDecodeTime >> 24, baseMediaDecodeTime >> 16 & 0XFF, baseMediaDecodeTime >> 8 & 0XFF, baseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      16 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i,
          sample,
          duration,
          size,
          flags,
          cts;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      var movie = MP4.moov(tracks),
          result;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aac = require('../helper/aac');

var _aac2 = _interopRequireDefault(_aac);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _mp4Generator = require('../remux/mp4-generator');

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = require('../errors');

require('../utils/polyfill');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP4Remuxer = function () {
  function MP4Remuxer(observer, id, config) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.id = id;
    this.config = config;
    this.ISGenerated = false;
    this.PES2MP4SCALEFACTOR = 4;
    this.PES_TIMESCALE = 90000;
    this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._initPTS = this._initDTS = undefined;
    }
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous) {
      this.level = level;
      this.sn = sn;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAacPts, which is
        // calculated in remuxAudio.
        //logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (audioTrack.samples.length) {
          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous);
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }
            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
          }
        } else {
          var videoData = void 0;
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
          }
          if (videoData && audioTrack.codec) {
            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
          }
        }
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }
      //notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED, { id: this.id, level: this.level, sn: this.sn });
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          pesTimeScale = this.PES_TIMESCALE,
          tracks = {},
          data = { id: this.id, level: this.level, sn: this.sn, tracks: tracks, unique: false },
          computePTSDTS = this._initPTS === undefined,
          initPTS,
          initDTS;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        audioTrack.timescale = audioTrack.audiosamplerate;
        // MP4 duration (track duration in seconds multiplied by timescale) is coded on 32 bits
        // we know that each AAC sample contains 1024 frames....
        // in order to avoid overflowing the 32 bit counter for large duration, we use smaller timescale (timescale/gcd)
        // we just need to ensure that AAC sample duration will still be an integer (will be 1024/gcd)
        if (audioTrack.timescale * audioTrack.duration > Math.pow(2, 32)) {
          (function () {
            var greatestCommonDivisor = function greatestCommonDivisor(a, b) {
              if (!b) {
                return a;
              }
              return greatestCommonDivisor(b, a % b);
            };
            audioTrack.timescale = audioTrack.audiosamplerate / greatestCommonDivisor(audioTrack.audiosamplerate, 1024);
          })();
        }
        _logger.logger.log('audio mp4 timescale :' + audioTrack.timescale);
        tracks.audio = {
          container: 'audio/mp4',
          codec: audioTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS + DTS ...
          initPTS = initDTS = audioSamples[0].pts - pesTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        videoTrack.timescale = this.MP4_TIMESCALE;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - pesTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - pesTimeScale * timeOffset);
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      var offset = 8,
          pesTimeScale = this.PES_TIMESCALE,
          pes2mp4ScaleFactor = this.PES2MP4SCALEFACTOR,
          mp4SampleDuration,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          nextDTS,
          lastPTS,
          lastDTS,
          inputSamples = track.samples,
          outputSamples = [];

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      var nextAvcDts = void 0;
      if (contiguous) {
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        nextAvcDts = this.nextAvcDts;
      } else {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * pesTimeScale;
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(this._PTSNormalize(sample.dts - this._initDTS, nextAvcDts), 0);
      firstPTS = Math.max(this._PTSNormalize(sample.pts - this._initDTS, nextAvcDts), 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }
          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS + this._initDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS + this._initDTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + firstPTS + '/' + firstDTS + ',delta:' + delta);
        }
      }
      nextDTS = firstDTS;

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(this._PTSNormalize(sample.dts - this._initDTS, nextAvcDts), 0);
      lastPTS = Math.max(this._PTSNormalize(sample.pts - this._initDTS, nextAvcDts), 0);
      lastPTS = Math.max(lastPTS, lastDTS);

      var vendor = navigator.vendor,
          userAgent = navigator.userAgent,
          isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (pes2mp4ScaleFactor * (inputSamples.length - 1)));
      }

      // normalize all PTS/DTS now ...
      for (var i = 0; i < inputSamples.length; i++) {
        var _sample = inputSamples[i];
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + i * pes2mp4ScaleFactor * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(this._PTSNormalize(_sample.dts - this._initDTS, nextAvcDts), firstDTS);
          // ensure dts is a multiple of scale factor to avoid rounding issues
          _sample.dts = Math.round(_sample.dts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
        }
        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
        // and we ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(this._PTSNormalize(_sample.pts - this._initDTS, nextAvcDts), _sample.dts);
        // ensure pts is a multiple of scale factor to avoid rounding issues
        _sample.pts = Math.round(_sample.pts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      mdat = new Uint8Array(track.len + 4 * track.nbNalu + 8);
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdat.byteLength);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i = 0; _i < inputSamples.length; _i++) {
        var avcSample = inputSamples[_i],
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        while (avcSample.units.units.length) {
          var unit = avcSample.units.units.shift();
          view.setUint32(offset, unit.data.byteLength);
          offset += 4;
          mdat.set(unit.data, offset);
          offset += unit.data.byteLength;
          mp4SampleLength += 4 + unit.data.byteLength;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i < inputSamples.length - 1) {
            mp4SampleDuration = inputSamples[_i + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i > 0 ? _i - 1 : _i].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  maxSeekHole = config.maxSeekHole,
                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * pesTimeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * pesTimeScale : this.nextAacPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }
                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          mp4SampleDuration /= pes2mp4ScaleFactor;
          compositionTimeOffset = Math.round((avcSample.pts - avcSample.dts) / pes2mp4ScaleFactor);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / (pes2mp4ScaleFactor * mp4SampleDuration)));
        }

        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${this._initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration * pes2mp4ScaleFactor;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
      track.samples = [];

      var data = {
        id: this.id,
        level: this.level,
        sn: this.sn,
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / pesTimeScale,
        endPTS: (lastPTS + pes2mp4ScaleFactor * mp4SampleDuration) / pesTimeScale,
        startDTS: firstDTS / pesTimeScale,
        endDTS: this.nextAvcDts / pesTimeScale,
        type: 'video',
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,
          expectedSampleDuration = track.timescale * 1024 / track.audiosamplerate;
      var view,
          offset = 8,
          aacSample,
          mp4Sample,
          unit,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          lastDTS,
          pts,
          dts,
          ptsnorm,
          dtsnorm,
          samples = [],
          samples0 = [],
          fillFrame,
          newStamp;

      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });
      samples0 = track.samples;

      var nextAacPts = contiguous ? this.nextAacPts : timeOffset * pesTimeScale;

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.
      var pesFrameDuration = expectedSampleDuration * pes2mp4ScaleFactor;
      var nextPtsNorm = nextAacPts;
      for (var i = 0; i < samples0.length;) {
        // First, let's see how far off this frame is from where we expect it to be
        var sample = samples0[i],
            ptsNorm = this._PTSNormalize(sample.pts - this._initDTS, nextAacPts),
            delta = ptsNorm - nextPtsNorm;

        // If we're overlapping by more than half a duration, drop this sample
        if (delta < -0.5 * pesFrameDuration) {
          _logger.logger.log('Dropping frame due to ' + Math.round(Math.abs(delta / 90)) + ' ms overlap.');
          samples0.splice(i, 1);
          track.len -= sample.unit.length;
          // Don't touch nextPtsNorm or i
        }
        // Otherwise, if we're more than half a frame away from where we should be, insert missing frames
        else if (delta > 0.5 * pesFrameDuration) {
            var missing = Math.round(delta / pesFrameDuration);
            _logger.logger.log('Injecting ' + missing + ' frame' + (missing > 1 ? 's' : '') + ' of missing audio due to ' + Math.round(delta / 90) + ' ms gap.');
            for (var j = 0; j < missing; j++) {
              newStamp = sample.pts - (missing - j) * pesFrameDuration;
              newStamp = Math.max(newStamp, this._initDTS);
              fillFrame = _aac2.default.getSilentFrame(track.channelCount);
              if (!fillFrame) {
                _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                fillFrame = sample.unit.slice(0);
              }
              samples0.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
              track.len += fillFrame.length;
              i += 1;
            }

            // Adjust sample to next expected pts
            sample.pts = samples0[i - 1].pts + pesFrameDuration;
            nextPtsNorm = this._PTSNormalize(sample.pts + pesFrameDuration - this._initDTS, nextAacPts);
            i += 1;
          }
          // Otherwise, we're within half a frame duration, so just adjust pts
          else {
              if (Math.abs(delta) > 0.1 * pesFrameDuration) {
                _logger.logger.log('Invalid frame delta ' + Math.round(ptsNorm - nextPtsNorm + pesFrameDuration) + ' at PTS ' + Math.round(ptsNorm / 90) + ' (should be ' + Math.round(pesFrameDuration) + ').');
              }
              nextPtsNorm += pesFrameDuration;
              if (i === 0) {
                sample.pts = this._initDTS + nextAacPts;
              } else {
                sample.pts = samples0[i - 1].pts + pesFrameDuration;
              }
              i += 1;
            }
      }

      while (samples0.length) {
        aacSample = samples0.shift();
        unit = aacSample.unit;
        pts = aacSample.pts - this._initDTS;
        dts = aacSample.dts - this._initDTS;
        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastDTS !== undefined) {
          ptsnorm = this._PTSNormalize(pts, lastDTS);
          dtsnorm = this._PTSNormalize(dts, lastDTS);
          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / pes2mp4ScaleFactor);
        } else {
          ptsnorm = this._PTSNormalize(pts, nextAacPts);
          dtsnorm = this._PTSNormalize(dts, nextAacPts);
          var _delta = Math.round(1000 * (ptsnorm - nextAacPts) / pesTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          if (contiguous) {
            // log delta
            if (_delta) {
              if (_delta > 0) {
                numMissingFrames = Math.round((ptsnorm - nextAacPts) / pesFrameDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aac2.default.getSilentFrame(track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.slice(0);
                  }
                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              ptsnorm = dtsnorm = nextAacPts;
            }
          }
          // remember first PTS of our aacSamples, ensure value is positive
          firstPTS = Math.max(0, ptsnorm);
          firstDTS = Math.max(0, dtsnorm);
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            mdat = new Uint8Array(track.len + 8);
            view = new DataView(mdat.buffer);
            view.setUint32(0, mdat.byteLength);
            mdat.set(_mp4Generator2.default.types.mdat, 4);
          } else {
            // no audio samples
            return;
          }
          for (i = 0; i < numMissingFrames; i++) {
            newStamp = ptsnorm - (numMissingFrames - i) * pesFrameDuration;
            fillFrame = _aac2.default.getSilentFrame(track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.slice(0);
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            samples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        offset += unit.byteLength;
        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${aacSample.pts}/${aacSample.dts}/${this._initDTS}/${ptsnorm}/${dtsnorm}/${(aacSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unit.byteLength,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        samples.push(mp4Sample);
        lastDTS = dtsnorm;
      }
      var lastSampleDuration = 0;
      var nbSamples = samples.length;
      //set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = samples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next aac sample PTS should be equal to last sample PTS + duration
        this.nextAacPts = ptsnorm + pes2mp4ScaleFactor * lastSampleDuration;
        //logger.log('Audio/PTS/PTSend:' + aacSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = samples;
        moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
        track.samples = [];
        var audioData = {
          id: this.id,
          level: this.level,
          sn: this.sn,
          data1: moof,
          data2: mdat,
          startPTS: firstPTS / pesTimeScale,
          endPTS: this.nextAacPts / pesTimeScale,
          startDTS: firstDTS / pesTimeScale,
          endDTS: (dtsnorm + pes2mp4ScaleFactor * lastSampleDuration) / pesTimeScale,
          type: 'audio',
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale ? track.timescale : track.audiosamplerate,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,


      // sync with video's timestamp
      startDTS = videoData.startDTS * pesTimeScale + this._initDTS,
          endDTS = videoData.endDTS * pesTimeScale + this._initDTS,


      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = pes2mp4ScaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aac2.default.getSilentFrame(track.channelCount);

      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame.slice(0), pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track, timeOffset) {
      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
          sample.dts = (sample.dts - this._initDTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track, timeOffset) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset;
      if (reference === undefined) {
        return value;
      }
      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return false;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

},{"../errors":27,"../events":29,"../helper/aac":30,"../remux/mp4-generator":38,"../utils/logger":46,"../utils/polyfill":47}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer, id) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
    this.id = id;
    this.ISGenerated = false;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {}
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, rawData) {
      var observer = this.observer;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        var tracks = {},
            data = { id: this.id, tracks: tracks, unique: true },
            track = videoTrack,
            codec = track.codec;

        if (codec) {
          data.tracks.video = {
            container: track.container,
            codec: codec,
            metadata: {
              width: track.width,
              height: track.height
            }
          };
        }

        track = audioTrack;
        codec = track.codec;
        if (codec) {
          data.tracks.audio = {
            container: track.container,
            codec: codec,
            metadata: {
              channelCount: track.channelCount
            }
          };
        }
        this.ISGenerated = true;
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
      }
      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        id: this.id,
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: 'audiovideo',
        nb: 1,
        dropped: 0
      });
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return true;
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

},{"../events":29}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = /^(\d+)x(\d+)$/.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var re = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
      var match,
          attrs = {};
      while ((match = re.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;

},{}],42:[function(require,module,exports){
"use strict";

var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

module.exports = BinarySearch;

},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 32;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        _classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    _createClass(PenState, [{
        key: 'reset',
        value: function reset() {
            this.foreground = 'white';
            this.underline = false;
            this.italics = false;
            this.background = 'black';
            this.flash = false;
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
            for (var i = 0; i < attribs.length; i++) {
                var style = attribs[i];
                if (styles.hasOwnProperty(style)) {
                    this[style] = styles[style];
                }
            }
        }
    }, {
        key: 'isDefault',
        value: function isDefault() {
            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        }
    }, {
        key: 'copy',
        value: function copy(newPenState) {
            this.foreground = newPenState.foreground;
            this.underline = newPenState.underline;
            this.italics = newPenState.italics;
            this.background = newPenState.background;
            this.flash = newPenState.flash;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
        }
    }]);

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        _classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    _createClass(StyledUnicodeChar, [{
        key: 'reset',
        value: function reset() {
            this.uchar = ' ';
            this.penState.reset();
        }
    }, {
        key: 'setChar',
        value: function setChar(uchar, newPenState) {
            this.uchar = uchar;
            this.penState.copy(newPenState);
        }
    }, {
        key: 'setPenState',
        value: function setPenState(newPenState) {
            this.penState.copy(newPenState);
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.uchar === other.uchar && this.penState.equals(other.penState);
        }
    }, {
        key: 'copy',
        value: function copy(newChar) {
            this.uchar = newChar.uchar;
            this.penState.copy(newChar.penState);
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this.uchar === ' ' && this.penState.isDefault();
        }
    }]);

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        _classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    _createClass(Row, [{
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].equals(other.chars[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_COLS; i++) {
                this.chars[i].copy(other.chars[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }

        /**
         *  Set the cursor to a valid column.
         */

    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            if (this.pos !== absPos) {
                this.pos = absPos;
            }
            if (this.pos < 0) {
                logger.log('ERROR', 'Negative cursor position ' + this.pos);
                this.pos = 0;
            } else if (this.pos > NR_COLS) {
                logger.log('ERROR', 'Too large cursor position ' + this.pos);
                this.pos = NR_COLS;
            }
        }

        /**
         * Move the cursor relative to current position.
         */

    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var newPos = this.pos + relPos;
            if (relPos > 1) {
                for (var i = this.pos + 1; i < newPos + 1; i++) {
                    this.chars[i].setPenState(this.currPenState);
                }
            }
            this.setCursor(newPos);
        }

        /**
         * Backspace, move one step back and clear character.
         */

    }, {
        key: 'backSpace',
        value: function backSpace() {
            this.moveCursor(-1);
            this.chars[this.pos].setChar(' ', this.currPenState);
        }
    }, {
        key: 'insertChar',
        value: function insertChar(byte) {
            if (byte >= 0x90) {
                //Extended char
                this.backSpace();
            }
            var char = getCharForByte(byte);
            if (this.pos >= NR_COLS) {
                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                return;
            }
            this.chars[this.pos].setChar(char, this.currPenState);
            this.moveCursor(1);
        }
    }, {
        key: 'clearFromPos',
        value: function clearFromPos(startPos) {
            var i;
            for (i = startPos; i < NR_COLS; i++) {
                this.chars[i].reset();
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clearFromPos(0);
            this.pos = 0;
            this.currPenState.reset();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            this.clearFromPos(this.pos);
        }
    }, {
        key: 'getTextString',
        value: function getTextString() {
            var chars = [];
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                var char = this.chars[i].uchar;
                if (char !== ' ') {
                    empty = false;
                }
                chars.push(char);
            }
            if (empty) {
                return '';
            } else {
                return chars.join('');
            }
        }
    }, {
        key: 'setPenStyles',
        value: function setPenStyles(styles) {
            this.currPenState.setStyles(styles);
            var currChar = this.chars[this.pos];
            currChar.setPenState(this.currPenState);
        }
    }]);

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        _classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    _createClass(CaptionScreen, [{
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            this.currRow = NR_ROWS - 1;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].equals(other.rows[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].copy(other.rows[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }
    }, {
        key: 'backSpace',
        value: function backSpace() {
            var row = this.rows[this.currRow];
            row.backSpace();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            var row = this.rows[this.currRow];
            row.clearToEndOfRow();
        }

        /**
         * Insert a character (without styling) in the current row.
         */

    }, {
        key: 'insertChar',
        value: function insertChar(char) {
            var row = this.rows[this.currRow];
            row.insertChar(char);
        }
    }, {
        key: 'setPen',
        value: function setPen(styles) {
            var row = this.rows[this.currRow];
            row.setPenStyles(styles);
        }
    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var row = this.rows[this.currRow];
            row.moveCursor(relPos);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            logger.log('INFO', 'setCursor: ' + absPos);
            var row = this.rows[this.currRow];
            row.setCursor(absPos);
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
            var newRow = pacData.row - 1;
            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                newRow = this.nrRollUpRows - 1;
            }
            this.currRow = newRow;
            var row = this.rows[this.currRow];
            if (pacData.indent !== null) {
                var indent = pacData.indent;
                var prevPos = Math.max(indent - 1, 0);
                row.setCursor(pacData.indent);
                pacData.color = row.chars[prevPos].penState.foreground;
            }
            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
            this.setPen(styles);
        }

        /**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */

    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {

            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
            this.backSpace();
            this.setPen(bkgData);
            this.insertChar(0x20); //Space
        }
    }, {
        key: 'setRollUpRows',
        value: function setRollUpRows(nrRows) {
            this.nrRollUpRows = nrRows;
        }
    }, {
        key: 'rollUp',
        value: function rollUp() {
            if (this.nrRollUpRows === null) {
                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                return; //Not properly setup
            }
            logger.log('TEXT', this.getDisplayText());
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var topRow = this.rows.splice(topRowIndex, 1)[0];
            topRow.clear();
            this.rows.splice(this.currRow, 0, topRow);
            logger.log('INFO', 'Rolling up');
            //logger.log('TEXT', this.get_display_text())
        }

        /**
         * Get all non-empty rows with as unicode text.
         */

    }, {
        key: 'getDisplayText',
        value: function getDisplayText(asOneRow) {
            asOneRow = asOneRow || false;
            var displayText = [];
            var text = '';
            var rowNr = -1;
            for (var i = 0; i < NR_ROWS; i++) {
                var rowText = this.rows[i].getTextString();
                if (rowText) {
                    rowNr = i + 1;
                    if (asOneRow) {
                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                    } else {
                        displayText.push(rowText.trim());
                    }
                }
            }
            if (displayText.length > 0) {
                if (asOneRow) {
                    text = '[' + displayText.join(' | ') + ']';
                } else {
                    text = displayText.join('\n');
                }
            }
            return text;
        }
    }, {
        key: 'getTextAndFormat',
        value: function getTextAndFormat() {
            return this.rows;
        }
    }]);

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        _classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    _createClass(Cea608Channel, [{
        key: 'reset',
        value: function reset() {
            this.mode = null;
            this.displayedMemory.reset();
            this.nonDisplayedMemory.reset();
            this.lastOutputScreen.reset();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null;
            this.lastCueEndTime = null;
        }
    }, {
        key: 'getHandler',
        value: function getHandler() {
            return this.outputFilter;
        }
    }, {
        key: 'setHandler',
        value: function setHandler(newHandler) {
            this.outputFilter = newHandler;
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            this.writeScreen.setPAC(pacData);
        }
    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {
            this.writeScreen.setBkgData(bkgData);
        }
    }, {
        key: 'setMode',
        value: function setMode(newMode) {
            if (newMode === this.mode) {
                return;
            }
            this.mode = newMode;
            logger.log('INFO', 'MODE=' + newMode);
            if (this.mode === 'MODE_POP-ON') {
                this.writeScreen = this.nonDisplayedMemory;
            } else {
                this.writeScreen = this.displayedMemory;
                this.writeScreen.reset();
            }
            if (this.mode !== 'MODE_ROLL-UP') {
                this.displayedMemory.nrRollUpRows = null;
                this.nonDisplayedMemory.nrRollUpRows = null;
            }
            this.mode = newMode;
        }
    }, {
        key: 'insertChars',
        value: function insertChars(chars) {
            for (var i = 0; i < chars.length; i++) {
                this.writeScreen.insertChar(chars[i]);
            }
            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccRCL',
        value: function ccRCL() {
            // Resume Caption Loading (switch mode to Pop On)
            logger.log('INFO', 'RCL - Resume Caption Loading');
            this.setMode('MODE_POP-ON');
        }
    }, {
        key: 'ccBS',
        value: function ccBS() {
            // BackSpace
            logger.log('INFO', 'BS - BackSpace');
            if (this.mode === 'MODE_TEXT') {
                return;
            }
            this.writeScreen.backSpace();
            if (this.writeScreen === this.displayedMemory) {
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccAOF',
        value: function ccAOF() {
            // Reserved (formerly Alarm Off)
            return;
        }
    }, {
        key: 'ccAON',
        value: function ccAON() {
            // Reserved (formerly Alarm On)
            return;
        }
    }, {
        key: 'ccDER',
        value: function ccDER() {
            // Delete to End of Row
            logger.log('INFO', 'DER- Delete to End of Row');
            this.writeScreen.clearToEndOfRow();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccRU',
        value: function ccRU(nrRows) {
            //Roll-Up Captions-2,3,or 4 Rows
            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
            this.writeScreen = this.displayedMemory;
            this.setMode('MODE_ROLL-UP');
            this.writeScreen.setRollUpRows(nrRows);
        }
    }, {
        key: 'ccFON',
        value: function ccFON() {
            //Flash On
            logger.log('INFO', 'FON - Flash On');
            this.writeScreen.setPen({ flash: true });
        }
    }, {
        key: 'ccRDC',
        value: function ccRDC() {
            // Resume Direct Captioning (switch mode to PaintOn)
            logger.log('INFO', 'RDC - Resume Direct Captioning');
            this.setMode('MODE_PAINT-ON');
        }
    }, {
        key: 'ccTR',
        value: function ccTR() {
            // Text Restart in text mode (not supported, however)
            logger.log('INFO', 'TR');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccRTD',
        value: function ccRTD() {
            // Resume Text Display in Text mode (not supported, however)
            logger.log('INFO', 'RTD');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccEDM',
        value: function ccEDM() {
            // Erase Displayed Memory
            logger.log('INFO', 'EDM - Erase Displayed Memory');
            this.displayedMemory.reset();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccCR',
        value: function ccCR() {
            // Carriage Return
            logger.log('CR - Carriage Return');
            this.writeScreen.rollUp();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccENM',
        value: function ccENM() {
            //Erase Non-Displayed Memory
            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
            this.nonDisplayedMemory.reset();
        }
    }, {
        key: 'ccEOC',
        value: function ccEOC() {
            //End of Caption (Flip Memories)
            logger.log('INFO', 'EOC - End Of Caption');
            if (this.mode === 'MODE_POP-ON') {
                var tmp = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory;
                this.nonDisplayedMemory = tmp;
                this.writeScreen = this.nonDisplayedMemory;
                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate();
        }
    }, {
        key: 'ccTO',
        value: function ccTO(nrCols) {
            // Tab Offset 1,2, or 3 columns
            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
            this.writeScreen.moveCursor(nrCols);
        }
    }, {
        key: 'ccMIDROW',
        value: function ccMIDROW(secondByte) {
            // Parse MIDROW command
            var styles = { flash: false };
            styles.underline = secondByte % 2 === 1;
            styles.italics = secondByte >= 0x2e;
            if (!styles.italics) {
                var colorIndex = Math.floor(secondByte / 2) - 0x10;
                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                styles.foreground = colors[colorIndex];
            } else {
                styles.foreground = 'white';
            }
            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
            this.writeScreen.setPen(styles);
        }
    }, {
        key: 'outputDataUpdate',
        value: function outputDataUpdate() {
            var t = logger.time;
            if (t === null) {
                return;
            }
            if (this.outputFilter) {
                if (this.outputFilter.updateData) {
                    this.outputFilter.updateData(t, this.displayedMemory);
                }
                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                    // Start of a new cue
                    this.cueStartTime = t;
                } else {
                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                    }
                }
                this.lastOutputScreen.copy(this.displayedMemory);
            }
        }
    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            if (this.outputFilter) {
                if (!this.displayedMemory.isEmpty()) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                    }
                    this.cueStartTime = t;
                }
            }
        }
    }]);

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        _classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    _createClass(Cea608Parser, [{
        key: 'getHandler',
        value: function getHandler(index) {
            return this.channels[index].getHandler();
        }
    }, {
        key: 'setHandler',
        value: function setHandler(index, newHandler) {
            this.channels[index].setHandler(newHandler);
        }

        /**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */

    }, {
        key: 'addData',
        value: function addData(t, byteList) {
            var cmdFound,
                a,
                b,
                charsFound = false;

            this.lastTime = t;
            logger.setTime(t);

            for (var i = 0; i < byteList.length; i += 2) {
                a = byteList[i] & 0x7f;
                b = byteList[i + 1] & 0x7f;
                if (a === 0 && b === 0) {
                    this.dataCounters.padding += 2;
                    continue;
                } else {
                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                }
                cmdFound = this.parseCmd(a, b);
                if (!cmdFound) {
                    cmdFound = this.parseMidrow(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parsePAC(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parseBackgroundAttributes(a, b);
                }
                if (!cmdFound) {
                    charsFound = this.parseChars(a, b);
                    if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                            var channel = this.channels[this.currChNr - 1];
                            channel.insertChars(charsFound);
                        } else {
                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                        }
                    }
                }
                if (cmdFound) {
                    this.dataCounters.cmd += 2;
                } else if (charsFound) {
                    this.dataCounters.char += 2;
                } else {
                    this.dataCounters.other += 2;
                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                }
            }
        }

        /**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */

    }, {
        key: 'parseCmd',
        value: function parseCmd(a, b) {
            var chNr = null;

            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
            if (!(cond1 || cond2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null; // Repeated commands are dropped (once)
                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                return true;
            }

            if (a === 0x14 || a === 0x17) {
                chNr = 1;
            } else {
                chNr = 2; // (a === 0x1C || a=== 0x1f)
            }

            var channel = this.channels[chNr - 1];

            if (a === 0x14 || a === 0x1C) {
                if (b === 0x20) {
                    channel.ccRCL();
                } else if (b === 0x21) {
                    channel.ccBS();
                } else if (b === 0x22) {
                    channel.ccAOF();
                } else if (b === 0x23) {
                    channel.ccAON();
                } else if (b === 0x24) {
                    channel.ccDER();
                } else if (b === 0x25) {
                    channel.ccRU(2);
                } else if (b === 0x26) {
                    channel.ccRU(3);
                } else if (b === 0x27) {
                    channel.ccRU(4);
                } else if (b === 0x28) {
                    channel.ccFON();
                } else if (b === 0x29) {
                    channel.ccRDC();
                } else if (b === 0x2A) {
                    channel.ccTR();
                } else if (b === 0x2B) {
                    channel.ccRTD();
                } else if (b === 0x2C) {
                    channel.ccEDM();
                } else if (b === 0x2D) {
                    channel.ccCR();
                } else if (b === 0x2E) {
                    channel.ccENM();
                } else if (b === 0x2F) {
                    channel.ccEOC();
                }
            } else {
                //a == 0x17 || a == 0x1F
                channel.ccTO(b - 0x20);
            }
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Parse midrow styling command
         * @returns {Boolean}
         */

    }, {
        key: 'parseMidrow',
        value: function parseMidrow(a, b) {
            var chNr = null;

            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                if (a === 0x11) {
                    chNr = 1;
                } else {
                    chNr = 2;
                }
                if (chNr !== this.currChNr) {
                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
                    return false;
                }
                var channel = this.channels[chNr - 1];
                channel.ccMIDROW(b);
                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                return true;
            }
            return false;
        }
        /**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */

    }, {
        key: 'parsePAC',
        value: function parsePAC(a, b) {

            var chNr = null;
            var row = null;

            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
            if (!(case1 || case2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true; // Repeated commands are dropped (once)
            }

            chNr = a <= 0x17 ? 1 : 2;

            if (0x40 <= b && b <= 0x5F) {
                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
            } else {
                // 0x60 <= b <= 0x7F
                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
            }
            var pacData = this.interpretPAC(row, b);
            var channel = this.channels[chNr - 1];
            channel.setPAC(pacData);
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */

    }, {
        key: 'interpretPAC',
        value: function interpretPAC(row, byte) {
            var pacIndex = byte;
            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

            if (byte > 0x5F) {
                pacIndex = byte - 0x60;
            } else {
                pacIndex = byte - 0x40;
            }
            pacData.underline = (pacIndex & 1) === 1;
            if (pacIndex <= 0xd) {
                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
            } else if (pacIndex <= 0xf) {
                pacData.italics = true;
                pacData.color = 'white';
            } else {
                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
            }
            return pacData; // Note that row has zero offset. The spec uses 1.
        }

        /**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */

    }, {
        key: 'parseChars',
        value: function parseChars(a, b) {

            var channelNr = null,
                charCodes = null,
                charCode1 = null;

            if (a >= 0x19) {
                channelNr = 2;
                charCode1 = a - 8;
            } else {
                channelNr = 1;
                charCode1 = a;
            }
            if (0x11 <= charCode1 && charCode1 <= 0x13) {
                // Special character
                var oneCode = b;
                if (charCode1 === 0x11) {
                    oneCode = b + 0x50;
                } else if (charCode1 === 0x12) {
                    oneCode = b + 0x70;
                } else {
                    oneCode = b + 0x90;
                }
                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                charCodes = [oneCode];
            } else if (0x20 <= a && a <= 0x7f) {
                charCodes = b === 0 ? [a] : [a, b];
            }
            if (charCodes) {
                var hexCodes = numArrayToHexArray(charCodes);
                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
            return charCodes;
        }

        /**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */

    }, {
        key: 'parseBackgroundAttributes',
        value: function parseBackgroundAttributes(a, b) {
            var bkgData, index, chNr, channel;

            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
            if (!(case1 || case2)) {
                return false;
            }
            bkgData = {};
            if (a === 0x10 || a === 0x18) {
                index = Math.floor((b - 0x20) / 2);
                bkgData.background = backgroundColors[index];
                if (b % 2 === 1) {
                    bkgData.background = bkgData.background + '_semi';
                }
            } else if (b === 0x2d) {
                bkgData.background = 'transparent';
            } else {
                bkgData.foreground = 'black';
                if (b === 0x2f) {
                    bkgData.underline = true;
                }
            }
            chNr = a < 0x18 ? 1 : 2;
            channel = this.channels[chNr - 1];
            channel.setBkgData(bkgData);
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true;
        }

        /**
         * Reset state of parser and its channels.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].reset();
                }
            }
            this.lastCmdA = null;
            this.lastCmdB = null;
        }

        /**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */

    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].cueSplitAtTime(t);
                }
            }
        }
    }]);

    return Cea608Parser;
}();

exports.default = Cea608Parser;

},{}],44:[function(require,module,exports){
'use strict';

var Cues = {

  newCue: function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;

    for (var r = 0; r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = '';

      if (!row.isEmpty()) {
        for (var c = 0; c < row.chars.length; c++) {
          if (row.chars[c].uchar.match(/\s/) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        cue = new VTTCue(startTime, endTime, text.trim());

        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }

        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
        // also, drop line 1 since it's to close to the top
        if (navigator.userAgent.match(/Firefox\//)) {
          cue.line = r + 1;
        } else {
          cue.line = r > 7 ? r - 2 : r + 1;
        }
        cue.align = 'left';
        cue.position = 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0);
        track.addCue(cue);
      }
    }
  }

};

module.exports = Cues;

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = window.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(window.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

},{}],47:[function(require,module,exports){
'use strict';

if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
  ArrayBuffer.prototype.slice = function (start, end) {
    var that = new Uint8Array(this);
    if (end === undefined) {
      end = that.length;
    }
    var result = new ArrayBuffer(end - start);
    var resultArray = new Uint8Array(result);
    for (var i = 0; i < resultArray.length; i++) {
      resultArray[i] = that[i + start];
    }
    return result;
  };
}

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  TimeRanges to string helper
 */

var TimeRanges = function () {
  function TimeRanges() {
    _classCallCheck(this, TimeRanges);
  }

  _createClass(TimeRanges, null, [{
    key: 'toString',
    value: function toString(r) {
      var log = '',
          len = r.length;
      for (var i = 0; i < len; i++) {
        log += '[' + r.start(i) + ',' + r.end(i) + ']';
      }
      return log;
    }
  }]);

  return TimeRanges;
}();

exports.default = TimeRanges;

},{}],49:[function(require,module,exports){
'use strict';

var URLHelper = {
  // build an absolute URL from a relative one using the provided baseURL
  // if relativeURL is an absolute URL it will be returned as is.
  buildAbsoluteURL: function buildAbsoluteURL(baseURL, relativeURL) {
    // remove any remaining space and CRLF
    relativeURL = relativeURL.trim();
    if (/^[a-z]+:/i.test(relativeURL)) {
      // complete url, not relative
      return relativeURL;
    }

    var relativeURLQuery = null;
    var relativeURLHash = null;

    var relativeURLHashSplit = /^([^#]*)(.*)$/.exec(relativeURL);
    if (relativeURLHashSplit) {
      relativeURLHash = relativeURLHashSplit[2];
      relativeURL = relativeURLHashSplit[1];
    }
    var relativeURLQuerySplit = /^([^\?]*)(.*)$/.exec(relativeURL);
    if (relativeURLQuerySplit) {
      relativeURLQuery = relativeURLQuerySplit[2];
      relativeURL = relativeURLQuerySplit[1];
    }

    var baseURLHashSplit = /^([^#]*)(.*)$/.exec(baseURL);
    if (baseURLHashSplit) {
      baseURL = baseURLHashSplit[1];
    }
    var baseURLQuerySplit = /^([^\?]*)(.*)$/.exec(baseURL);
    if (baseURLQuerySplit) {
      baseURL = baseURLQuerySplit[1];
    }

    var baseURLDomainSplit = /^(([a-z]+:)?\/\/[a-z0-9\.\-_~]+(:[0-9]+)?)?(\/.*)$/i.exec(baseURL);
    if (!baseURLDomainSplit) {
      throw new Error('Error trying to parse base URL.');
    }

    // e.g. 'http:', 'https:', ''
    var baseURLProtocol = baseURLDomainSplit[2] || '';
    // e.g. 'http://example.com', '//example.com', ''
    var baseURLProtocolDomain = baseURLDomainSplit[1] || '';
    // e.g. '/a/b/c/playlist.m3u8'
    var baseURLPath = baseURLDomainSplit[4];

    var builtURL = null;
    if (/^\/\//.test(relativeURL)) {
      // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)
      builtURL = baseURLProtocol + '//' + URLHelper.buildAbsolutePath('', relativeURL.substring(2));
    } else if (/^\//.test(relativeURL)) {
      // relative url starts with '/' so start from root of domain
      builtURL = baseURLProtocolDomain + '/' + URLHelper.buildAbsolutePath('', relativeURL.substring(1));
    } else {
      builtURL = URLHelper.buildAbsolutePath(baseURLProtocolDomain + baseURLPath, relativeURL);
    }

    // put the query and hash parts back
    if (relativeURLQuery) {
      builtURL += relativeURLQuery;
    }
    if (relativeURLHash) {
      builtURL += relativeURLHash;
    }
    return builtURL;
  },

  // build an absolute path using the provided basePath
  // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter
  // this does not handle the case where relativePath is "/" or "//". These cases should be handled outside this.
  buildAbsolutePath: function buildAbsolutePath(basePath, relativePath) {
    var sRelPath = relativePath;
    var nUpLn,
        sDir = '',
        sPath = basePath.replace(/[^\/]*$/, sRelPath.replace(/(\/|^)(?:\.?\/+)+/g, '$1'));
    for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {
      nUpLn = /^\/(?:\.\.\/)*/.exec(sPath.slice(nEnd))[0].length;
      sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\/+[^\\\/]*){0,' + (nUpLn - 1) / 3 + '}$'), '/');
    }
    return sDir + sPath.substr(nStart);
  }
};

module.exports = URLHelper;

},{}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr,
          context = this.context;

      if (typeof XDomainRequest !== 'undefined') {
        xhr = this.loader = new XDomainRequest();
      } else {
        xhr = this.loader = new XMLHttpRequest();
      }

      xhr.onloadend = this.loadend.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);

      xhr.open('GET', context.url, true);

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.responseType = context.responseType;
      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      if (this.xhrSetup) {
        this.xhrSetup(xhr, context.url);
      }
      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'loadend',
    value: function loadend(event) {
      var xhr = event.currentTarget,
          status = xhr.status,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // in any case clear the current xhrs timeout
      window.clearTimeout(this.requestTimeout);

      // http status between 200 to 299 are all successful
      if (status >= 200 && status < 300) {
        stats.tload = Math.max(stats.tfirst, performance.now());
        var data = void 0,
            len = void 0;
        if (context.responseType === 'arraybuffer') {
          data = xhr.response;
          len = data.byteLength;
        } else {
          data = xhr.responseText;
          len = data.length;
        }
        stats.loaded = stats.total = len;
        var response = { url: xhr.responseURL, data: data };
        this.callbacks.onSuccess(response, stats, context);
      } else {
        // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
        if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
          _logger.logger.error(status + ' while loading ' + context.url);
          this.callbacks.onError({ code: status, text: xhr.statusText }, context);
        } else {
          // retry
          _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
          // aborts and resets internal state
          this.destroy();
          // schedule retry
          this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
          // set exponential backoff
          this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
          stats.retry++;
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var stats = this.stats;
      if (stats.tfirst === 0) {
        stats.tfirst = Math.max(performance.now(), stats.trequest);
      }
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // last args is to provide on progress data
        onProgress(stats, this.context, null);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;

},{"../utils/logger":46}]},{},[34])(34)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5L2luZGV4LmpzIiwic3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLmpzIiwic3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLmpzIiwic3JjL2NyeXB0L2Flcy5qcyIsInNyYy9jcnlwdC9hZXMxMjgtZGVjcnlwdGVyLmpzIiwic3JjL2NyeXB0L2RlY3J5cHRlci5qcyIsInNyYy9kZW11eC9hYWNkZW11eGVyLmpzIiwic3JjL2RlbXV4L2FkdHMuanMiLCJzcmMvZGVtdXgvZGVtdXhlci1pbmxpbmUuanMiLCJzcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMiLCJzcmMvZGVtdXgvZGVtdXhlci5qcyIsInNyYy9kZW11eC9leHAtZ29sb21iLmpzIiwic3JjL2RlbXV4L2Zsdi9mbHYtcGFyc2VyLmpzIiwic3JjL2RlbXV4L2Zsdi9mbHYtdGFnLmpzIiwic3JjL2RlbXV4L2ZsdmRlbXV4ZXIuanMiLCJzcmMvZGVtdXgvaWQzLmpzIiwic3JjL2RlbXV4L3RzZGVtdXhlci5qcyIsInNyYy9lcnJvcnMuanMiLCJzcmMvZXZlbnQtaGFuZGxlci5qcyIsInNyYy9ldmVudHMuanMiLCJzcmMvaGVscGVyL2FhYy5qcyIsInNyYy9oZWxwZXIvYnVmZmVyLWhlbHBlci5qcyIsInNyYy9oZWxwZXIvbGV2ZWwtaGVscGVyLmpzIiwic3JjL2hscy5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLmpzIiwic3JjL2xvYWRlci9rZXktbG9hZGVyLmpzIiwic3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanMiLCJzcmMvcmVtdXgvbXA0LWdlbmVyYXRvci5qcyIsInNyYy9yZW11eC9tcDQtcmVtdXhlci5qcyIsInNyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLmpzIiwic3JjL3V0aWxzL2F0dHItbGlzdC5qcyIsInNyYy91dGlscy9iaW5hcnktc2VhcmNoLmpzIiwic3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzIiwic3JjL3V0aWxzL2N1ZXMuanMiLCJzcmMvdXRpbHMvZXdtYS5qcyIsInNyYy91dGlscy9sb2dnZXIuanMiLCJzcmMvdXRpbHMvcG9seWZpbGwuanMiLCJzcmMvdXRpbHMvdGltZVJhbmdlcy5qcyIsInNyYy91dGlscy91cmwuanMiLCJzcmMvdXRpbHMveGhyLWxvYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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SUFBUCw0QkFBcUMsS0FBSyxPQUFMLENBQWEsR0FBbEQ7QUFDQSxXQUFLLFNBQUwsQ0FBZSxTQUFmLENBQXlCLEtBQUssS0FBOUIsRUFBcUMsS0FBSyxPQUExQztBQUNEOzs7aUNBRVksSyxFQUFPO0FBQ2xCLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsVUFBSSxNQUFNLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEIsY0FBTSxNQUFOLEdBQWUsS0FBSyxHQUFMLENBQVMsWUFBWSxHQUFaLEVBQVQsRUFBNEIsTUFBTSxRQUFsQyxDQUFmO0FBQ0Q7QUFDRCxZQUFNLE1BQU4sR0FBZSxNQUFNLE1BQXJCO0FBQ0EsVUFBSSxNQUFNLGdCQUFWLEVBQTRCO0FBQzFCLGNBQU0sS0FBTixHQUFjLE1BQU0sS0FBcEI7QUFDRDtBQUNELFVBQUksYUFBYSxLQUFLLFNBQUwsQ0FBZSxVQUFoQztBQUNBLFVBQUksVUFBSixFQUFnQjtBQUNkO0FBQ0EsbUJBQVcsS0FBWCxFQUFrQixLQUFLLE9BQXZCLEVBQWdDLElBQWhDO0FBQ0Q7QUFDRjs7Ozs7O2tCQUdZLFMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwidmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIHZhciBleHAgPSBjYWNoZVtrZXldLmV4cG9ydHM7XG4gICAgICAgIC8vIFVzaW5nIGJhYmVsIGFzIGEgdHJhbnNwaWxlciB0byB1c2UgZXNtb2R1bGUsIHRoZSBleHBvcnQgd2lsbCBhbHdheXNcbiAgICAgICAgLy8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgZXhwb3J0IGFzIGEgcHJvcGVydHkgb2YgaXQuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgZXhpc3RpbmcgYXBpIGFuZCBiYWJlbCBlc21vZHVsZSBleHBvcnRzIGFyZSBib3RoIHN1cHBvcnRlZCB3ZVxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aFxuICAgICAgICBpZiAoZXhwID09PSBmbiB8fCBleHAgJiYgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnLCdtb2R1bGUnLCdleHBvcnRzJ10sICcoJyArIGZuICsgJykoc2VsZiknKSxcbiAgICAgICAgICAgIHdjYWNoZVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgc2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZSddLCAoXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlXG4gICAgICAgICAgICAvLyBleHBvcnRzXG4gICAgICAgICAgICAndmFyIGYgPSByZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKTsnICtcbiAgICAgICAgICAgICcoZi5kZWZhdWx0ID8gZi5kZWZhdWx0IDogZikoc2VsZik7J1xuICAgICAgICApKSxcbiAgICAgICAgc2NhY2hlXG4gICAgXTtcblxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMoc291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgO1xuXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iOyB9XG4gICAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsKTtcbiAgICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsO1xuICAgIHJldHVybiB3b3JrZXI7XG59O1xuIiwiLypcbiAqIHNpbXBsZSBBQlIgQ29udHJvbGxlclxuICogIC0gY29tcHV0ZSBuZXh0IGxldmVsIGJhc2VkIG9uIGxhc3QgZnJhZ21lbnQgYncgaGV1cmlzdGljc1xuICogIC0gaW1wbGVtZW50IGFuIGFiYW5kb24gcnVsZXMgdHJpZ2dlcmVkIGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBhbmQgaWYgY29tcHV0ZWQgYncgc2hvd3MgdGhhdCB3ZSByaXNrIGJ1ZmZlciBzdGFsbGluZ1xuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBCdWZmZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHtFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIGZyb20gJy4vZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yJztcblxuY2xhc3MgQWJyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5GUkFHX0xPQURJTkcsXG4gICAgICAgICAgICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgICAgICAgICAgIEV2ZW50LkVSUk9SKTtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5vbkNoZWNrID0gdGhpcy5hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uRnJhZ0xvYWRpbmcoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XG4gICAgICB9XG4gICAgICAvLyBsYXp5IGluaXQgb2YgYncgRXN0aW1hdG9yLCByYXRpb25hbGUgaXMgdGhhdCB3ZSB1c2UgZGlmZmVyZW50IHBhcmFtcyBmb3IgTGl2ZS9Wb0RcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgIGlmICghdGhpcy5id0VzdGltYXRvcikge1xuICAgICAgICBsZXQgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgICBsZXZlbCA9IGRhdGEuZnJhZy5sZXZlbCxcbiAgICAgICAgICAgIGlzTGl2ZSA9IGhscy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMubGl2ZSxcbiAgICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgICAgICBld21hRmFzdCwgZXdtYVNsb3c7XG5cbiAgICAgICAgaWYgKGlzTGl2ZSkge1xuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0TGl2ZTtcbiAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd0xpdmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXdtYUZhc3QgPSBjb25maWcuYWJyRXdtYUZhc3RWb0Q7XG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dWb0Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5id0VzdGltYXRvciA9IG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKGhscyxld21hU2xvdyxld21hRmFzdCxjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICB9XG4gIH1cblxuICBhYmFuZG9uUnVsZXNDaGVjaygpIHtcbiAgICAvKlxuICAgICAgbW9uaXRvciBmcmFnbWVudCByZXRyaWV2YWwgdGltZS4uLlxuICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxuICAgICAgd2UgY29tcGFyZSBpdCB0byBleHBlY3RlZCB0aW1lIG9mIGJ1ZmZlciBzdGFydmF0aW9uXG4gICAgKi9cbiAgICBsZXQgaGxzID0gdGhpcy5obHMsIHYgPSBobHMubWVkaWEsZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuXG4gICAgLy8gaWYgbG9hZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCBvciBsb2FkaW5nIGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgIGlmKCFsb2FkZXIgfHwgKCBsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XG4gICAgICBsb2dnZXIud2FybihgZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzQ2hlY2tgKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgLyogb25seSBtb25pdG9yIGZyYWcgcmV0cmlldmFsIHRpbWUgaWZcbiAgICAodmlkZW8gbm90IHBhdXNlZCBPUiBmaXJzdCBmcmFnbWVudCBiZWluZyBsb2FkZWQocmVhZHkgc3RhdGUgPT09IEhBVkVfTk9USElORyA9IDApKSBBTkQgYXV0b3N3aXRjaGluZyBlbmFibGVkIEFORCBub3QgbG93ZXN0IGxldmVsICg9PiBtZWFucyB0aGF0IHdlIGhhdmUgc2V2ZXJhbCBsZXZlbHMpICovXG4gICAgaWYgKHYgJiYgKCghdi5wYXVzZWQgJiYgKHYucGxheWJhY2tSYXRlICE9PSAwKSkgfHwgIXYucmVhZHlTdGF0ZSkgJiYgZnJhZy5hdXRvTGV2ZWwgJiYgZnJhZy5sZXZlbCkge1xuICAgICAgbGV0IHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMudHJlcXVlc3QsXG4gICAgICAgICAgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpO1xuICAgICAgLy8gbW9uaXRvciBmcmFnbWVudCBsb2FkIHByb2dyZXNzIGFmdGVyIGhhbGYgb2YgZXhwZWN0ZWQgZnJhZ21lbnQgZHVyYXRpb24sdG8gc3RhYmlsaXplIGJpdHJhdGVcbiAgICAgIGlmIChyZXF1ZXN0RGVsYXkgPiAoNTAwICogZnJhZy5kdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkpIHtcbiAgICAgICAgbGV0IGxldmVscyA9IGhscy5sZXZlbHMsXG4gICAgICAgICAgICBsb2FkUmF0ZSA9IE1hdGgubWF4KDEsIHN0YXRzLmJ3ID8gc3RhdHMuYncgLyA4IDogc3RhdHMubG9hZGVkICogMTAwMCAvIHJlcXVlc3REZWxheSksIC8vIGJ5dGUvczsgYXQgbGVhc3QgMSBieXRlL3MgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVyb1xuICAgICAgICAgICAgLy8gY29tcHV0ZSBleHBlY3RlZCBmcmFnbWVudCBsZW5ndGggdXNpbmcgZnJhZyBkdXJhdGlvbiBhbmQgbGV2ZWwgYml0cmF0ZS4gYWxzbyBlbnN1cmUgdGhhdCBleHBlY3RlZCBsZW4gaXMgZ3RlIHRoYW4gYWxyZWFkeSBsb2FkZWQgc2l6ZVxuICAgICAgICAgICAgZXhwZWN0ZWRMZW4gPSBzdGF0cy50b3RhbCA/IHN0YXRzLnRvdGFsIDogTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gKiBsZXZlbHNbZnJhZy5sZXZlbF0uYml0cmF0ZSAvIDgpKSxcbiAgICAgICAgICAgIHBvcyA9IHYuY3VycmVudFRpbWUsXG4gICAgICAgICAgICBmcmFnTG9hZGVkRGVsYXkgPSAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGUsXG4gICAgICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odixwb3MsaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xuICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXG4gICAgICAgIC8vIHRpbWUgdG8gZmluaXNoIGxvYWRpbmcgY3VycmVudCBmcmFnbWVudCBpcyBiaWdnZXIgdGhhbiBidWZmZXIgc3RhcnZhdGlvbiBkZWxheVxuICAgICAgICAvLyBpZSBpZiB3ZSByaXNrIGJ1ZmZlciBzdGFydmF0aW9uIGlmIGJ3IGRvZXMgbm90IGluY3JlYXNlIHF1aWNrbHlcbiAgICAgICAgaWYgKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPCAoMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSAmJiAoZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSkge1xuICAgICAgICAgIGxldCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXksIG5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXG4gICAgICAgICAgLy8gd2Ugc3RhcnQgZnJvbSBjdXJyZW50IGxldmVsIC0gMSBhbmQgd2Ugc3RlcCBkb3duICwgdW50aWwgd2UgZmluZCBhIG1hdGNoaW5nIGxldmVsXG4gICAgICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDEgOyBuZXh0TG9hZExldmVsID49MCA7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxuICAgICAgICAgICAgLy8gMC44IDogY29uc2lkZXIgb25seSA4MCUgb2YgY3VycmVudCBidyB0byBiZSBjb25zZXJ2YXRpdmVcbiAgICAgICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxuICAgICAgICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gZnJhZy5kdXJhdGlvbiAqIGxldmVsc1tuZXh0TG9hZExldmVsXS5iaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBmcmFnTG9hZGVkRGVsYXkvYnVmZmVyU3RhcnZhdGlvbkRlbGF5L2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheVske25leHRMb2FkTGV2ZWx9XSA6JHtmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgxKX0vJHtidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgxKX0vJHtmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgxKX1gKTtcbiAgICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYSBsb3dlciBsZXZlbCB0aGF0IGJlIHJlYnVmZmVyaW5nIGZyZWUgd2l0aCBjdXJyZW50IGVzdGltYXRlZCBidyAhXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBmaW5pc2hpbmcgbG9hZGluZyBjdXJyZW50IG9uZSAuLi5cbiAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgbmV4dExvYWRMZXZlbCBpcyBub3QgbmVnYXRpdmVcbiAgICAgICAgICAgIG5leHRMb2FkTGV2ZWwgPSBNYXRoLm1heCgwLG5leHRMb2FkTGV2ZWwpO1xuICAgICAgICAgICAgLy8gZm9yY2UgbmV4dCBsb2FkIGxldmVsIGluIGF1dG8gbW9kZVxuICAgICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcbiAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSxzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgLy8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZyAuLi5cbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsb2FkaW5nIHRvbyBzbG93LCBhYm9ydCBmcmFnbWVudCBsb2FkaW5nIGFuZCBzd2l0Y2ggdG8gbGV2ZWwgJHtuZXh0TG9hZExldmVsfWApO1xuICAgICAgICAgICAgLy9hYm9ydCBmcmFnbWVudCBsb2FkaW5nXG4gICAgICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGxldCBzdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICAvLyBvbmx5IHVwZGF0ZSBzdGF0cyBvbiBmaXJzdCBmcmFnIGxvYWRpbmdcbiAgICAgIC8vIGlmIHNhbWUgZnJhZyBpcyBsb2FkZWQgbXVsdGlwbGUgdGltZXMsIGl0IG1pZ2h0IGJlIGluIGJyb3dzZXIgY2FjaGUsIGFuZCBsb2FkZWQgcXVpY2tseVxuICAgICAgLy8gYW5kIGxlYWRpbmcgdG8gd3JvbmcgYncgZXN0aW1hdGlvblxuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQgPT09IHVuZGVmaW5lZCAmJiBmcmFnLmxvYWRDb3VudGVyID09PSAxKSB7XG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMudHJlcXVlc3Qsc3RhdHMubG9hZGVkKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICAvLyBzdG9wIHRpbWVyIGluIGNhc2Ugb2YgZnJhZyBsb2FkaW5nIGVycm9yXG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gY2xlYXJUaW1lcigpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiB9XG5cbiAgLyoqIFJldHVybiB0aGUgY2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBjb3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtICoqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBsZXQgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgIGxldmVscyA9IGhscy5sZXZlbHMsXG4gICAgICAgIHYgPSBobHMubWVkaWEsXG4gICAgICAgIGksIG1heEF1dG9MZXZlbDtcbiAgICBpZiAodGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICYmIGxldmVscy5sZW5ndGgpIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICAgIH1cblxuICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgcmV0dXJuIGl0IHN0cmFpZ2h0LWF3YXkgKGJ1dCBjYXBwZWQpXG4gICAgaWYgKHRoaXMuX25leHRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5fbmV4dEF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwpO1xuICAgIH1cbiAgICBsZXQgcGxheWJhY2tSYXRlID0gKCh2ICYmIHYucGxheWJhY2tSYXRlICE9PSAwKSA/IE1hdGguYWJzKHYucGxheWJhY2tSYXRlKSA6IDEuMCksXG4gICAgICAgIGF2Z2J3ID0gdGhpcy5id0VzdGltYXRvciA/IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKS9wbGF5YmFja1JhdGUgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZS9wbGF5YmFja1JhdGUsXG4gICAgICAgIGFkanVzdGVkYnc7XG4gICAgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgIC8vIFBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHN0cmVhbSBiZWxvdyBvciBlcXVhbCB0byBlc3RpbWF0ZWQgYmFuZHdpZHRoLlxuICAgIGZvciAoaSA9IDA7IGkgPD0gbWF4QXV0b0xldmVsOyBpKyspIHtcbiAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcbiAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgIGlmIChpIDw9IHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCkge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciAqIGF2Z2J3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvciAqIGF2Z2J3O1xuICAgICAgfVxuICAgICAgaWYgKGFkanVzdGVkYncgPCBsZXZlbHNbaV0uYml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgaSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaSAtIDE7XG4gIH1cblxuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFickNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBBdWRpbyBTdHJlYW0gQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcbmltcG9ydCBCdWZmZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgTGV2ZWxIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lUmFuZ2VzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEIDogJ1NUT1BQRUQnLFxuICBTVEFSVElORyA6ICdTVEFSVElORycsXG4gIElETEUgOiAnSURMRScsXG4gIFBBVVNFRCA6ICdQQVVTRUQnLFxuICBLRVlfTE9BRElORyA6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORyA6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSA6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0sgOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkcgOiAnUEFSU0lORycsXG4gIFBBUlNFRCA6ICdQQVJTRUQnLFxuICBFTkRFRCA6ICdFTkRFRCcsXG4gIEVSUk9SIDogJ0VSUk9SJ1xufTtcblxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLU19VUERBVEVELFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENILFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELFxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLFxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXG4gICAgICBFdmVudC5FUlJPUixcbiAgICAgIEV2ZW50LkJVRkZFUl9DUkVBVEVELFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB0aGlzLm9udGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLnRyYWNrcykge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSwgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGlmIChtZWRpYSAmJiBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gQCR7bGFzdEN1cnJlbnRUaW1lfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUQVJUSU5HO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZykge1xuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgdGhpcy50aWNrcysrO1xuICAgIGlmICh0aGlzLnRpY2tzID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgaWYgKHRoaXMudGlja3MgPiAxKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy50aWNrLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGlja3MgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGRvVGljaygpIHtcbiAgICB2YXIgcG9zLCB0cmFjaywgdHJhY2tEZXRhaWxzLCBobHMgPSB0aGlzLmhscywgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAvL2xvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtOicgKyB0aGlzLnN0YXRlKTtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5FUlJPUjpcbiAgICAgICAgLy9kb24ndCBkbyBhbnl0aGluZyBpbiBlcnJvciBzdGF0ZSB0byBhdm9pZCBicmVha2luZyBmdXJ0aGVyIC4uLlxuICAgICAgY2FzZSBTdGF0ZS5QQVVTRUQ6XG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gcGF1c2VkIHN0YXRlIGVpdGhlciAuLi5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLlNUQVJUSU5HOlxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgICAgLy8gZXhpdCBsb29wXG4gICAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXG4gICAgICAgICAgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcbiAgICAgICAgLy8gIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgIHBvcyA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSxwb3MsY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcbiAgICAgICAgICAgIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxuICAgICAgICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aDtcblxuICAgICAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcbiAgICAgICAgaWYgKGJ1ZmZlckxlbiA8IG1heEJ1ZkxlbiAmJiB0aGlzLnRyYWNrSWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFja0RldGFpbHMgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLmRldGFpbHM7XG4gICAgICAgICAgLy8gaWYgdHJhY2sgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciB0cmFjayByZXRyaWV2YWxcbiAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZmluYWxpemUgbWVkaWEgc3RyZWFtXG4gICAgICAgIGlmICghdHJhY2tEZXRhaWxzLmxpdmUgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zbiA9PT0gdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHNlZWtpbmcgb3IgaWYgd2UgYXJlIHNlZWtpbmcgYnV0IGV2ZXJ5dGhpbmcgKGFsbW9zdCkgdGlsIHRoZSBlbmQgaXMgYnVmZmVyZWQsIGxldCdzIHNpZ25hbCBlb3NcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSB3aGVuIHN3aXRjaGluZ1xuICAgICAgICAgICAgLy8gYmV0d2VlbiBkaWZmZXJlbnQgcmVuZGl0aW9ucy4gdXNpbmcgaGFsZiBmcmFnIGR1cmF0aW9uIHNob3VsZCBoZWxwIGNvcGUgd2l0aCB0aGVzZSBjYXNlcy5cbiAgICAgICAgICAgIGlmICghdGhpcy5tZWRpYS5zZWVraW5nIHx8ICh0aGlzLm1lZGlhLmR1cmF0aW9uLWJ1ZmZlckVuZCkgPCBmcmFnUHJldmlvdXMuZHVyYXRpb24vMikge1xuICAgICAgICAgICAgLy8gRmluYWxpemUgdGhlIG1lZGlhIHN0cmVhbVxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLHsgdHlwZSA6ICdhdWRpbyd9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgICBsZXQgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuLTFdLmR1cmF0aW9uLFxuICAgICAgICAgICAgICBmcmFnO1xuXG4gICAgICAgICAgLy8gaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZztcbiAgICAgICAgICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgICAgICAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgICAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgICAgICAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAgICAgICAgICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgICAgICAgICAgICBpZiAoKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPiBidWZmZXJFbmQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuLTFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZykge1xuICAgICAgICAgICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcbiAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICAgICAgICAgIGlmIChmcmFnLnNuIDwgdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWcuc24gKyAxIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGZyYWcpIHtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnICAgICAgbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgaWYgKChmcmFnLmRlY3J5cHRkYXRhLnVyaSAhPSBudWxsKSAmJiAoZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7dHJhY2tEZXRhaWxzLnN0YXJ0U059ICwke3RyYWNrRGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dGhpcy50cmFja0lkfWApO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RoaXMudHJhY2tJZH0sIGN1cnJlbnRUaW1lOiR7cG9zfSxidWZmZXJFbmQ6JHtidWZmZXJFbmQudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgbGV0IG1heFRocmVzaG9sZCA9IGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIDMgdGltZXMsIGFuZCBpZiBpdCBoYXMgYmVlbiByZWxvYWRlZCByZWNlbnRseVxuICAgICAgICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyID4gbWF4VGhyZXNob2xkICYmIChNYXRoLmFicyh0aGlzLmZyYWdMb2FkSWR4IC0gZnJhZy5sb2FkSWR4KSA8IG1heFRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWd9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJhZy5sb2FkSWR4ID0gdGhpcy5mcmFnTG9hZElkeDtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2suZGV0YWlscykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGlzU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XG4gICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgIGlmKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8IGlzU2Vla2luZykge1xuICAgICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGVgKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZChkYXRhKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZih0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIGxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZGluZyBjb3VudGVyIG9uIE1TRSBkZXRhY2hpbmcgdG8gYXZvaWQgcmVwb3J0aW5nIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SIGFmdGVyIGVycm9yIHJlY292ZXJ5XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgIGlmICh0cmFja3MpIHtcbiAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWQgY291bnRlclxuICAgICAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgaWYodHJhY2suZGV0YWlscykge1xuICAgICAgICAgICAgdHJhY2suZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmxvYWRDb3VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkICA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG5cbiAgb25NZWRpYVNlZWtpbmcoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICAvLyBhdm9pZCByZXBvcnRpbmcgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIGluIGNhc2UgdXNlciBpcyBzZWVraW5nIHNldmVyYWwgdGltZXMgb24gc2FtZSBwb3NpdGlvblxuICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICB9XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cblxuICBvbkF1ZGlvVHJhY2tzVXBkYXRlZChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2goZGF0YSkge1xuICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyBkZW11eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICBpZiAoZGF0YS50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmbHVzaCBhdWRpbyBzb3VyY2UgYnVmZmVyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGUgOiAnYXVkaW8nfSk7XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZGF0YSkge1xuICAgIHZhciBkZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgICB0cmFja0lkID0gZGF0YS5pZCxcbiAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSxcbiAgICAgICAgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG5cbiAgICBsb2dnZXIubG9nKGB0cmFjayAke3RyYWNrSWR9IGxvYWRlZCBbJHtkZXRhaWxzLnN0YXJ0U059LCR7ZGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XG4gICAgZGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIHRyYWNrLmRldGFpbHMgPSBkZXRhaWxzO1xuXG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvblxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gZmlyc3QsIGNoZWNrIGlmIHN0YXJ0IHRpbWUgb2Zmc2V0IGhhcyBiZWVuIHNldCBpbiBwbGF5bGlzdCwgaWYgeWVzLCB1c2UgdGhpcyB2YWx1ZVxuICAgICAgICBsZXQgc3RhcnRUaW1lT2Zmc2V0ID0gZGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIGlmKCFpc05hTihzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbktleUxvYWRlZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcbiAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5mcmFnLnR5cGUgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS5mcmFnLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICBkYXRhLmZyYWcuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgIHRoaXMuc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLFxuICAgICAgICAgICAgZGV0YWlscyA9IHRyYWNrLmRldGFpbHMsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ0N1cnJlbnQuc3RhcnQsXG4gICAgICAgICAgICB0cmFja0lkID0gZnJhZ0N1cnJlbnQubGV2ZWwsXG4gICAgICAgICAgICBzbiA9IGZyYWdDdXJyZW50LnNuLFxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IHRyYWNrLmF1ZGlvQ29kZWM7XG4gICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZyA9IDA7XG4gICAgICAgIGlmKCF0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywnYXVkaW8nKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKGBEZW11eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgIHRoaXMuZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgYXVkaW9Db2RlYywgbnVsbCwgc3RhcnQsIGZyYWdDdXJyZW50LmNjLCB0cmFja0lkLCBzbiwgZHVyYXRpb24sIGZyYWdDdXJyZW50LmRlY3J5cHRkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudChkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrO1xuXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZih0cmFjaykge1xuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLHRyYWNrcyk7XG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHRyYWNrOmF1ZGlvLGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XG4gICAgICAgIGxldCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmcrKztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHt0eXBlOiAnYXVkaW8nLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50IDogJ2F1ZGlvJyxjb250ZW50IDogJ2luaXRTZWdtZW50J30pO1xuICAgICAgICB9XG4gICAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YShkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLFxuICAgICAgICAgIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuXG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn1gKTtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFModHJhY2suZGV0YWlscyxmcmFnLnNuLGRhdGEuc3RhcnRQVFMsZGF0YS5lbmRQVFMpO1xuXG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQXBwZW5kaW5nKys7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudCA6ICdhdWRpbycsY29udGVudCA6ICdkYXRhJ30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuZW5kUFRTO1xuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG5cbiAgb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcbiAgICBsZXQgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXI7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZy0tO1xuICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCgpIHtcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmIHRoaXMucGVuZGluZ0FwcGVuZGluZyA9PT0gMCkgIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZCA6ICdhdWRpbyd9KTtcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyBidWZmZXJlZCA6ICR7VGltZVJhbmdlcy50b1N0cmluZyhtZWRpYS5idWZmZXJlZCl9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgICAvLyByZXNldCBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gNjRzXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLGxvYWRFcnJvci0xKSp0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksNjQwMDApO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5gKTtcbiAgICAgICAgICAgIC8vIHJlZGlzcGF0Y2ggc2FtZSBlcnJvciBidXQgd2l0aCBmYXRhbCBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vICB3aGVuIGluIEVSUk9SIHN0YXRlLCBkb24ndCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGluIGNhc2UgYSBub24tZmF0YWwgZXJyb3IgaXMgcmVjZWl2ZWRcbiAgICAgICAgaWYodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmcsIG90aGVyd2lzZSBtb3ZlIHRvIElETEUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBTdGF0ZS5FUlJPUiA6IFN0YXRlLklETEU7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgYXVkaW9TdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gd2hpbGUgbG9hZGluZyBmcmFnLHN3aXRjaCB0byAke3RoaXMuc3RhdGV9IHN0YXRlIC4uLmApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJGbHVzaGVkKCkge1xuICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIGF1ZGlvIHRyYWNrIGNvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBBdWRpb1RyYWNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgICAgICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVEKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAvLyByZXNldCBhdWRpbyB0cmFja3Mgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcbiAgICBsZXQgdHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgICBsZXQgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG4gICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCwge2F1ZGlvVHJhY2tzIDogdHJhY2tzfSk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBhdWRpbyB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcbiAgICBsZXQgaWQgPSAwO1xuICAgIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGlmKHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrID0gaWQ7XG4gICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlkKys7XG4gICAgfSk7XG4gICAgaWYgKGRlZmF1bHRGb3VuZCA9PT0gZmFsc2UgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZygnbm8gZGVmYXVsdCBhdWRpbyB0cmFjayBkZWZpbmVkLCB1c2UgZmlyc3QgYXVkaW8gdHJhY2sgYXMgZGVmYXVsdCcpO1xuICAgICAgdGhpcy5hdWRpb1RyYWNrID0gMDtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZGF0YSkge1xuICAgIGlmIChkYXRhLmlkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKGBhdWRpb1RyYWNrICR7ZGF0YS5pZH0gbG9hZGVkYCk7XG4gICAgICB0aGlzLnRyYWNrc1tkYXRhLmlkXS5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcbiAgICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSAmJiAhdGhpcy50aW1lcikge1xuICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0IHdlIHdpbGwgaGF2ZSB0byByZWxvYWQgaXQgcGVyaW9kaWNhbGx5XG4gICAgICAgIC8vIHNldCByZWxvYWQgcGVyaW9kIHRvIHBsYXlsaXN0IHRhcmdldCBkdXJhdGlvblxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMDAgKiBkYXRhLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhLmRldGFpbHMubGl2ZSAmJiB0aGlzLnRpbWVyKSB7XG4gICAgICAgIC8vIHBsYXlsaXN0IGlzIG5vdCBsaXZlIGFuZCB0aW1lciBpcyBhcm1lZCA6IHN0b3BwaW5nIGl0XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gIH1cblxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cblxuICAvKiogc2VsZWN0IGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMqKi9cbiAgc2V0IGF1ZGlvVHJhY2soYXVkaW9UcmFja0lkKSB7XG4gICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gYXVkaW9UcmFja0lkIHx8IHRoaXMudHJhY2tzW2F1ZGlvVHJhY2tJZF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldEF1ZGlvVHJhY2tJbnRlcm5hbChhdWRpb1RyYWNrSWQpO1xuICAgIH1cbiAgfVxuXG4gc2V0QXVkaW9UcmFja0ludGVybmFsKG5ld0lkKSB7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgdG8gYXVkaW9UcmFjayAke25ld0lkfWApO1xuICAgICAgbGV0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF0sIHR5cGUgPSBhdWRpb1RyYWNrLnR5cGU7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSCwge2lkOiBuZXdJZCwgdHlwZSA6IHR5cGV9KTtcbiAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgYXVkaW8gVHJhY2tcbiAgICAgICBsZXQgZGV0YWlscyA9IGF1ZGlvVHJhY2suZGV0YWlscztcbiAgICAgIGlmICh0eXBlICE9PSAnbWFpbicgJiYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpKSB7XG4gICAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgbG9nZ2VyLmxvZyhgKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7dXJsOiBhdWRpb1RyYWNrLnVybCwgaWQ6IG5ld0lkfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuIiwiLypcbiAqIEJ1ZmZlciBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5cbmNsYXNzIEJ1ZmZlckNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9SRVNFVCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsXG4gICAgICBFdmVudC5CVUZGRVJfQ09ERUNTLFxuICAgICAgRXZlbnQuQlVGRkVSX0VPUyxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSElORyxcbiAgICAgIEV2ZW50LkxFVkVMX1VQREFURUQpO1xuXG4gICAgLy8gdGhlIHZhbHVlIHRoYXQgd2UgaGF2ZSBzZXQgbWVkaWFzb3VyY2UuZHVyYXRpb24gdG9cbiAgICAvLyAodGhlIGFjdHVhbCBkdXJhdGlvbiBtYXkgYmUgdHdlYWtlZCBzbGlnaGx5IGJ5IHRoZSBicm93c2VyKVxuICAgIHRoaXMuX21zRHVyYXRpb24gPSBudWxsO1xuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIHdhbnQgdG8gc2V0IG1lZGlhU291cmNlLmR1cmF0aW9uIHRvXG4gICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IG51bGw7XG5cbiAgICAvLyBTb3VyY2UgQnVmZmVyIGxpc3RlbmVyc1xuICAgIHRoaXMub25zYnVlID0gdGhpcy5vblNCVXBkYXRlRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnNiZSAgPSB0aGlzLm9uU0JVcGRhdGVFcnJvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQoZGF0YSkge1xuICAgIGxldCBhdWRpb0V4cGVjdGVkID0gZGF0YS5hdWRpbyxcbiAgICAgICAgdmlkZW9FeHBlY3RlZCA9IGRhdGEudmlkZW8sXG4gICAgICAgIHNvdXJjZUJ1ZmZlck5iID0gMDtcbiAgICBpZiAoYXVkaW9FeHBlY3RlZCB8fCB2aWRlb0V4cGVjdGVkKSB7XG4gICAgICBzb3VyY2VCdWZmZXJOYiA9IChhdWRpb0V4cGVjdGVkID8gMSA6IDApICsgKHZpZGVvRXhwZWN0ZWQgPyAxIDogMCk7XG4gICAgICBsb2dnZXIubG9nKGAke3NvdXJjZUJ1ZmZlck5ifSBzb3VyY2VCdWZmZXIocykgZXhwZWN0ZWRgKTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9IHNvdXJjZUJ1ZmZlck5iO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXG4gICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAvL01lZGlhIFNvdXJjZSBsaXN0ZW5lcnNcbiAgICAgIHRoaXMub25tc28gPSB0aGlzLm9uTWVkaWFTb3VyY2VPcGVuLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9ubXNlID0gdGhpcy5vbk1lZGlhU291cmNlRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub25tc2MgPSB0aGlzLm9uTWVkaWFTb3VyY2VDbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG4gICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgIG1lZGlhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKG1zKSB7XG4gICAgICBpZiAobXMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgbXMuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2Fybihgb25NZWRpYURldGFjaGluZzoke2Vyci5tZXNzYWdlfSB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIHRoaXMubWVkaWEubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm9ubXNvID0gdGhpcy5vbm1zZSA9IHRoaXMub25tc2MgPSBudWxsO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfREVUQUNIRUQpO1xuICB9XG5cbiAgb25NZWRpYVNvdXJjZU9wZW4oKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNIRUQsIHsgbWVkaWEgOiB0aGlzLm1lZGlhIH0pO1xuICAgIGxldCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gIH1cblxuICBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgLy8gaWYgYW55IGJ1ZmZlciBjb2RlY3MgcGVuZGluZywgY2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggdG8gY3JlYXRlIHNvdXJjZUJ1ZmZlcnNcbiAgICBsZXQgcGVuZGluZ1RyYWNrcyA9IHRoaXMucGVuZGluZ1RyYWNrcyxcbiAgICAgICAgcGVuZGluZ1RyYWNrc05iID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgIC8vIGlmIGFueSBwZW5kaW5nIHRyYWNrcyBhbmQgKGlmIG5iIG9mIHBlbmRpbmcgdHJhY2tzIG1hdGNoaW5nIGV4cGVjdGVkIG5iIG9yIGlmIHVua25vb3duIGV4cGVjdGVkIG5iKVxuICAgIGlmIChwZW5kaW5nVHJhY2tzTmIgJiYgKFxuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlck5iID09PSBwZW5kaW5nVHJhY2tzTmIgfHxcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9PT0gMCkpIHtcbiAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhU291cmNlQ2xvc2UoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICB9XG5cbiAgb25NZWRpYVNvdXJjZUVuZGVkKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICB9XG5cblxuICBvblNCVXBkYXRlRW5kKCkge1xuXG4gICAgaWYgKHRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgIHRoaXMuZG9GbHVzaCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc0Vvcykge1xuICAgICAgdGhpcy5jaGVja0VvcygpO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVOREVELCB7IHBhcmVudCA6IHRoaXMucGFyZW50fSk7XG5cbiAgICAvLyBkb24ndCBhcHBlbmQgaW4gZmx1c2hpbmcgbW9kZVxuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgfVxuXG4gIG9uU0JVcGRhdGVFcnJvcihldmVudCkge1xuICAgIGxvZ2dlci5lcnJvcihgc291cmNlQnVmZmVyIGVycm9yOiR7ZXZlbnR9YCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2V9KTtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGRvIG1vcmUgdGhhbiB0aGF0LCBhcyBhY2NvcmRpbiB0byB0aGUgc3BlYywgdXBkYXRlZW5kIHdpbGwgYmUgZmlyZWQganVzdCBhZnRlclxuICB9XG5cbiAgb25CdWZmZXJSZXNldCgpIHtcbiAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgZm9yKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICB0aGlzLmFwcGVuZGVkID0gMDtcbiAgfVxuXG4gIG9uQnVmZmVyQ29kZWNzKHRyYWNrcykge1xuICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcikubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKHZhciB0cmFja05hbWUgaW4gdHJhY2tzKSB7IHRoaXMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gdHJhY2tzW3RyYWNrTmFtZV07IH1cbiAgICAgIGxldCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICBpZiAobWVkaWFTb3VyY2UgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIC8vIHRyeSB0byBjcmVhdGUgc291cmNlYnVmZmVycyBpZiBtZWRpYXNvdXJjZSBvcGVuZWRcbiAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzKSB7XG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcblxuICAgIGZvciAobGV0IHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xuICAgICAgICBsZXQgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgLy8gdXNlIGxldmVsQ29kZWMgYXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgbGV0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcbiAgICAgICAgbGV0IG1pbWVUeXBlID0gYCR7dHJhY2suY29udGFpbmVyfTtjb2RlY3M9JHtjb2RlY31gO1xuICAgICAgICBsb2dnZXIubG9nKGBjcmVhdGluZyBzb3VyY2VCdWZmZXIgd2l0aCBtaW1lVHlwZToke21pbWVUeXBlfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XG4gICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgICAgICB0cmFjay5idWZmZXIgPSBzYjtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLCBmYXRhbDogZmFsc2UsIGVycjogZXJyLCBtaW1lVHlwZSA6IG1pbWVUeXBlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ1JFQVRFRCwgeyB0cmFja3MgOiB0cmFja3MgfSApO1xuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRpbmcoZGF0YSkge1xuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgaWYgKCF0aGlzLnNlZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbIGRhdGEgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZEZhaWwoZGF0YSkge1xuICAgIGxvZ2dlci5lcnJvcihgc291cmNlQnVmZmVyIGVycm9yOiR7ZGF0YS5ldmVudH1gKTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogdGhpcy5mcmFnQ3VycmVudH0pO1xuICB9XG5cbiAgLy8gb24gQlVGRkVSX0VPUyBtYXJrIG1hdGNoaW5nIHNvdXJjZWJ1ZmZlcihzKSBhcyBlbmRlZCBhbmQgdHJpZ2dlciBjaGVja0VvcygpXG4gIG9uQnVmZmVyRW9zKGRhdGEpIHtcbiAgICB2YXIgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBsZXQgZGF0YVR5cGUgPSBkYXRhLnR5cGU7XG4gICAgZm9yKGxldCB0eXBlIGluIHNiKSB7XG4gICAgICBpZiAoIWRhdGFUeXBlIHx8IHR5cGUgPT09IGRhdGFUeXBlKSB7XG4gICAgICAgIGlmICghc2JbdHlwZV0uZW5kZWQpIHtcbiAgICAgICAgICBzYlt0eXBlXS5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgJHt0eXBlfSBzb3VyY2VCdWZmZXIgbm93IEVPU2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgfVxuXG4gLy8gaWYgYWxsIHNvdXJjZSBidWZmZXJzIGFyZSBtYXJrZWQgYXMgZW5kZWQsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlLlxuIGNoZWNrRW9zKCkge1xuICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvcihsZXQgdHlwZSBpbiBzYikge1xuICAgICAgaWYgKCFzYlt0eXBlXS5lbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZihzYlt0eXBlXS51cGRhdGluZykge1xuICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnYWxsIG1lZGlhIGRhdGEgYXZhaWxhYmxlLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZSBhbmQgc3RvcCBsb2FkaW5nIGZyYWdtZW50Jyk7XG4gICAgLy9Ob3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxuICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiB9XG5cblxuICBvbkJ1ZmZlckZsdXNoaW5nKGRhdGEpIHtcbiAgICB0aGlzLmZsdXNoUmFuZ2UucHVzaCh7c3RhcnQ6IGRhdGEuc3RhcnRPZmZzZXQsIGVuZDogZGF0YS5lbmRPZmZzZXQsIHR5cGUgOiBkYXRhLnR5cGV9KTtcbiAgICAvLyBhdHRlbXB0IGZsdXNoIGltbWVkaWF0bHlcbiAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgdGhpcy5kb0ZsdXNoKCk7XG4gIH1cblxuICBvbkxldmVsVXBkYXRlZChldmVudCkge1xuICAgIGxldCBkZXRhaWxzID0gZXZlbnQuZGV0YWlscztcbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24gKyBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGFpbHltb3Rpb24vaGxzLmpzL2lzc3Vlcy8zNTVcbiAgdXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xldmVsRHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlLFxuICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBpZiAoIW1lZGlhIHx8ICFtZWRpYVNvdXJjZSB8fCAhc291cmNlQnVmZmVyIHx8IG1lZGlhLnJlYWR5U3RhdGUgPT09IDAgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICBpZiAoc291cmNlQnVmZmVyW3R5cGVdLnVwZGF0aW5nKSB7XG4gICAgICAgIC8vIGNhbid0IHNldCBkdXJhdGlvbiB3aGlsc3QgYSBidWZmZXIgaXMgdXBkYXRpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fbXNEdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgLy8gaW5pdGlhbGlzZSB0byB0aGUgdmFsdWUgdGhhdCB0aGUgbWVkaWEgc291cmNlIGlzIHJlcG9ydGluZ1xuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IG1lZGlhU291cmNlLmR1cmF0aW9uO1xuICAgIH1cbiAgICAvLyB0aGlzLl9sZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXG4gICAgLy8gbm90IHVzaW5nIG1lZGlhU291cmNlLmR1cmF0aW9uIGFzIHRoZSBicm93c2VyIG1heSB0d2VhayB0aGlzIHZhbHVlXG4gICAgLy8gb25seSB1cGRhdGUgbWVkaWFzb3VyY2UgZHVyYXRpb24gaWYgaXRzIHZhbHVlIGluY3JlYXNlLCB0aGlzIGlzIHRvIGF2b2lkXG4gICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbCwgYXMgdGhleVxuICAgIGlmICh0aGlzLl9sZXZlbER1cmF0aW9uID4gdGhpcy5fbXNEdXJhdGlvbikge1xuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgbWVkaWFzb3VyY2UgZHVyYXRpb24gdG8gJHt0aGlzLl9sZXZlbER1cmF0aW9ufWApO1xuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSB0aGlzLl9sZXZlbER1cmF0aW9uO1xuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgZG9GbHVzaCgpIHtcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGJ1ZmZlciByYW5nZXMgdG8gZmx1c2hcbiAgICB3aGlsZSh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmZsdXNoUmFuZ2VbMF07XG4gICAgICAvLyBmbHVzaEJ1ZmZlciB3aWxsIGFib3J0IGFueSBidWZmZXIgYXBwZW5kIGluIHByb2dyZXNzIGFuZCBmbHVzaCBBdWRpby9WaWRlbyBCdWZmZXJcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIHJhbmdlLnR5cGUpKSB7XG4gICAgICAgIC8vIHJhbmdlIGZsdXNoZWQsIHJlbW92ZSBmcm9tIGZsdXNoIGFycmF5XG4gICAgICAgIHRoaXMuZmx1c2hSYW5nZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgLy8gYXZvaWQgbG9vcGluZywgd2FpdCBmb3IgU0IgdXBkYXRlIGVuZCB0byByZXRyaWdnZXIgYSBmbHVzaFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWRcbiAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSBmYWxzZTtcblxuICAgICAgLy8gbGV0J3MgcmVjb21wdXRlIHRoaXMuYXBwZW5kZWQsIHdoaWNoIGlzIHVzZWQgdG8gYXZvaWQgZmx1c2ggbG9vcGluZ1xuICAgICAgdmFyIGFwcGVuZGVkID0gMDtcbiAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgIGFwcGVuZGVkICs9IHNvdXJjZUJ1ZmZlclt0eXBlXS5idWZmZXJlZC5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZGVkID0gYXBwZW5kZWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSEVEKTtcbiAgICB9XG4gIH1cblxuICBkb0FwcGVuZGluZygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHMsIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYS5lcnJvcikge1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgIGxvZ2dlci5lcnJvcigndHJ5aW5nIHRvIGFwcGVuZCBhbHRob3VnaCBhIG1lZGlhIGVycm9yIG9jY3VyZWQsIGZsdXNoIHNlZ21lbnQgYW5kIGFib3J0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFwcGVuZGluZykge1xuICAgICAgICAvL2xvZ2dlci5sb2coYHNiIGFwcGVuZGluZyBpbiBwcm9ncmVzc2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgdHlwZSA9IHNlZ21lbnQudHlwZTtcbiAgICAgICAgICBpZihzb3VyY2VCdWZmZXJbdHlwZV0pIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHNvdXJjZUJ1ZmZlciBlbmRlZCBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgc2VnbWVudFxuICAgICAgICAgICAgc291cmNlQnVmZmVyW3R5cGVdLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coYGFwcGVuZGluZyAke3NlZ21lbnQuY29udGVudH0gJHtzZWdtZW50LnR5cGV9IFNCLCBzaXplOiR7c2VnbWVudC5kYXRhLmxlbmd0aH0sICR7c2VnbWVudC5wYXJlbnR9YCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHNlZ21lbnQucGFyZW50O1xuICAgICAgICAgICAgc291cmNlQnVmZmVyW3R5cGVdLmFwcGVuZEJ1ZmZlcihzZWdtZW50LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkKys7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgc291cmNlIGJ1ZmZlciBtYXRjaGluZyB3aXRoIHRoaXMgc2VnbWVudCB0eXBlLFxuICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhhdCBNZWRpYXNvdXJjZSBmYWlscyB0byBjcmVhdGUgc291cmNlYnVmZmVyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIHRoaXMgc2VnbWVudCwgYW5kIHRyaWdnZXIgdXBkYXRlIGVuZFxuICAgICAgICAgICAgdGhpcy5vblNCVXBkYXRlRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIGJ1ZmZlcjoke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XG4gICAgICAgICAgdmFyIGV2ZW50ID0ge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1J9O1xuICAgICAgICAgIGlmKGVyci5jb2RlICE9PSAyMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgICBldmVudC5mcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIHJldHJ5aW5nIGhlbHAgcmVjb3ZlcmluZyB0aGlzXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IgPiBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZmFpbCAke2hscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeX0gdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gc291cmNlQnVmZmVyYCk7XG4gICAgICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgZmx1c2ggc3BlY2lmaWVkIGJ1ZmZlcmVkIHJhbmdlLFxuICAgIHJldHVybiB0cnVlIG9uY2UgcmFuZ2UgaGFzIGJlZW4gZmx1c2hlZC5cbiAgICBhcyBzb3VyY2VCdWZmZXIucmVtb3ZlKCkgaXMgYXN5bmNocm9ub3VzLCBmbHVzaEJ1ZmZlciB3aWxsIGJlIHJldHJpZ2dlcmVkIG9uIHNvdXJjZUJ1ZmZlciB1cGRhdGUgZW5kXG4gICovXG4gIGZsdXNoQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGVJbikge1xuICAgIHZhciBzYiwgaSwgYnVmU3RhcnQsIGJ1ZkVuZCwgZmx1c2hTdGFydCwgZmx1c2hFbmQsIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZygnZmx1c2hCdWZmZXIscG9zL3N0YXJ0L2VuZDogJyArIHRoaXMubWVkaWEuY3VycmVudFRpbWUgKyAnLycgKyBzdGFydE9mZnNldCArICcvJyArIGVuZE9mZnNldCk7XG4gICAgICAvLyBzYWZlZ3VhcmQgdG8gYXZvaWQgaW5maW5pdGUgbG9vcGluZyA6IGRvbid0IHRyeSB0byBmbHVzaCBtb3JlIHRoYW4gdGhlIG5iIG9mIGFwcGVuZGVkIHNlZ21lbnRzXG4gICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPCB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlYnVmZmVyIHR5cGUgaXMgZGVmaW5lZCAodHlwZUluKTogaWYgeWVzLCBsZXQncyBvbmx5IGZsdXNoIHRoaXMgb25lXG4gICAgICAgICAgLy8gaWYgbm8sIGxldCdzIGZsdXNoIGFsbCBzb3VyY2VidWZmZXJzXG4gICAgICAgICAgaWYgKHR5cGVJbiAmJiB0eXBlICE9PSB0eXBlSW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZiAoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2IuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgYnVmU3RhcnQgPSBzYi5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgICAgICAgICAgYnVmRW5kID0gc2IuYnVmZmVyZWQuZW5kKGkpO1xuICAgICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZpcmVmb3ggbm90IGFibGUgdG8gcHJvcGVybHkgZmx1c2ggbXVsdGlwbGUgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMSAmJiBlbmRPZmZzZXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIGZsdXNoU3RhcnQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IGVuZE9mZnNldDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbHVzaFN0YXJ0ID0gTWF0aC5tYXgoYnVmU3RhcnQsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IE1hdGgubWluKGJ1ZkVuZCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiBzb21ldGltZXMgc291cmNlYnVmZmVyLnJlbW92ZSgpIGRvZXMgbm90IGZsdXNoXG4gICAgICAgICAgICAgICAgIHRoZSBleGFjdCBleHBlY3RlZCB0aW1lIHJhbmdlLlxuICAgICAgICAgICAgICAgICB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMvaW5maW5pdGUgbG9vcCxcbiAgICAgICAgICAgICAgICAgb25seSBmbHVzaCBidWZmZXIgcmFuZ2Ugb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiA1MDBtcy5cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgaWYgKE1hdGgubWluKGZsdXNoRW5kLGJ1ZkVuZCkgLSBmbHVzaFN0YXJ0ID4gMC41ICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZmx1c2ggJHt0eXBlfSBbJHtmbHVzaFN0YXJ0fSwke2ZsdXNoRW5kfV0sIG9mIFske2J1ZlN0YXJ0fSwke2J1ZkVuZH1dLCBwb3M6JHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lfWApO1xuICAgICAgICAgICAgICAgIHNiLnJlbW92ZShmbHVzaFN0YXJ0LCBmbHVzaEVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnYWJvcnQgJyArIHR5cGUgKyAnIGFwcGVuZCBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGFib3J0IGFueSBhcHBlbmRpbmcgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIC8vc2IuYWJvcnQoKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdjYW5ub3QgZmx1c2gsIHNiIHVwZGF0aW5nIGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignYWJvcnQgZmx1c2hpbmcgdG9vIG1hbnkgcmV0cmllcycpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZygnYnVmZmVyIGZsdXNoZWQnKTtcbiAgICB9XG4gICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkICFcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJDb250cm9sbGVyO1xuIiwiLypcbiAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuXG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXHRjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VEKTsgICBcblx0fVxuXHRcblx0ZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICB0aGlzLm1lZGlhID0gdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gbnVsbDtcbiAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXHRcbiAgb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMucmVzdHJpY3RlZExldmVscykge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0xldmVsUmVzdHJpY3RlZChkYXRhLmRyb3BwZWRMZXZlbCkpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKGRhdGEuZHJvcHBlZExldmVsKTtcbiAgICB9XG4gIH1cbiAgXG5cdG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsOyAgXG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgdGhpcy5obHMuZmlyc3RMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwoZGF0YS5maXJzdExldmVsKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgfVxuICB9XG4gIFxuICBkZXRlY3RQbGF5ZXJTaXplKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICBsZXQgbGV2ZWxzTGVuZ3RoID0gdGhpcy5sZXZlbHMgPyB0aGlzLmxldmVscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKGxldmVsc0xlbmd0aCkge1xuICAgICAgICB0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHNMZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcpIHtcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxuICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICB0aGlzLmhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmc7ICAgICAgICBcbiAgICAgIH0gIFxuICAgIH1cbiAgfVxuICBcbiAgLypcbiAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAqL1xuICBnZXRNYXhMZXZlbChjYXBMZXZlbEluZGV4KSB7XG4gICAgbGV0IHJlc3VsdCA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIGxldmVsLFxuICAgICAgICBtV2lkdGggPSB0aGlzLm1lZGlhV2lkdGgsXG4gICAgICAgIG1IZWlnaHQgPSB0aGlzLm1lZGlhSGVpZ2h0LFxuICAgICAgICBsV2lkdGggPSAwLFxuICAgICAgICBsSGVpZ2h0ID0gMDtcbiAgICAgICAgXG4gICAgZm9yIChpID0gMDsgaSA8PSBjYXBMZXZlbEluZGV4OyBpKyspIHtcbiAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbaV07XG4gICAgICBpZiAodGhpcy5pc0xldmVsUmVzdHJpY3RlZChpKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBsV2lkdGggPSBsZXZlbC53aWR0aDtcbiAgICAgIGxIZWlnaHQgPSBsZXZlbC5oZWlnaHQ7XG4gICAgICBpZiAobVdpZHRoIDw9IGxXaWR0aCB8fCBtSGVpZ2h0IDw9IGxIZWlnaHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBcbiAgaXNMZXZlbFJlc3RyaWN0ZWQobGV2ZWwpIHtcbiAgICByZXR1cm4gKHRoaXMucmVzdHJpY3RlZExldmVscyAmJiB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMuaW5kZXhPZihsZXZlbCkgIT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbiAgfVxuICBcbiAgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvcigpIHtcbiAgICBsZXQgcGl4ZWxSYXRpbyA9IDE7XG4gICAgdHJ5IHtcbiAgICAgIHBpeGVsUmF0aW8gPSAgd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfSBjYXRjaChlKSB7fVxuICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICB9XG4gIFxuICBnZXQgbWVkaWFXaWR0aCgpIHtcbiAgICBsZXQgd2lkdGg7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tZWRpYS53aWR0aCB8fCB0aGlzLm1lZGlhLmNsaWVudFdpZHRoIHx8IHRoaXMubWVkaWEub2Zmc2V0V2lkdGg7XG4gICAgICB3aWR0aCAqPSB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIFxuICBnZXQgbWVkaWFIZWlnaHQoKSB7XG4gICAgbGV0IGhlaWdodDtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5tZWRpYS5oZWlnaHQgfHwgdGhpcy5tZWRpYS5jbGllbnRIZWlnaHQgfHwgdGhpcy5tZWRpYS5vZmZzZXRIZWlnaHQ7XG4gICAgICBoZWlnaHQgKj0gdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7IFxuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcExldmVsQ29udHJvbGxlcjsiLCIvKlxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxuICovXG5cbmltcG9ydCBFV01BIGZyb20gJy4uL3V0aWxzL2V3bWEnO1xuXG5cbmNsYXNzIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKGhscyxzbG93LGZhc3QsZGVmYXVsdEVzdGltYXRlKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcbiAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdyk7XG4gICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QpO1xuICB9XG5cbiAgc2FtcGxlKGR1cmF0aW9uTXMsbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgdmFyIGJhbmR3aWR0aCA9IDgwMDAqIG51bUJ5dGVzIC8gZHVyYXRpb25NcyxcbiAgICAvL2NvbnNvbGUubG9nKCdpbnN0YW50IGJ3OicrIE1hdGgucm91bmQoYmFuZHdpZHRoKSk7XG4gICAgLy8gd2Ugd2VpZ2h0IHNhbXBsZSB1c2luZyBsb2FkaW5nIGR1cmF0aW9uLi4uLlxuICAgICAgICB3ZWlnaHQgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICB0aGlzLmZhc3RfLnNhbXBsZSh3ZWlnaHQsYmFuZHdpZHRoKTtcbiAgICB0aGlzLnNsb3dfLnNhbXBsZSh3ZWlnaHQsYmFuZHdpZHRoKTtcbiAgfVxuXG5cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKCF0aGlzLmZhc3RfIHx8ICF0aGlzLnNsb3dfIHx8IHRoaXMuZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSA8IHRoaXMubWluV2VpZ2h0Xykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgIC8vY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xuXG4iLCIvKlxuICogRlBTIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBGUFNDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVye1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgfVxuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICB9XG4gIFxuICBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICB0aGlzLnZpZGVvID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgdGhpcy5obHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICB9IFxuICB9XG4gIFxuICBjaGVja0ZQUyh2aWRlbywgZGVjb2RlZEZyYW1lcywgZHJvcHBlZEZyYW1lcykge1xuICAgIGxldCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XG4gICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICBsZXQgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZSxcbiAgICAgICAgICAgIGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXMsXG4gICAgICAgICAgICBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzLFxuICAgICAgICAgICAgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlBTX0RST1AsIHtjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzfSk7XG4gICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoY3VycmVudERyb3BwZWQgPiB0aGlzLmhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IHRoaXMuaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArIGN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAodGhpcy5obHMuYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgfHwgdGhpcy5obHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORywge2xldmVsOiBjdXJyZW50TGV2ZWwsIGRyb3BwZWRMZXZlbDogdGhpcy5obHMuY3VycmVudExldmVsfSk7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xuICAgIH1cbiAgfVxuICBcbiAgY2hlY2tGUFNJbnRlcnZhbCgpIHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICBsZXQgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB0aGlzLnZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModGhpcy52aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModGhpcy52aWRlbywgdGhpcy52aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdGhpcy52aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7ICBcbiAgICAgIH1cbiAgICB9XG4gIH0gXG59XG5cbmV4cG9ydCBkZWZhdWx0IEZQU0NvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBMZXZlbCBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5jbGFzcyBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LkVSUk9SKTtcbiAgICB0aGlzLm9udGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX21hbnVhbExldmVsID0gdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX21hbnVhbExldmVsID0gLTE7XG4gIH1cblxuICBzdGFydExvYWQoKSB7XG4gICAgdGhpcy5jYW5sb2FkID0gdHJ1ZTtcbiAgICAvLyBzcGVlZCB1cCBsaXZlIHBsYXlsaXN0IHJlZnJlc2ggaWYgdGltZXIgZXhpc3RzXG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgdmFyIGxldmVsczAgPSBbXSwgbGV2ZWxzID0gW10sIGJpdHJhdGVTdGFydCwgaSwgYml0cmF0ZVNldCA9IHt9LCB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZSwgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2UsIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWwgdG9nZXRoZXJcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIGlmKGxldmVsLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmKGxldmVsLmF1ZGlvQ29kZWMgfHwgKGxldmVsLmF0dHJzICYmIGxldmVsLmF0dHJzLkFVRElPKSkge1xuICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZHVuZGFudExldmVsSWQgPSBiaXRyYXRlU2V0W2xldmVsLmJpdHJhdGVdO1xuICAgICAgaWYgKHJlZHVuZGFudExldmVsSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiaXRyYXRlU2V0W2xldmVsLmJpdHJhdGVdID0gbGV2ZWxzMC5sZW5ndGg7XG4gICAgICAgIGxldmVsLnVybCA9IFtsZXZlbC51cmxdO1xuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgIGxldmVsczAucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbHMwW3JlZHVuZGFudExldmVsSWRdLnVybC5wdXNoKGxldmVsLnVybCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYXVkaW8tb25seSBsZXZlbCBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggYXVkaW8rdmlkZW8gY29kZWNzIHNpZ25hbGxlZFxuICAgIGlmKHZpZGVvQ29kZWNGb3VuZCAmJiBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgIGxldmVsczAuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgIGlmKGxldmVsLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMwO1xuICAgIH1cblxuICAgIC8vIG9ubHkga2VlcCBsZXZlbCB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICB2YXIgY2hlY2tTdXBwb3J0ZWRBdWRpbyA9IGZ1bmN0aW9uKGNvZGVjKSB7IHJldHVybiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoYGF1ZGlvL21wNDtjb2RlY3M9JHtjb2RlY31gKTt9O1xuICAgICAgdmFyIGNoZWNrU3VwcG9ydGVkVmlkZW8gPSBmdW5jdGlvbihjb2RlYykgeyByZXR1cm4gTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKGB2aWRlby9tcDQ7Y29kZWNzPSR7Y29kZWN9YCk7fTtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYywgdmlkZW9Db2RlYyA9IGxldmVsLnZpZGVvQ29kZWM7XG5cbiAgICAgIHJldHVybiAoIWF1ZGlvQ29kZWMgfHwgY2hlY2tTdXBwb3J0ZWRBdWRpbyhhdWRpb0NvZGVjKSkgJiZcbiAgICAgICAgICAgICAoIXZpZGVvQ29kZWMgfHwgY2hlY2tTdXBwb3J0ZWRWaWRlbyh2aWRlb0NvZGVjKSk7XG4gICAgfSk7XG5cbiAgICBpZihsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgICAgYml0cmF0ZVN0YXJ0ID0gbGV2ZWxzWzBdLmJpdHJhdGU7XG4gICAgICAvLyBzb3J0IGxldmVsIG9uIGJpdHJhdGVcbiAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICAgIGxvZ2dlci5sb2coYG1hbmlmZXN0IGxvYWRlZCwke2xldmVscy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiR7Yml0cmF0ZVN0YXJ0fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9QQVJTRUQsIHtsZXZlbHM6IHRoaXMuX2xldmVscywgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCwgc3RhdHM6IGRhdGEuc3RhdHMsIGF1ZGlvIDogYXVkaW9Db2RlY0ZvdW5kLCB2aWRlbyA6IHZpZGVvQ29kZWNGb3VuZH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiBobHMudXJsLCByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J30pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gIH1cblxuICBnZXQgbGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICB9XG5cbiAgc2V0IGxldmVsKG5ld0xldmVsKSB7XG4gICAgbGV0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzICYmIGxldmVscy5sZW5ndGggPiBuZXdMZXZlbCkge1xuICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCB8fCBsZXZlbHNbbmV3TGV2ZWxdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gc2V0TGV2ZWxJbnRlcm5hbChuZXdMZXZlbCkge1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyB0byBsZXZlbCAke25ld0xldmVsfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9TV0lUQ0gsIHtsZXZlbDogbmV3TGV2ZWx9KTtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF0sIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsLiBkb24ndCByZWxvYWQgbGl2ZSBwbGF5bGlzdCBtb3JlIHRoYW4gb25jZSBwZXIgc2Vjb25kXG4gICAgICBpZiAoIWxldmVsRGV0YWlscyB8fFxuICAgICAgICAgIChsZXZlbERldGFpbHMubGl2ZSA9PT0gdHJ1ZSAmJiAocGVyZm9ybWFuY2Uubm93KCkgLSBsZXZlbERldGFpbHMudGxvYWQgPiAxMDAwKSApKSB7XG4gICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgbG9nZ2VyLmxvZyhgKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIGxldmVsICR7bmV3TGV2ZWx9YCk7XG4gICAgICAgIHZhciB1cmxJZCA9IGxldmVsLnVybElkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHt1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBuZXdMZXZlbCwgaWQ6IHVybElkfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUiwgbGV2ZWw6IG5ld0xldmVsLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4J30pO1xuICAgIH1cbiB9XG5cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9tYW51YWxMZXZlbDtcbiAgfVxuXG4gIHNldCBtYW51YWxMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX21hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gIH1cblxuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIG9uRXJyb3IoZGF0YSkge1xuICAgIGlmKGRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZGV0YWlscyA9IGRhdGEuZGV0YWlscywgaGxzID0gdGhpcy5obHMsIGxldmVsSWQsIGxldmVsLCBsZXZlbEVycm9yID0gZmFsc2U7XG4gICAgLy8gdHJ5IHRvIHJlY292ZXIgbm90IGZhdGFsIGVycm9yc1xuICAgIHN3aXRjaChkZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAgbGV2ZWxJZCA9IGRhdGEuZnJhZy5sZXZlbDtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgbGV2ZWxJZCA9IGRhdGEuY29udGV4dC5sZXZlbDtcbiAgICAgICAgbGV2ZWxFcnJvciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIHRyeSB0byBzd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAgICogaWYgbm8gcmVkdW5kYW50IHN0cmVhbSBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAoaWYgaW4gYXV0byBtb2RlIGFuZCBjdXJyZW50IGxldmVsIG5vdCAwKVxuICAgICAqIG90aGVyd2lzZSwgd2UgY2Fubm90IHJlY292ZXIgdGhpcyBuZXR3b3JrIGVycm9yIC4uLlxuICAgICAqIGRvbid0IHJhaXNlIEZSQUdfTE9BRF9FUlJPUiBhbmQgRlJBR19MT0FEX1RJTUVPVVQgYXMgZmF0YWwsIGFzIGl0IGlzIGhhbmRsZWQgYnkgbWVkaWFDb250cm9sbGVyXG4gICAgICovXG4gICAgaWYgKGxldmVsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XG4gICAgICBpZiAobGV2ZWwudXJsSWQgPCAobGV2ZWwudXJsLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgIGxldmVsLnVybElkKys7XG4gICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30gZm9yIGxldmVsICR7bGV2ZWxJZH06IHN3aXRjaGluZyB0byByZWR1bmRhbnQgc3RyZWFtIGlkICR7bGV2ZWwudXJsSWR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBjb3VsZCB0cnkgdG8gcmVjb3ZlciBpZiBpbiBhdXRvIG1vZGUgYW5kIGN1cnJlbnQgbGV2ZWwgbm90IGxvd2VzdCBsZXZlbCAoMClcbiAgICAgICAgbGV0IHJlY292ZXJhYmxlID0gKCh0aGlzLl9tYW51YWxMZXZlbCA9PT0gLTEpICYmIGxldmVsSWQpO1xuICAgICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwke2RldGFpbHN9OiBlbWVyZ2VuY3kgc3dpdGNoLWRvd24gZm9yIG5leHQgZnJhZ21lbnRgKTtcbiAgICAgICAgICBobHMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gMDtcbiAgICAgICAgfSBlbHNlIGlmKGxldmVsICYmIGxldmVsLmRldGFpbHMgJiYgbGV2ZWwuZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsJHtkZXRhaWxzfSBvbiBsaXZlIHN0cmVhbSwgZGlzY2FyZGApO1xuICAgICAgICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICAgICAgICAvLyByZXNldCB0aGlzLl9sZXZlbCBzbyB0aGF0IGFub3RoZXIgY2FsbCB0byBzZXQgbGV2ZWwoKSB3aWxsIHJldHJpZ2dlciBhIGZyYWcgbG9hZFxuICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAvLyBGUkFHX0xPQURfRVJST1IgYW5kIEZSQUdfTE9BRF9USU1FT1VUIGFyZSBoYW5kbGVkIGJ5IG1lZGlhQ29udHJvbGxlclxuICAgICAgICB9IGVsc2UgaWYgKGRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IgJiYgZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBjYW5ub3QgcmVjb3ZlciAke2RldGFpbHN9IGVycm9yYCk7XG4gICAgICAgICAgdGhpcy5fbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkxldmVsTG9hZGVkKGRhdGEpIHtcbiAgICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgICBpZiAoZGF0YS5sZXZlbCA9PT0gdGhpcy5fbGV2ZWwpIHtcbiAgICAgIGxldCBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwKiggbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPyBuZXdEZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA6IG5ld0RldGFpbHMudGFyZ2V0ZHVyYXRpb24pLFxuICAgICAgICAgICAgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbZGF0YS5sZXZlbF0sXG4gICAgICAgICAgICBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5lbmRTTiA9PT0gY3VyRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgICAgICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgICAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgICByZWxvYWRJbnRlcnZhbCAvPTI7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc2FtZSBsaXZlIHBsYXlsaXN0LCByZWxvYWQgdHdpY2UgZmFzdGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjcmVtZW50IHJlbG9hZEludGVydmFsIHdpdGggbGV2ZWwgbG9hZGluZyBkZWxheVxuICAgICAgICByZWxvYWRJbnRlcnZhbCAtPSBwZXJmb3JtYW5jZS5ub3coKSAtIGRhdGEuc3RhdHMudHJlcXVlc3Q7XG4gICAgICAgIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGV2ZXJ5IHNlY29uZFxuICAgICAgICByZWxvYWRJbnRlcnZhbCA9IE1hdGgubWF4KDEwMDAsTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCkpO1xuICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCByZWxvYWQgaW4gJHtyZWxvYWRJbnRlcnZhbH0gbXNgKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5vbnRpY2sscmVsb2FkSW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGljaygpIHtcbiAgICB2YXIgbGV2ZWxJZCA9IHRoaXMuX2xldmVsO1xuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jYW5sb2FkKSB7XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF0sIHVybElkID0gbGV2ZWwudXJsSWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHt1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBsZXZlbElkLCBpZDogdXJsSWR9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5fbWFudWFsTGV2ZWwgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFudWFsTGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgcmV0dXJuIHRoaXMuaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgbmV4dExvYWRMZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuICAgIGlmICh0aGlzLl9tYW51YWxMZXZlbCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGV2ZWxDb250cm9sbGVyO1xuXG4iLCIvKlxuICogU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IExldmVsSGVscGVyIGZyb20gJy4uL2hlbHBlci9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZVJhbmdlcyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRCA6ICdTVE9QUEVEJyxcbiAgU1RBUlRJTkcgOiAnU1RBUlRJTkcnLFxuICBJRExFIDogJ0lETEUnLFxuICBQQVVTRUQgOiAnUEFVU0VEJyxcbiAgS0VZX0xPQURJTkcgOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkcgOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkgOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX0xFVkVMIDogJ1dBSVRJTkdfTEVWRUwnLFxuICBQQVJTSU5HIDogJ1BBUlNJTkcnLFxuICBQQVJTRUQgOiAnUEFSU0VEJyxcbiAgRU5ERUQgOiAnRU5ERUQnLFxuICBFUlJPUiA6ICdFUlJPUidcbn07XG5cbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0gsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVEKTtcblxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy50aWNrcyA9IDA7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG5cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsJ21haW4nKTtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKG1lZGlhICYmIGxhc3RDdXJyZW50VGltZSA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gQCR7bGFzdEN1cnJlbnRUaW1lfWApO1xuICAgICAgICBpZiAoIXRoaXMubGFzdFBhdXNlZCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3Jlc3VtaW5nIHZpZGVvJyk7XG4gICAgICAgICAgbWVkaWEucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLnN0YXJ0UG9zaXRpb24gPyB0aGlzLnN0YXJ0UG9zaXRpb24gOiBzdGFydFBvc2l0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RBUlRJTkc7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignY2Fubm90IHN0YXJ0IGxvYWRpbmcgYXMgbWFuaWZlc3Qgbm90IHBhcnNlZCB5ZXQnKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZykge1xuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgdGhpcy50aWNrcysrO1xuICAgIGlmICh0aGlzLnRpY2tzID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgaWYgKHRoaXMudGlja3MgPiAxKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy50aWNrLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGlja3MgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5TVEFSVElORzpcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICBsZXQgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICB0aGlzLmZyYWdCaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgLy8gd2hlbiB0aGlzIHJldHVybnMgZmFsc2UgdGhlcmUgd2FzIGFuIGVycm9yIGFuZCB3ZSBzaGFsbCByZXR1cm4gaW1tZWRpYXRseVxuICAgICAgICAvLyBmcm9tIGN1cnJlbnQgdGlja1xuICAgICAgICBpZiAoIXRoaXMuX2RvVGlja0lkbGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmIChsZXZlbCAmJiBsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgaWYoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5zZWVraW5nKSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYG1lZGlhQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGVgKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICBjYXNlIFN0YXRlLlBBVVNFRDpcbiAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBjaGVjayBidWZmZXJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xuICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG4gICAgdGhpcy5fY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuXG4gIC8vIElyb25pY2FsbHkgdGhlIFwiaWRsZVwiIHN0YXRlIGlzIHRoZSBvbiB3ZSBkbyB0aGUgbW9zdCBsb2dpYyBpbiBpdCBzZWVtcyAuLi4uXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxuICAvLyAgICAgICBwbGF5ZWQgc2VnbWVudCwgb3Igb24gcGF1c2UvcGxheS9zZWVrIGluc3RlYWQgb2YgbmFpdmVseSBjaGVja2luZyBldmVyeSAxMDBtcz9cbiAgX2RvVGlja0lkbGUoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgLy8gZXhpdCBsb29wXG4gICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgIGlmICghbWVkaWEgJiZcbiAgICAgICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgIGxldCBwb3M7XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBuZXh0IGxvYWQgbGV2ZWxcbiAgICBsZXQgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbDtcblxuICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICBsZXQgbWF4QnVmTGVuO1xuICAgIGlmICgodGhpcy5sZXZlbHNbbGV2ZWxdKS5oYXNPd25Qcm9wZXJ0eSgnYml0cmF0ZScpKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyB0aGlzLmxldmVsc1tsZXZlbF0uYml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1pbihtYXhCdWZMZW4sIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAvLyBlbnN1cmUgdXAgdG8gYGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGhgIG9mIGJ1ZmZlciB1cGZyb250XG5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCAuLi5cbiAgICBsb2dnZXIudHJhY2UoYGJ1ZmZlciBsZW5ndGggb2YgJHtidWZmZXJMZW4udG9GaXhlZCgzKX0gaXMgYmVsb3cgbWF4IG9mICR7bWF4QnVmTGVuLnRvRml4ZWQoMyl9LiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLmApO1xuXG4gICAgLy8gc2V0IG5leHQgbG9hZCBsZXZlbCA6IHRoaXMgd2lsbCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZCBpZiBuZWVkZWRcbiAgICBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcblxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxzW2xldmVsXS5kZXRhaWxzO1xuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgIGlmICh0eXBlb2YgbGV2ZWxEZXRhaWxzID09PSAndW5kZWZpbmVkJyB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UganVzdCBnb3QgZG9uZSBsb2FkaW5nIHRoZSBmaW5hbCBmcmFnbWVudCwgY2hlY2sgaWYgd2UgbmVlZCB0byBmaW5hbGl6ZSBtZWRpYSBzdHJlYW1cbiAgICBsZXQgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnNuID09PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBzZWVraW5nIG9yIGlmIHdlIGFyZSBzZWVraW5nIGJ1dCBldmVyeXRoaW5nIChhbG1vc3QpIHRpbCB0aGUgZW5kIGlzIGJ1ZmZlcmVkLCBsZXQncyBzaWduYWwgZW9zXG4gICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSB3aGVuIHN3aXRjaGluZ1xuICAgICAgICAvLyBiZXR3ZWVuIGRpZmZlcmVudCByZW5kaXRpb25zLiB1c2luZyBoYWxmIGZyYWcgZHVyYXRpb24gc2hvdWxkIGhlbHAgY29wZSB3aXRoIHRoZXNlIGNhc2VzLlxuICAgICAgICBpZiAoIW1lZGlhLnNlZWtpbmcgfHwgKG1lZGlhLmR1cmF0aW9uLWJ1ZmZlckluZm8uZW5kKSA8PSBmcmFnUHJldmlvdXMuZHVyYXRpb24vMikge1xuICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgbWVkaWEgc3RyZWFtXG4gICAgICAgIGxldCBkYXRhID0ge307XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvVHJhY2tUeXBlID09PSAnQVVESU8nKSB7XG4gICAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSB0aGUgbGV2ZWxEZXRhaWxzIGZvciB0aGUgc2VsZWN0ZWQgdmFyaWFudCwgbGV0cyBjb250aW51ZSBlbnJpY2hlbiBvdXIgc3RyZWFtIChsb2FkIGtleXMvZnJhZ21lbnRzIG9yIHRyaWdnZXIgRU9TLCBldGMuLilcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hQYXlsb2FkT3JFb3Moe3BvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzfSk7XG4gIH1cblxuICBfZmV0Y2hQYXlsb2FkT3JFb3Moe3BvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzfSkge1xuICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbDtcblxuICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgbGV0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoLFxuICAgICAgICBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbi0xXS5kdXJhdGlvbixcbiAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgIGZyYWc7XG5cbiAgICAgIC8vIGluIGNhc2Ugb2YgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHJlcXVlc3RlZCBwb3NpdGlvbiBpcyBub3QgbG9jYXRlZCBiZWZvcmUgcGxheWxpc3Qgc3RhcnRcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGZyYWcgPSB0aGlzLl9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KHtsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW59KTtcbiAgICAgIC8vIGlmIGl0IGV4cGxpY2l0ZWx5IHJldHVybnMgbnVsbCBkb24ndCBsb2FkIGFueSBmcmFnbWVudCBhbmQgZXhpdCBmdW5jdGlvbiBub3dcbiAgICAgIGlmIChmcmFnID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIGZyYWcgPSB0aGlzLl9maW5kRnJhZ21lbnQoe3N0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlsc30pO1xuICAgIH1cbiAgICBpZihmcmFnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZEZyYWdtZW50T3JLZXkoe2ZyYWcsIGxldmVsLCBsZXZlbERldGFpbHMsIHBvcywgYnVmZmVyRW5kfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQoe2xldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbn0pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICBsZXQgZnJhZztcblxuICAgIC8vIGNoZWNrIGlmIHJlcXVlc3RlZCBwb3NpdGlvbiBpcyB3aXRoaW4gc2Vla2FibGUgYm91bmRhcmllcyA6XG4gICAgLy9sb2dnZXIubG9nKGBzdGFydC9wb3MvYnVmRW5kL3NlZWtpbmc6JHtzdGFydC50b0ZpeGVkKDMpfS8ke3Bvcy50b0ZpeGVkKDMpfS8ke2J1ZmZlckVuZC50b0ZpeGVkKDMpfS8ke3RoaXMubWVkaWEuc2Vla2luZ31gKTtcbiAgICBsZXQgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQqbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuXG4gICAgaWYgKGJ1ZmZlckVuZCA8IE1hdGgubWF4KHN0YXJ0LCBlbmQgLSBtYXhMYXRlbmN5KSkge1xuICAgICAgICBsZXQgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzdGFydCwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYnVmZmVyIGVuZDogJHtidWZmZXJFbmR9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0LCByZXNldCBjdXJyZW50VGltZSB0byA6ICR7bGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBlbmQgb2YgYnVmZmVyIGdyZWF0ZXIgdGhhbiBsaXZlIGVkZ2UsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50XG4gICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgbGl2ZSBwbGF5bGlzdCBpbnRlcm1pdHRlbnRseSBzbGlkZXMgaW4gdGhlIHBhc3QuXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MSwxODI1ODAxNjddXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjldXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjggb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjkgb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjhdIDw9PT09PT09PT09PT09IGhlcmUgd2Ugc2hvdWxkIGhhdmUgYnVmZmVyRW5kID4gZW5kLiBpbiB0aGF0IGNhc2UgYnJlYWsgdG8gYXZvaWQgcmVsb2FkaW5nIDE4MjU4MDE2OFxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjQsMTgyNTgwMTcxXVxuICAgIC8vXG4gICAgaWYgKGxldmVsRGV0YWlscy5QVFNLbm93biAmJiBidWZmZXJFbmQgPiBlbmQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAhbGV2ZWxEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAvKiB3ZSBhcmUgc3dpdGNoaW5nIGxldmVsIG9uIGxpdmUgcGxheWxpc3QsIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBQVFMgaW5mbyBmb3IgdGhhdCBxdWFsaXR5IGxldmVsIC4uLlxuICAgICAgICAgdHJ5IHRvIGxvYWQgZnJhZyBtYXRjaGluZyB3aXRoIG5leHQgU04uXG4gICAgICAgICBldmVuIGlmIFNOIGFyZSBub3Qgc3luY2hyb25pemVkIGJldHdlZW4gcGxheWxpc3RzLCBsb2FkaW5nIHRoaXMgZnJhZyB3aWxsIGhlbHAgdXNcbiAgICAgICAgIGNvbXB1dGUgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lIGFmdGVyIGluIGNhc2UgaXQgd2FzIG5vdCB0aGUgcmlnaHQgY29uc2VjdXRpdmUgb25lICovXG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgICAgIHZhciB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJHtmcmFnLnNufWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLyogd2UgaGF2ZSBubyBpZGVhIGFib3V0IHdoaWNoIGZyYWdtZW50IHNob3VsZCBiZSBsb2FkZWQuXG4gICAgICAgICAgIHNvIGxldCdzIGxvYWQgbWlkIGZyYWdtZW50LiBpdCB3aWxsIGhlbHAgY29tcHV0aW5nIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZVxuICAgICAgICAqL1xuICAgICAgICBmcmFnID0gZnJhZ21lbnRzW01hdGgubWluKGZyYWdMZW4gLSAxLCBNYXRoLnJvdW5kKGZyYWdMZW4gLyAyKSldO1xuICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIHVua25vd24sIGxvYWQgbWlkZGxlIGZyYWcgOiAke2ZyYWcuc259YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgX2ZpbmRGcmFnbWVudCh7c3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzfSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIGxldCBmcmFnLFxuICAgICAgICBmb3VuZEZyYWcsXG4gICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcblxuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwO1xuICAgICAgfVxuICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAgICAgICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgICAgICAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAvL2xvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gICAgICAgIGlmICgoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0vLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuLTFdO1xuICAgIH1cbiAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgc3RhcnQgPSBmb3VuZEZyYWcuc3RhcnQ7XG4gICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICBpZiAoZnJhZy5zbiA8IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgIGxldCBkZWx0YVBUUyA9IGZyYWdQcmV2aW91cy5kZWx0YVBUUyxcbiAgICAgICAgICBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxuICAgICAgICAgIC8vIGFuZCBpZiBwcmV2aW91cyByZW11eGVkIGZyYWdtZW50IGRpZCBub3Qgc3RhcnQgd2l0aCBhIGtleWZyYW1lLiAoZnJhZ1ByZXZpb3VzLmRyb3BwZWQpXG4gICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIGxvYWQgcHJldmlvdXMgZnJhZ21lbnQgYWdhaW4gdG8gZ2V0IGxhc3Qga2V5ZnJhbWVcbiAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcbiAgICAgICAgICBpZiAoZGVsdGFQVFMgJiYgZGVsdGFQVFMgPiBjb25maWcubWF4QnVmZmVySG9sZSAmJiBmcmFnUHJldmlvdXMuZHJvcHBlZCAmJiBjdXJTTklkeCkge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeC0xXTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBTTiBqdXN0IGxvYWRlZCwgd2l0aCBsYXJnZSBQVFMgZ2FwIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBtYXliZSBmcmFnIGlzIG5vdCBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgPyBsb2FkIHByZXZpb3VzIG9uZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc2ApO1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IHByZXZpb3VzIGZyYWcgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIHdoZW4gbmV4dCBmcmFnbWVudCB3aWxsIGdldCByZWxvYWRlZFxuICAgICAgICAgICAgZnJhZ1ByZXZpb3VzLmxvYWRDb3VudGVyLS07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHgrMV07XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIF9sb2FkRnJhZ21lbnRPcktleSh7ZnJhZywgbGV2ZWwsIGxldmVsRGV0YWlscywgcG9zLCBidWZmZXJFbmR9KSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIC8vbG9nZ2VyLmxvZygnbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgIGlmICgoZnJhZy5kZWNyeXB0ZGF0YS51cmkgIT0gbnVsbCkgJiYgKGZyYWcuZGVjcnlwdGRhdGEua2V5ID09IG51bGwpKSB7XG4gICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIubG9nKGBMb2FkaW5nICR7ZnJhZy5zbn0gb2YgWyR7bGV2ZWxEZXRhaWxzLnN0YXJ0U059ICwke2xldmVsRGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9LCBjdXJyZW50VGltZToke3Bvc30sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XG4gICAgICAvLyBlbnN1cmUgdGhhdCB3ZSBhcmUgbm90IHJlbG9hZGluZyB0aGUgc2FtZSBmcmFnbWVudHMgaW4gbG9vcCAuLi5cbiAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5sb2FkQ291bnRlcikge1xuICAgICAgICBmcmFnLmxvYWRDb3VudGVyKys7XG4gICAgICAgIGxldCBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAvLyBpZiB0aGlzIGZyYWcgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgMyB0aW1lcywgYW5kIGlmIGl0IGhhcyBiZWVuIHJlbG9hZGVkIHJlY2VudGx5XG4gICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyID4gbWF4VGhyZXNob2xkICYmIChNYXRoLmFicyh0aGlzLmZyYWdMb2FkSWR4IC0gZnJhZy5sb2FkSWR4KSA8IG1heFRocmVzaG9sZCkpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGZyYWcubG9hZElkeCA9IHRoaXMuZnJhZ0xvYWRJZHg7XG4gICAgICBmcmFnLmF1dG9MZXZlbCA9IGhscy5hdXRvTGV2ZWxFbmFibGVkO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHtmcmFnOiBmcmFnfSk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXRlKG5leHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBsb2dnZXIubG9nKGBlbmdpbmUgc3RhdGUgdHJhbnNpdGlvbiBmcm9tICR7cHJldmlvdXNTdGF0ZX0gdG8gJHtuZXh0U3RhdGV9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OLCB7cHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGdldEJ1ZmZlclJhbmdlKHBvc2l0aW9uKSB7XG4gICAgdmFyIGksIHJhbmdlLFxuICAgICAgICBidWZmZXJSYW5nZSA9IHRoaXMuYnVmZmVyUmFuZ2U7XG4gICAgaWYgKGJ1ZmZlclJhbmdlKSB7XG4gICAgICBmb3IgKGkgPSBidWZmZXJSYW5nZS5sZW5ndGggLSAxOyBpID49MDsgaS0tKSB7XG4gICAgICAgIHJhbmdlID0gYnVmZmVyUmFuZ2VbaV07XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSByYW5nZS5zdGFydCAmJiBwb3NpdGlvbiA8PSByYW5nZS5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKHRoaXMubWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5mcmFnLmxldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXQgbmV4dEJ1ZmZlclJhbmdlKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlclJhbmdlKHRoaXMuZ2V0QnVmZmVyUmFuZ2UodGhpcy5tZWRpYS5jdXJyZW50VGltZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmb2xsb3dpbmdCdWZmZXJSYW5nZShyYW5nZSkge1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyUmFuZ2UocmFuZ2UuZW5kICsgMC41KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgbmV4dExldmVsKCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMubmV4dEJ1ZmZlclJhbmdlO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgcmV0dXJuIHJhbmdlLmZyYWcubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBpc0J1ZmZlcmVkKHBvc2l0aW9uKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGxldCBidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCkge1xuICAgIHZhciByYW5nZUN1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnNlZWtpbmcgPT09IGZhbHNlKSB7XG4gICAgICBjdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xuICAgICAgLyogaWYgdmlkZW8gZWxlbWVudCBpcyBpbiBzZWVrZWQgc3RhdGUsIGN1cnJlbnRUaW1lIGNhbiBvbmx5IGluY3JlYXNlLlxuICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgQXMgc29tZXRpbWVzIGN1cnJlbnRUaW1lIGp1bXBzIGJhY2sgdG8gemVybyBhZnRlciBhXG4gICAgICAgIG1lZGlhIGRlY29kZSBlcnJvciwgY2hlY2sgdGhpcywgdG8gYXZvaWQgc2Vla2luZyBiYWNrIHRvXG4gICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAqL1xuICAgICAgaWYoY3VycmVudFRpbWUgPiB2aWRlby5wbGF5YmFja1JhdGUqdGhpcy5sYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQnVmZmVyZWQoY3VycmVudFRpbWUpKSB7XG4gICAgICAgIHJhbmdlQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UoY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQnVmZmVyZWQoY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgcmFuZ2VDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJSYW5nZShjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2VDdXJyZW50KSB7XG4gICAgICAgIHZhciBmcmFnUGxheWluZyA9IHJhbmdlQ3VycmVudC5mcmFnO1xuICAgICAgICBpZiAoZnJhZ1BsYXlpbmcgIT09IHRoaXMuZnJhZ1BsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmc7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0NIQU5HRUQsIHtmcmFnOiBmcmFnUGxheWluZ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICovXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xuICAgIGxvZ2dlci5sb2coJ2ltbWVkaWF0ZUxldmVsU3dpdGNoJyk7XG4gICAgaWYgKCF0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSB0cnVlO1xuICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSwgcHJldmlvdXNseVBhdXNlZDtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gbWVkaWEucGF1c2VkO1xuICAgICAgICBtZWRpYS5wYXVzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9uJ3QgcmVzdGFydCBwbGF5YmFjayBhZnRlciBpbnN0YW50IGxldmVsIHN3aXRjaCBpbiBjYXNlIG1lZGlhIG5vdCBhdHRhY2hlZFxuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldmlvdXNseVBhdXNlZCA9IHByZXZpb3VzbHlQYXVzZWQ7XG4gICAgfVxuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVVTRUQ7XG4gICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSk7XG4gIH1cblxuICAvKlxuICAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIGVuZCwgYWZ0ZXIgbmV3IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkIDpcbiAgICAgIC0gbnVkZ2UgdmlkZW8gZGVjb2RlciBieSBzbGlnaHRseSBhZGp1c3RpbmcgdmlkZW8gY3VycmVudFRpbWUgKGlmIGN1cnJlbnRUaW1lIGJ1ZmZlcmVkKVxuICAgICAgLSByZXN1bWUgdGhlIHBsYXliYWNrIGlmIG5lZWRlZFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5idWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gZmFsc2U7XG4gICAgICBpZih0aGlzLmlzQnVmZmVyZWQobWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICAgIC8vIG9ubHkgbnVkZ2UgaWYgY3VycmVudFRpbWUgaXMgYnVmZmVyZWRcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgLT0gMC4wMDAxO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnByZXZpb3VzbHlQYXVzZWQpIHtcbiAgICAgICAgbWVkaWEucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICAvKiB0cnkgdG8gc3dpdGNoIEFTQVAgd2l0aG91dCBicmVha2luZyB2aWRlbyBwbGF5YmFjayA6XG4gICAgICAgaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgICAgd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICAgIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAgKi9cbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIGxldCBmZXRjaGRlbGF5LCBjdXJyZW50UmFuZ2UsIG5leHRSYW5nZTtcbiAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICBjdXJyZW50UmFuZ2UgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChjdXJyZW50UmFuZ2UgJiYgY3VycmVudFJhbmdlLnN0YXJ0ID4gMSkge1xuICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywge3N0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IGN1cnJlbnRSYW5nZS5zdGFydCAtIDF9KTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEucGF1c2VkKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICB2YXIgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLG5leHRMZXZlbCA9IHRoaXMubGV2ZWxzW25leHRMZXZlbElkXSwgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLmJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vbG9nZ2VyLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICBuZXh0UmFuZ2UgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICBpZiAobmV4dFJhbmdlKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgbmV4dFJhbmdlID0gdGhpcy5mb2xsb3dpbmdCdWZmZXJSYW5nZShuZXh0UmFuZ2UpO1xuICAgICAgICBpZiAobmV4dFJhbmdlKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIC8vIGZsdXNoIHBvc2l0aW9uIGlzIHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGlzIG5ldyBidWZmZXJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IG5leHRSYW5nZS5zdGFydCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZChkYXRhKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZih0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWRpbmcgY291bnRlciBvbiBNU0UgZGV0YWNoaW5nIHRvIGF2b2lkIHJlcG9ydGluZyBGUkFHX0xPT1BfTE9BRElOR19FUlJPUiBhZnRlciBlcnJvciByZWNvdmVyeVxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICBpZiAobGV2ZWxzKSB7XG4gICAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkIGNvdW50ZXJcbiAgICAgICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICAgIGlmKGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICAgICAgICBmcmFnbWVudC5sb2FkQ291bnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCAgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZDtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzZWVraW5nIHRvICcgKyBjdXJyZW50VGltZSk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORykge1xuICAgICAgbGV0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSxjdXJyZW50VGltZSx0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgICBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgc2Vla2luZyB0byBhIHVuYnVmZmVyZWQgYXJlYSBBTkQgaWYgZnJhZyBsb2FkaW5nIGlzIGluIHByb2dyZXNzXG4gICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgbGV0IHRvbGVyYW5jZSA9IHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsXG4gICAgICAgICAgICBmcmFnU3RhcnRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCAtIHRvbGVyYW5jZSxcbiAgICAgICAgICAgIGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzZWVrIHBvc2l0aW9uIHdpbGwgYmUgb3V0IG9mIGN1cnJlbnRseSBsb2FkZWQgZnJhZyByYW5nZSA6IGlmIG91dCBjYW5jZWwgZnJhZyBsb2FkLCBpZiBpbiwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldCkge1xuICAgICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIGJ1dCB3aXRoaW4gY3VycmVudGx5IGxvYWRlZCBmcmFnbWVudCByYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICAvLyBhdm9pZCByZXBvcnRpbmcgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIGluIGNhc2UgdXNlciBpcyBzZWVraW5nIHNldmVyYWwgdGltZXMgb24gc2FtZSBwb3NpdGlvblxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiYgdGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25NZWRpYVNlZWtlZCgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzZWVrZWQgdG8gJyArIHRoaXMubWVkaWEuY3VycmVudFRpbWUpO1xuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR01FTlRfUExBWUlORyB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhRW5kZWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgZW5kZWQnKTtcbiAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cblxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgbG9nZ2VyLmxvZygndHJpZ2dlciBCVUZGRVJfUkVTRVQnKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9SRVNFVCk7XG4gICAgdGhpcy5idWZmZXJSYW5nZSA9IFtdO1xuICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQoZGF0YSkge1xuICAgIHZhciBhYWMgPSBmYWxzZSwgaGVhYWMgPSBmYWxzZSwgY29kZWM7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAvLyBkZXRlY3QgaWYgd2UgaGF2ZSBkaWZmZXJlbnQga2luZCBvZiBhdWRpbyBjb2RlY3MgdXNlZCBhbW9uZ3N0IHBsYXlsaXN0c1xuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEpIHtcbiAgICAgICAgICBhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBoZWFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSAoYWFjICYmIGhlYWFjKTtcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICBsb2dnZXIubG9nKCdib3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydExldmVsTG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxMb2FkZWQoZGF0YSkge1xuICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgICBuZXdMZXZlbElkID0gZGF0YS5sZXZlbCxcbiAgICAgICAgY3VyTGV2ZWwgPSB0aGlzLmxldmVsc1tuZXdMZXZlbElkXSxcbiAgICAgICAgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgIHNsaWRpbmcgPSAwO1xuXG4gICAgbG9nZ2VyLmxvZyhgbGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbmV3TGV2ZWxJZDtcblxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIHZhciBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgIGlmIChjdXJEZXRhaWxzKSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLG5ld0RldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIGZpcnN0IGxvYWQsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cbiAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1VQREFURUQsIHsgZGV0YWlsczogbmV3RGV0YWlscywgbGV2ZWw6IG5ld0xldmVsSWQgfSk7XG5cbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPT09IGZhbHNlKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBuZWdhdGl2ZSBzdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0sIGNvdW50IGZyb20gZW5kIG9mIGxhc3QgZnJhZ21lbnRgKTtcbiAgICAgICAgICAgIHN0YXJ0VGltZU9mZnNldCA9IHNsaWRpbmcgKyBkdXJhdGlvbiArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBzZXQgc3RhcnQgcG9zaXRpb24gdG8gYmUgZnJhZ21lbnQgTi10aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKHVzdWFsbHkgMylcbiAgICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgbmV3RGV0YWlscyk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBjb25maWd1cmUgc3RhcnRQb3NpdGlvbiB0byAke3RoaXMuc3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmZyYWcudHlwZSA9PT0gJ21haW4nICYmXG4gICAgICAgIGRhdGEuZnJhZy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgZGF0YS5mcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGVkICAke2ZyYWdDdXJyZW50LnNufSBvZiBsZXZlbCAke2ZyYWdDdXJyZW50LmxldmVsfWApO1xuICAgICAgaWYgKHRoaXMuZnJhZ0JpdHJhdGVUZXN0ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgLi4uIHdlIGp1c3QgbG9hZGVkIGEgZnJhZ21lbnQgdG8gZGV0ZXJtaW5lIGFkZXF1YXRlIHN0YXJ0IGJpdHJhdGUgYW5kIGluaXRpYWxpemUgYXV0b3N3aXRjaCBhbGdvXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmZyYWdCaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBkYXRhLnN0YXRzLnRwYXJzZWQgPSBkYXRhLnN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHtzdGF0czogZGF0YS5zdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkIDogJ21haW4nfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLFxuICAgICAgICAgICAgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydCA9IGZyYWdDdXJyZW50LnN0YXJ0RFRTICE9PSB1bmRlZmluZWQgPyBmcmFnQ3VycmVudC5zdGFydERUUyAgOiBmcmFnQ3VycmVudC5zdGFydCxcbiAgICAgICAgICAgIGxldmVsID0gZnJhZ0N1cnJlbnQubGV2ZWwsXG4gICAgICAgICAgICBzbiA9IGZyYWdDdXJyZW50LnNuLFxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgICBpZih0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICBpZihhdWRpb0NvZGVjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmxhc3RBdWRpb0NvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICBpZihhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PS0xKSB7XG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nQXBwZW5kaW5nID0gMDtcbiAgICAgICAgbG9nZ2VyLmxvZyhgRGVtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH0sIGNjICR7ZnJhZ0N1cnJlbnQuY2N9YCk7XG4gICAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgICBpZiAoIWRlbXV4ZXIpIHtcbiAgICAgICAgICBkZW11eGVyID0gdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsJ21haW4nKTtcbiAgICAgICAgfVxuICAgICAgICBkZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBhdWRpb0NvZGVjLCBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYywgc3RhcnQsIGZyYWdDdXJyZW50LmNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLCBmcmFnQ3VycmVudC5kZWNyeXB0ZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrTmFtZSwgdHJhY2s7XG5cbiAgICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxuICAgICAgaWYgKHRyYWNrcy5hdWRpbyAmJiB0aGlzLmF1ZGlvVHJhY2tUeXBlID09PSAnQVVESU8nKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgICB9XG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZih0cmFjaykge1xuICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYoYXVkaW9Db2RlYyAmJiB0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICBpZihhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PS0xKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBBQUMgYW5kIEhFLUFBQyBhdWRpbyBjb2RlY3MgYXJlIHNpZ25hbGxlZCBpbiBtYW5pZmVzdFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMgLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyB0aGF0IHdheSxcbiAgICAgICAgLy8gZXhjZXB0IGZvciBtb25vIHN0cmVhbXMgT1Igb24gRkZcbiAgICAgICAgLy8gdGhlc2UgY29uZGl0aW9ucyBtaWdodCBuZWVkIHRvIGJlIHJldmlld2VkIC4uLlxuICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW1cbiAgICAgICAgICAgaWYodHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmXG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgZmlyZWZveFxuICAgICAgICAgICAgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgICAgaWYodWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICBsb2dnZXIubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0b2AgKyBhdWRpb0NvZGVjKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgfVxuICAgICAgdHJhY2sgPSB0cmFja3MudmlkZW87XG4gICAgICBpZih0cmFjaykge1xuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0udmlkZW9Db2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiByZW11eGVyIHNwZWNpZnkgdGhhdCBhIHVuaXF1ZSB0cmFjayBuZWVkcyB0byBnZW5lcmF0ZWQsXG4gICAgICAvLyBsZXQncyBtZXJnZSBhbGwgdHJhY2tzIHRvZ2V0aGVyXG4gICAgICBpZiAoZGF0YS51bmlxdWUpIHtcbiAgICAgICAgdmFyIG1lcmdlZFRyYWNrID0ge1xuICAgICAgICAgICAgY29kZWMgOiAnJyxcbiAgICAgICAgICAgIGxldmVsQ29kZWMgOiAnJ1xuICAgICAgICAgIH07XG4gICAgICAgIGZvciAodHJhY2tOYW1lIGluIGRhdGEudHJhY2tzKSB7XG4gICAgICAgICAgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgICBtZXJnZWRUcmFjay5jb250YWluZXIgPSB0cmFjay5jb250YWluZXI7XG4gICAgICAgICAgaWYgKG1lcmdlZFRyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5jb2RlYyArPSAgJywnO1xuICAgICAgICAgICAgbWVyZ2VkVHJhY2subGV2ZWxDb2RlYyArPSAgJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0cmFjay5jb2RlYykge1xuICAgICAgICAgICAgbWVyZ2VkVHJhY2suY29kZWMgKz0gIHRyYWNrLmNvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2subGV2ZWxDb2RlYykge1xuICAgICAgICAgICAgbWVyZ2VkVHJhY2subGV2ZWxDb2RlYyArPSAgdHJhY2subGV2ZWxDb2RlYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tzID0geyBhdWRpb3ZpZGVvIDogbWVyZ2VkVHJhY2sgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NPREVDUyx0cmFja3MpO1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXG4gICAgICBmb3IgKHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgICAgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbWFpbiB0cmFjazoke3RyYWNrTmFtZX0sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcbiAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZysrO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywge3R5cGU6IHRyYWNrTmFtZSwgZGF0YTogaW5pdFNlZ21lbnQsIHBhcmVudCA6ICdtYWluJywgY29udGVudCA6ICdpbml0U2VnbWVudCd9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YShkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGRhdGEuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGRhdGEubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIChkYXRhLnR5cGUgIT09ICdhdWRpbycgfHwgdGhpcy5hdWRpb1RyYWNrVHlwZSAhPT0gJ0FVRElPJykgJiYgLy8gZmlsdGVyIG91dCBtYWluIGF1ZGlvIGlmIGF1ZGlvIHRyYWNrIGlzIGxvYWRlZCB0aHJvdWdoIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLFxuICAgICAgICAgIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuXG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn0sZHJvcHBlZDoke2RhdGEuZHJvcHBlZCB8fCAwfWApO1xuXG4gICAgICB2YXIgZHJpZnQgPSBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKGxldmVsLmRldGFpbHMsZnJhZy5zbixkYXRhLnN0YXJ0UFRTLGRhdGEuZW5kUFRTLGRhdGEuc3RhcnREVFMsZGF0YS5lbmREVFMpLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfUFRTX1VQREFURUQsIHtkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLCBsZXZlbDogdGhpcy5sZXZlbCwgZHJpZnQ6IGRyaWZ0fSk7XG5cbiAgICAgIC8vIGhhcyByZW11eGVyIGRyb3BwZWQgdmlkZW8gZnJhbWVzIGxvY2F0ZWQgYmVmb3JlIGZpcnN0IGtleWZyYW1lID9cbiAgICAgIGlmKGRhdGEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICBmcmFnLmRyb3BwZWQgPSBkYXRhLmRyb3BwZWQ7XG4gICAgICB9XG5cbiAgICAgIFtkYXRhLmRhdGExLCBkYXRhLmRhdGEyXS5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmcrKztcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudCA6ICdtYWluJyxjb250ZW50IDogJ2RhdGEnfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLmVuZFBUUztcbiAgICAgIHRoaXMuYnVmZmVyUmFuZ2UucHVzaCh7dHlwZTogZGF0YS50eXBlLCBzdGFydDogZGF0YS5zdGFydFBUUywgZW5kOiBkYXRhLmVuZFBUUywgZnJhZzogZnJhZ30pO1xuXG4gICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNlZChkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGRhdGEuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGRhdGEubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2goZGF0YSkge1xuICAgIHZhciBhdWRpb1RyYWNrVHlwZSA9IGRhdGEudHlwZTtcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgaWYgKGF1ZGlvVHJhY2tUeXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy52aWRlb0J1ZmZlcikge1xuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmF1ZGlvVHJhY2tUeXBlID0gYXVkaW9UcmFja1R5cGU7XG4gIH1cblxuXG4gIG9uQnVmZmVyQ3JlYXRlZChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCBtZWRpYVRyYWNrLCBuYW1lLCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IodmFyIHR5cGUgaW4gdHJhY2tzKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHRyYWNrc1t0eXBlXS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgbG9nZ2VyLmxvZyhgYWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgJHtuYW1lfS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRlZChkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZy0tO1xuICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCgpIHtcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmIHRoaXMucGVuZGluZ0FwcGVuZGluZyA9PT0gMCkgIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhpcy5mcmFnTGFzdEticHNcbiAgICAgICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50Zmlyc3QpKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZCA6ICdtYWluJ30pO1xuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIG1haW4gZnJhZ21lbnRcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2goZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICB2YXIgbG9hZEVycm9yID0gdGhpcy5mcmFnTG9hZEVycm9yO1xuICAgICAgICAgIGlmKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgbG9hZEVycm9yKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcj0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkgfHxcbiAgICAgICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgLyBkb24ndCByYWlzZSBmYXRhbCBuZXR3b3JrIGVycm9yIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgICAgICh0aGlzLm1lZGlhICYmIHRoaXMuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGxvYWRFcnJvcjtcbiAgICAgICAgICAgIC8vIHJlc2V0IGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvclxuICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDA7XG4gICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byA2NHNcbiAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsbG9hZEVycm9yLTEpKnRoaXMuY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSw2NDAwMCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbWVkaWFDb250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xuICAgICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYG1lZGlhQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xuICAgICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgICBpZih0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5mYXRhbCA/IFN0YXRlLkVSUk9SIDogU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBtZWRpYUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSB3aGlsZSBsb2FkaW5nIGZyYWcsc3dpdGNoIHRvICR7dGhpcy5zdGF0ZX0gc3RhdGUgLi4uYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgLy8gb25seSByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgICAgICB0aGlzLmNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgvPTI7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke3RoaXMuY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zIGFuZCBzd2l0Y2ggdG8gSURMRSBzdGF0ZWApO1xuICAgICAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbl9jaGVja0J1ZmZlcigpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yLCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHZhciBpc1NhZmFyaSA9IHZlbmRvciAmJiB2ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+IC0xICYmIHVzZXJBZ2VudCAmJiAhdXNlckFnZW50Lm1hdGNoKCdDcmlPUycpO1xuICAgIC8vIGlmIHJlYWR5IHN0YXRlIGRpZmZlcmVudCBmcm9tIEhBVkVfTk9USElORyAobnVtZXJpYyB2YWx1ZSAwKSwgd2UgYXJlIGFsbG93ZWQgdG8gc2Vla1xuICAgIGlmKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgICAgICAgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcbiAgICAgIC8vIGFkanVzdCBjdXJyZW50VGltZSB0byBzdGFydCBwb3NpdGlvbiBvbiBsb2FkZWQgbWV0YWRhdGFcbiAgICAgIGlmKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgICAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgICAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25CdWZmZXJlZCA9IHRoaXMuaXNCdWZmZXJlZChzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgLy8gaWYgY3VycmVudFRpbWUgbm90IG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgc3RhcnRQb3NpdGlvbiBvciBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgICAgICBpZiAoY3VycmVudFRpbWUgIT09IHN0YXJ0UG9zaXRpb24gfHwgIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHRhcmdldCBzdGFydCBwb3NpdGlvbjoke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWQsIGxldCdzIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMClcbiAgICAgICAgICBpZighc3RhcnRQb3NpdGlvbkJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gYnVmZmVyZWQuc3RhcnQoMCk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGB0YXJnZXQgc3RhcnQgcG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgYWRqdXN0IGN1cnJlbnRUaW1lIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHtzdGFydFBvc2l0aW9ufWApO1xuICAgICAgICAgIC8vIHJlYWR5U3RhdGUgPD0gMiBjYW4gbm90IHN1Y2Nlc3NmdWxseSBzZWVrIGluIHNhZmFyaVxuICAgICAgICAgIGlmICghaXNTYWZhcmkgfHwgbWVkaWEucmVhZHlTdGF0ZSA+IDIpIHtcbiAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsY3VycmVudFRpbWUsMCksXG4gICAgICAgICAgICBleHBlY3RlZFBsYXlpbmcgPSAhKG1lZGlhLnBhdXNlZCB8fCAvLyBub3QgcGxheWluZyB3aGVuIG1lZGlhIGlzIHBhdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5lbmRlZCAgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBlbmRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5idWZmZXJlZC5sZW5ndGggPT09IDApLCAvLyBub3QgcGxheWluZyBpZiBub3RoaW5nIGJ1ZmZlcmVkXG4gICAgICAgICAgICBqdW1wVGhyZXNob2xkID0gMC40LCAvLyB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCByYW5nZSBlbmRcbiAgICAgICAgICAgIHBsYXloZWFkTW92aW5nID0gY3VycmVudFRpbWUgPiBtZWRpYS5wbGF5YmFja1JhdGUqdGhpcy5sYXN0Q3VycmVudFRpbWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhbGxlZCAmJiBwbGF5aGVhZE1vdmluZykge1xuICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGJ1ZmZlciB1cGZyb250XG4gICAgICAgIC8vIGlmIGxlc3MgdGhhbiBqdW1wVGhyZXNob2xkIHNlY29uZCBpcyBidWZmZXJlZCwgbGV0J3MgY2hlY2sgaW4gbW9yZSBkZXRhaWxzXG4gICAgICAgIGlmKGV4cGVjdGVkUGxheWluZyAmJiBidWZmZXJJbmZvLmxlbiA8PSBqdW1wVGhyZXNob2xkKSB7XG4gICAgICAgICAgaWYocGxheWhlYWRNb3ZpbmcpIHtcbiAgICAgICAgICAgIC8vIHBsYXloZWFkIG1vdmluZ1xuICAgICAgICAgICAganVtcFRocmVzaG9sZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBsYXloZWFkIG5vdCBtb3ZpbmcgQU5EIG1lZGlhIGV4cGVjdGVkIHRvIHBsYXlcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBwbGF5YmFjayBzZWVtcyBzdHVjayBAJHtjdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUiwgZmF0YWw6IGZhbHNlfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiArPSB0aGlzLmNvbmZpZy5zZWVrSG9sZU51ZGdlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHdlIGFyZSBiZWxvdyB0aHJlc2hvbGQsIHRyeSB0byBqdW1wIHRvIHN0YXJ0IG9mIG5leHQgYnVmZmVyIHJhbmdlIGlmIGNsb3NlXG4gICAgICAgICAgaWYoYnVmZmVySW5mby5sZW4gPD0ganVtcFRocmVzaG9sZCkge1xuICAgICAgICAgICAgLy8gbm8gYnVmZmVyIGF2YWlsYWJsZSBAIGN1cnJlbnRUaW1lLCBjaGVjayBpZiBuZXh0IGJ1ZmZlciBpcyBjbG9zZSAod2l0aGluIGEgY29uZmlnLm1heFNlZWtIb2xlIHNlY29uZCByYW5nZSlcbiAgICAgICAgICAgIHZhciBuZXh0QnVmZmVyU3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCwgZGVsdGEgPSBuZXh0QnVmZmVyU3RhcnQtY3VycmVudFRpbWU7XG4gICAgICAgICAgICBpZihuZXh0QnVmZmVyU3RhcnQgJiZcbiAgICAgICAgICAgICAgIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heFNlZWtIb2xlKSAmJlxuICAgICAgICAgICAgICAgKGRlbHRhID4gMCkpIHtcbiAgICAgICAgICAgICAgLy8gbmV4dCBidWZmZXIgaXMgY2xvc2UgISBhZGp1c3QgY3VycmVudFRpbWUgdG8gbmV4dEJ1ZmZlclN0YXJ0XG4gICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBlbnN1cmUgZWZmZWN0aXZlIHZpZGVvIGRlY29kaW5nXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7bWVkaWEuY3VycmVudFRpbWV9IHRvIG5leHQgYnVmZmVyZWQgQCAke25leHRCdWZmZXJTdGFydH0gKyBudWRnZSAke3RoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9ufWApO1xuICAgICAgICAgICAgICBsZXQgaG9sZSA9IG5leHRCdWZmZXJTdGFydCArIHRoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9uIC0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgIC8vIGZyZXF1ZW50bHkgc2Vla2luZyBtYXkgY2F1c2UgZnJlcXVlbnRseSBmbGlja2VyIGluIHNhZmFyaVxuICAgICAgICAgICAgICBpZiAoIWlzU2FmYXJpIHx8ICh0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiAmJiB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiAlICgxMCAqIHRoaXMuY29uZmlnLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbikgPCB0aGlzLmNvbmZpZy5zZWVrSG9sZU51ZGdlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyU3RhcnQgKyB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSwgZmF0YWw6IGZhbHNlLCBob2xlIDogaG9sZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25CdWZmZXJGbHVzaGVkKCkge1xuICAgIC8qIGFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCByZWJ1aWxkIGJ1ZmZlciBSYW5nZSBhcnJheVxuICAgICAgbG9vcCB0aHJvdWdoIGV4aXN0aW5nIGJ1ZmZlciByYW5nZSBhbmQgY2hlY2sgaWZcbiAgICAgIGNvcnJlc3BvbmRpbmcgcmFuZ2UgaXMgc3RpbGwgYnVmZmVyZWQuIG9ubHkgcHVzaCB0byBuZXcgYXJyYXkgYWxyZWFkeSBidWZmZXJlZCByYW5nZVxuICAgICovXG4gICAgdmFyIG5ld1JhbmdlID0gW10scmFuZ2UsaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5idWZmZXJSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgcmFuZ2UgPSB0aGlzLmJ1ZmZlclJhbmdlW2ldO1xuICAgICAgaWYgKHRoaXMuaXNCdWZmZXJlZCgocmFuZ2Uuc3RhcnQgKyByYW5nZS5lbmQpIC8gMikpIHtcbiAgICAgICAgbmV3UmFuZ2UucHVzaChyYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyUmFuZ2UgPSBuZXdSYW5nZTtcblxuICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gIH1cblxuICBjb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xuICAgIGxldCB0YXJnZXRMYXRlbmN5ID0gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA6IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICByZXR1cm4gc2xpZGluZyArIE1hdGgubWF4KDAsIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC0gdGFyZ2V0TGF0ZW5jeSk7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIHNldCBsaXZlU3luY1Bvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbiA9IHZhbHVlO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBTdHJlYW1Db250cm9sbGVyO1xuXG4iLCIvKlxuICogVGltZWxpbmUgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IENlYTYwOFBhcnNlciBmcm9tICcuLi91dGlscy9jZWEtNjA4LXBhcnNlcic7XG5cbmNsYXNzIFRpbWVsaW5lQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXG4gICAgICAgICAgICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSxcbiAgICAgICAgICAgICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgICAgICAgICAgIEV2ZW50LkxFVkVMX1NXSVRDSCk7XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpXG4gICAge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hhbm5lbDEgPVxuICAgICAge1xuICAgICAgICAnbmV3Q3VlJzogZnVuY3Rpb24oc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnRleHRUcmFjazEgPSBzZWxmLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCAnVW5rbm93biBDQzEnLCAnZW4nKTtcbi8vICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2sxLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5DdWVzLm5ld0N1ZShzZWxmLnRleHRUcmFjazEsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGNoYW5uZWwyID1cbiAgICAgIHtcbiAgICAgICAgJ25ld0N1ZSc6IGZ1bmN0aW9uKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFzZWxmLnRleHRUcmFjazIpXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2syID0gc2VsZi5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgJ1Vua25vd24gQ0MyJywgJ2VzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5DdWVzLm5ld0N1ZShzZWxmLnRleHRUcmFjazIsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTsgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyID0gbmV3IENlYTYwOFBhcnNlcigwLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyQ3VycmVudEN1ZXModHJhY2spXG4gIHtcbiAgICBpZiAodHJhY2sgJiYgdHJhY2suY3VlcylcbiAgICB7XG4gICAgICB3aGlsZSAodHJhY2suY3Vlcy5sZW5ndGggPiAwKVxuICAgICAge1xuICAgICAgICB0cmFjay5yZW1vdmVDdWUodHJhY2suY3Vlc1swXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKVxuICB7XG4gICAgaWYgKHRoaXMubWVkaWEpXG4gICAge1xuICAgICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcoKVxuICB7XG4gICAgdGhpcy5sYXN0UHRzID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgb25MZXZlbFN3aXRjaCgpXG4gIHtcbiAgICBpZiAodGhpcy5obHMuY3VycmVudExldmVsLmNsb3NlZENhcHRpb25zID09PSAnTk9ORScpXG4gICAge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKVxuICB7XG4gICAgaWYgKGRhdGEuZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIHZhciBwdHMgPSBkYXRhLmZyYWcuc3RhcnQ7IC8vTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgLy8gaWYgdGhpcyBpcyBhIGZyYWcgZm9yIGEgcHJldmlvdXNseSBsb2FkZWQgdGltZXJhbmdlLCByZW1vdmUgYWxsIGNhcHRpb25zXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBqdXN0IHJlbW92aW5nIGNhcHRpb25zIGZvciB0aGUgdGltZXJhbmdlXG4gICAgICBpZiAocHRzIDw9IHRoaXMubGFzdFB0cylcbiAgICAgIHtcbiAgICAgIHRoaXMuY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazEpO1xuICAgICAgdGhpcy5jbGVhckN1cnJlbnRDdWVzKHRoaXMudGV4dFRyYWNrMik7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RQdHMgPSBwdHM7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhKGRhdGEpIHtcbiAgICAvLyBwdXNoIGFsbCBvZiB0aGUgQ0VBLTcwOCBtZXNzYWdlcyBpbnRvIHRoZSBpbnRlcnByZXRlclxuICAgIC8vIGltbWVkaWF0ZWx5LiBJdCB3aWxsIGNyZWF0ZSB0aGUgcHJvcGVyIHRpbWVzdGFtcHMgYmFzZWQgb24gb3VyIFBUUyB2YWx1ZVxuICAgIGlmICh0aGlzLmVuYWJsZWQpXG4gICAge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGRhdGEuc2FtcGxlcy5sZW5ndGg7IGkrKylcbiAgICAgIHtcbiAgICAgICAgdmFyIGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGRhdGEuc2FtcGxlc1tpXS5ieXRlcyk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXh0cmFjdENlYTYwOERhdGEoYnl0ZUFycmF5KVxuICB7XG4gICAgdmFyIGNvdW50ID0gYnl0ZUFycmF5WzBdICYgMzE7XG4gICAgdmFyIHBvc2l0aW9uID0gMjtcbiAgICB2YXIgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xuICAgIHZhciBhY3R1YWxDQ0J5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUxID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgPT09IDAgPyBmYWxzZSA6IHRydWU7XG4gICAgICBjY1R5cGUgPSAzICYgdG1wQnl0ZTtcblxuICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgLy8gfHwgY2NUeXBlID09PSAxXG4gICAgICAgIHtcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQ29udHJvbGxlcjtcbiIsIi8qXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGFuIGFkYXB0YXRpb24gb2YgdGhlIEFFUyBkZWNyeXB0aW9uIGFsZ29yaXRobVxuICogZnJvbSB0aGUgU3RhbmRmb3JkIEphdmFzY3JpcHQgQ3J5cHRvZ3JhcGh5IExpYnJhcnkuIFRoYXQgd29yayBpc1xuICogY292ZXJlZCBieSB0aGUgZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgcGVybWlzc2lvbnMgbm90aWNlOlxuICpcbiAqIENvcHlyaWdodCAyMDA5LTIwMTAgRW1pbHkgU3RhcmssIE1pa2UgSGFtYnVyZywgRGFuIEJvbmVoLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1JcbiAqIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gKiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG4gKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gKiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb25cbiAqIGFyZSB0aG9zZSBvZiB0aGUgYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmdcbiAqIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkIG9yIGltcGxpZWQsIG9mIHRoZSBhdXRob3JzLlxuICovXG5jbGFzcyBBRVMge1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZSBvdXQgYW4gQUVTIGtleSBmb3IgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLiBUaGlzXG4gICAqIGlzIGEgbG93LWxldmVsIGNsYXNzLiBVc2UgYSBjaXBoZXIgbW9kZSB0byBkbyBidWxrIGVuY3J5cHRpb24uXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ga2V5IHtBcnJheX0gVGhlIGtleSBhcyBhbiBhcnJheSBvZiA0LCA2IG9yIDggd29yZHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZXhwYW5kZWQgUy1ib3ggYW5kIGludmVyc2UgUy1ib3ggdGFibGVzLiBUaGVzZSB3aWxsIGJlIGNvbXB1dGVkXG4gICAgICogb24gdGhlIGNsaWVudCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gc2VuZCB0aGVtIGRvd24gdGhlIHdpcmUuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHRhYmxlcywgX3RhYmxlc1swXSBpcyBmb3IgZW5jcnlwdGlvbiBhbmRcbiAgICAgKiBfdGFibGVzWzFdIGlzIGZvciBkZWNyeXB0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IDQgc3ViLXRhYmxlcyBhcmUgdGhlIGV4cGFuZGVkIFMtYm94IHdpdGggTWl4Q29sdW1ucy4gVGhlXG4gICAgICogbGFzdCAoX3RhYmxlc1swMV1bNF0pIGlzIHRoZSBTLWJveCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RhYmxlcyA9IFtbW10sW10sW10sW10sW11dLFtbXSxbXSxbXSxbXSxbXV1dO1xuXG4gICAgdGhpcy5fcHJlY29tcHV0ZSgpO1xuXG4gICAgdmFyIGksIGosIHRtcCxcbiAgICBlbmNLZXksIGRlY0tleSxcbiAgICBzYm94ID0gdGhpcy5fdGFibGVzWzBdWzRdLCBkZWNUYWJsZSA9IHRoaXMuX3RhYmxlc1sxXSxcbiAgICBrZXlMZW4gPSBrZXkubGVuZ3RoLCByY29uID0gMTtcblxuICAgIGlmIChrZXlMZW4gIT09IDQgJiYga2V5TGVuICE9PSA2ICYmIGtleUxlbiAhPT0gOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5TGVuKTtcbiAgICB9XG5cbiAgICBlbmNLZXkgPSBrZXkuc2xpY2UoMCk7XG4gICAgZGVjS2V5ID0gW107XG4gICAgdGhpcy5fa2V5ID0gW2VuY0tleSwgZGVjS2V5XTtcblxuICAgIC8vIHNjaGVkdWxlIGVuY3J5cHRpb24ga2V5c1xuICAgIGZvciAoaSA9IGtleUxlbjsgaSA8IDQgKiBrZXlMZW4gKyAyODsgaSsrKSB7XG4gICAgICB0bXAgPSBlbmNLZXlbaS0xXTtcblxuICAgICAgLy8gYXBwbHkgc2JveFxuICAgICAgaWYgKGkla2V5TGVuID09PSAwIHx8IChrZXlMZW4gPT09IDggJiYgaSVrZXlMZW4gPT09IDQpKSB7XG4gICAgICAgIHRtcCA9IHNib3hbdG1wPj4+MjRdPDwyNCBeIHNib3hbdG1wPj4xNiYyNTVdPDwxNiBeIHNib3hbdG1wPj44JjI1NV08PDggXiBzYm94W3RtcCYyNTVdO1xuXG4gICAgICAgIC8vIHNoaWZ0IHJvd3MgYW5kIGFkZCByY29uXG4gICAgICAgIGlmIChpJWtleUxlbiA9PT0gMCkge1xuICAgICAgICAgIHRtcCA9IHRtcDw8OCBeIHRtcD4+PjI0IF4gcmNvbjw8MjQ7XG4gICAgICAgICAgcmNvbiA9IHJjb248PDEgXiAocmNvbj4+NykqMjgzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuY0tleVtpXSA9IGVuY0tleVtpLWtleUxlbl0gXiB0bXA7XG4gICAgfVxuXG4gICAgLy8gc2NoZWR1bGUgZGVjcnlwdGlvbiBrZXlzXG4gICAgZm9yIChqID0gMDsgaTsgaisrLCBpLS0pIHtcbiAgICAgIHRtcCA9IGVuY0tleVtqJjMgPyBpIDogaSAtIDRdO1xuICAgICAgaWYgKGk8PTQgfHwgajw0KSB7XG4gICAgICAgIGRlY0tleVtqXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY0tleVtqXSA9IGRlY1RhYmxlWzBdW3Nib3hbdG1wPj4+MjQgICAgICBdXSBeXG4gICAgICAgICAgZGVjVGFibGVbMV1bc2JveFt0bXA+PjE2ICAmIDI1NV1dIF5cbiAgICAgICAgICBkZWNUYWJsZVsyXVtzYm94W3RtcD4+OCAgICYgMjU1XV0gXlxuICAgICAgICAgIGRlY1RhYmxlWzNdW3Nib3hbdG1wICAgICAgJiAyNTVdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhwYW5kIHRoZSBTLWJveCB0YWJsZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlY29tcHV0ZSgpIHtcbiAgICB2YXIgZW5jVGFibGUgPSB0aGlzLl90YWJsZXNbMF0sIGRlY1RhYmxlID0gdGhpcy5fdGFibGVzWzFdLFxuICAgIHNib3ggPSBlbmNUYWJsZVs0XSwgc2JveEludiA9IGRlY1RhYmxlWzRdLFxuICAgIGksIHgsIHhJbnYsIGQ9W10sIHRoPVtdLCB4MiwgeDQsIHg4LCBzLCB0RW5jLCB0RGVjO1xuXG4gICAgLy8gQ29tcHV0ZSBkb3VibGUgYW5kIHRoaXJkIHRhYmxlc1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgdGhbKCBkW2ldID0gaTw8MSBeIChpPj43KSoyODMgKV5pXT1pO1xuICAgIH1cblxuICAgIGZvciAoeCA9IHhJbnYgPSAwOyAhc2JveFt4XTsgeCBePSB4MiB8fCAxLCB4SW52ID0gdGhbeEludl0gfHwgMSkge1xuICAgICAgLy8gQ29tcHV0ZSBzYm94XG4gICAgICBzID0geEludiBeIHhJbnY8PDEgXiB4SW52PDwyIF4geEludjw8MyBeIHhJbnY8PDQ7XG4gICAgICBzID0gcz4+OCBeIHMmMjU1IF4gOTk7XG4gICAgICBzYm94W3hdID0gcztcbiAgICAgIHNib3hJbnZbc10gPSB4O1xuXG4gICAgICAvLyBDb21wdXRlIE1peENvbHVtbnNcbiAgICAgIHg4ID0gZFt4NCA9IGRbeDIgPSBkW3hdXV07XG4gICAgICB0RGVjID0geDgqMHgxMDEwMTAxIF4geDQqMHgxMDAwMSBeIHgyKjB4MTAxIF4geCoweDEwMTAxMDA7XG4gICAgICB0RW5jID0gZFtzXSoweDEwMSBeIHMqMHgxMDEwMTAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGVuY1RhYmxlW2ldW3hdID0gdEVuYyA9IHRFbmM8PDI0IF4gdEVuYz4+Pjg7XG4gICAgICAgIGRlY1RhYmxlW2ldW3NdID0gdERlYyA9IHREZWM8PDI0IF4gdERlYz4+Pjg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcGFjdGlmeS4gQ29uc2lkZXJhYmxlIHNwZWVkdXAgb24gRmlyZWZveC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICBlbmNUYWJsZVtpXSA9IGVuY1RhYmxlW2ldLnNsaWNlKDApO1xuICAgICAgZGVjVGFibGVbaV0gPSBkZWNUYWJsZVtpXS5zbGljZSgwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCAxNiBieXRlcywgc3BlY2lmaWVkIGFzIGZvdXIgMzItYml0IHdvcmRzLlxuICAgKiBAcGFyYW0gZW5jcnlwdGVkMCB7bnVtYmVyfSB0aGUgZmlyc3Qgd29yZCB0byBkZWNyeXB0XG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQxIHtudW1iZXJ9IHRoZSBzZWNvbmQgd29yZCB0byBkZWNyeXB0XG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQyIHtudW1iZXJ9IHRoZSB0aGlyZCB3b3JkIHRvIGRlY3J5cHRcbiAgICogQHBhcmFtIGVuY3J5cHRlZDMge251bWJlcn0gdGhlIGZvdXJ0aCB3b3JkIHRvIGRlY3J5cHRcbiAgICogQHBhcmFtIG91dCB7SW50MzJBcnJheX0gdGhlIGFycmF5IHRvIHdyaXRlIHRoZSBkZWNyeXB0ZWQgd29yZHNcbiAgICogaW50b1xuICAgKiBAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IHRoZSBvZmZzZXQgaW50byB0aGUgb3V0cHV0IGFycmF5IHRvIHN0YXJ0XG4gICAqIHdyaXRpbmcgcmVzdWx0c1xuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHBsYWludGV4dC5cbiAgICovXG4gIGRlY3J5cHQoZW5jcnlwdGVkMCwgZW5jcnlwdGVkMSwgZW5jcnlwdGVkMiwgZW5jcnlwdGVkMywgb3V0LCBvZmZzZXQpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5fa2V5WzFdLFxuICAgIC8vIHN0YXRlIHZhcmlhYmxlcyBhLGIsYyxkIGFyZSBsb2FkZWQgd2l0aCBwcmUtd2hpdGVuZWQgZGF0YVxuICAgIGEgPSBlbmNyeXB0ZWQwIF4ga2V5WzBdLFxuICAgIGIgPSBlbmNyeXB0ZWQzIF4ga2V5WzFdLFxuICAgIGMgPSBlbmNyeXB0ZWQyIF4ga2V5WzJdLFxuICAgIGQgPSBlbmNyeXB0ZWQxIF4ga2V5WzNdLFxuICAgIGEyLCBiMiwgYzIsXG5cbiAgICBuSW5uZXJSb3VuZHMgPSBrZXkubGVuZ3RoIC8gNCAtIDIsIC8vIGtleS5sZW5ndGggPT09IDIgP1xuICAgIGksXG4gICAga0luZGV4ID0gNCxcbiAgICB0YWJsZSA9IHRoaXMuX3RhYmxlc1sxXSxcblxuICAgIC8vIGxvYWQgdXAgdGhlIHRhYmxlc1xuICAgIHRhYmxlMCAgICA9IHRhYmxlWzBdLFxuICAgIHRhYmxlMSAgICA9IHRhYmxlWzFdLFxuICAgIHRhYmxlMiAgICA9IHRhYmxlWzJdLFxuICAgIHRhYmxlMyAgICA9IHRhYmxlWzNdLFxuICAgIHNib3ggID0gdGFibGVbNF07XG5cbiAgICAvLyBJbm5lciByb3VuZHMuIENyaWJiZWQgZnJvbSBPcGVuU1NMLlxuICAgIGZvciAoaSA9IDA7IGkgPCBuSW5uZXJSb3VuZHM7IGkrKykge1xuICAgICAgYTIgPSB0YWJsZTBbYT4+PjI0XSBeIHRhYmxlMVtiPj4xNiAmIDI1NV0gXiB0YWJsZTJbYz4+OCAmIDI1NV0gXiB0YWJsZTNbZCAmIDI1NV0gXiBrZXlba0luZGV4XTtcbiAgICAgIGIyID0gdGFibGUwW2I+Pj4yNF0gXiB0YWJsZTFbYz4+MTYgJiAyNTVdIF4gdGFibGUyW2Q+PjggJiAyNTVdIF4gdGFibGUzW2EgJiAyNTVdIF4ga2V5W2tJbmRleCArIDFdO1xuICAgICAgYzIgPSB0YWJsZTBbYz4+PjI0XSBeIHRhYmxlMVtkPj4xNiAmIDI1NV0gXiB0YWJsZTJbYT4+OCAmIDI1NV0gXiB0YWJsZTNbYiAmIDI1NV0gXiBrZXlba0luZGV4ICsgMl07XG4gICAgICBkICA9IHRhYmxlMFtkPj4+MjRdIF4gdGFibGUxW2E+PjE2ICYgMjU1XSBeIHRhYmxlMltiPj44ICYgMjU1XSBeIHRhYmxlM1tjICYgMjU1XSBeIGtleVtrSW5kZXggKyAzXTtcbiAgICAgIGtJbmRleCArPSA0O1xuICAgICAgYT1hMjsgYj1iMjsgYz1jMjtcbiAgICB9XG5cbiAgICAvLyBMYXN0IHJvdW5kLlxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG91dFsoMyAmIC1pKSArIG9mZnNldF0gPVxuICAgICAgICBzYm94W2E+Pj4yNCAgICAgIF08PDI0IF5cbiAgICAgICAgc2JveFtiPj4xNiAgJiAyNTVdPDwxNiBeXG4gICAgICAgIHNib3hbYz4+OCAgICYgMjU1XTw8OCAgXlxuICAgICAgICBzYm94W2QgICAgICAmIDI1NV0gICAgIF5cbiAgICAgICAga2V5W2tJbmRleCsrXTtcbiAgICAgIGEyPWE7IGE9YjsgYj1jOyBjPWQ7IGQ9YTI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFFUztcbiIsIi8qXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGFuIGFkYXB0YXRpb24gb2YgdGhlIEFFUyBkZWNyeXB0aW9uIGFsZ29yaXRobVxuICogZnJvbSB0aGUgU3RhbmRmb3JkIEphdmFzY3JpcHQgQ3J5cHRvZ3JhcGh5IExpYnJhcnkuIFRoYXQgd29yayBpc1xuICogY292ZXJlZCBieSB0aGUgZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgcGVybWlzc2lvbnMgbm90aWNlOlxuICpcbiAqIENvcHlyaWdodCAyMDA5LTIwMTAgRW1pbHkgU3RhcmssIE1pa2UgSGFtYnVyZywgRGFuIEJvbmVoLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1JcbiAqIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gKiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG4gKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gKiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb25cbiAqIGFyZSB0aG9zZSBvZiB0aGUgYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmdcbiAqIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkIG9yIGltcGxpZWQsIG9mIHRoZSBhdXRob3JzLlxuICovXG5cbmltcG9ydCBBRVMgZnJvbSAnLi9hZXMnO1xuXG5jbGFzcyBBRVMxMjhEZWNyeXB0ZXIge1xuXG4gIGNvbnN0cnVjdG9yKGtleSwgaW5pdFZlY3Rvcikge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuaXYgPSBpbml0VmVjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgbmV0d29yay1vcmRlciAoYmlnLWVuZGlhbikgYnl0ZXMgaW50byB0aGVpciBsaXR0bGUtZW5kaWFuXG4gICAqIHJlcHJlc2VudGF0aW9uLlxuICAgKi9cbiAgbnRvaCh3b3JkKSB7XG4gICAgcmV0dXJuICh3b3JkIDw8IDI0KSB8XG4gICAgICAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHxcbiAgICAgICgod29yZCAmIDB4ZmYwMDAwKSA+PiA4KSB8XG4gICAgICAod29yZCA+Pj4gMjQpO1xuICB9XG5cblxuICAvKipcbiAgICogRGVjcnlwdCBieXRlcyB1c2luZyBBRVMtMTI4IHdpdGggQ0JDIGFuZCBQS0NTIzcgcGFkZGluZy5cbiAgICogQHBhcmFtIGVuY3J5cHRlZCB7VWludDhBcnJheX0gdGhlIGVuY3J5cHRlZCBieXRlc1xuICAgKiBAcGFyYW0ga2V5IHtVaW50MzJBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBkZWNyeXB0aW9uIGtleVxuICAgKiBAcGFyYW0gaW5pdFZlY3RvciB7VWludDMyQXJyYXl9IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgKElWKSB0b1xuICAgKiB1c2UgZm9yIHRoZSBmaXJzdCByb3VuZCBvZiBDQkMuXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSBkZWNyeXB0ZWQgYnl0ZXNcbiAgICpcbiAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FkdmFuY2VkX0VuY3J5cHRpb25fU3RhbmRhcmRcbiAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jsb2NrX2NpcGhlcl9tb2RlX29mX29wZXJhdGlvbiNDaXBoZXJfQmxvY2tfQ2hhaW5pbmdfLjI4Q0JDLjI5XG4gICAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIzMTVcbiAgICovXG4gIGRvRGVjcnlwdChlbmNyeXB0ZWQsIGtleSwgaW5pdFZlY3Rvcikge1xuICAgIHZhclxuICAgICAgLy8gd29yZC1sZXZlbCBhY2Nlc3MgdG8gdGhlIGVuY3J5cHRlZCBieXRlc1xuICAgICAgZW5jcnlwdGVkMzIgPSBuZXcgSW50MzJBcnJheShlbmNyeXB0ZWQuYnVmZmVyLCBlbmNyeXB0ZWQuYnl0ZU9mZnNldCwgZW5jcnlwdGVkLmJ5dGVMZW5ndGggPj4gMiksXG5cbiAgICBkZWNpcGhlciA9IG5ldyBBRVMoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoa2V5KSksXG5cbiAgICAvLyBieXRlIGFuZCB3b3JkLWxldmVsIGFjY2VzcyBmb3IgdGhlIGRlY3J5cHRlZCBvdXRwdXRcbiAgICBkZWNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQuYnl0ZUxlbmd0aCksXG4gICAgZGVjcnlwdGVkMzIgPSBuZXcgSW50MzJBcnJheShkZWNyeXB0ZWQuYnVmZmVyKSxcblxuICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZXMgZm9yIHdvcmtpbmcgd2l0aCB0aGUgSVYsIGVuY3J5cHRlZCwgYW5kXG4gICAgLy8gZGVjcnlwdGVkIGRhdGFcbiAgICBpbml0MCwgaW5pdDEsIGluaXQyLCBpbml0MyxcbiAgICBlbmNyeXB0ZWQwLCBlbmNyeXB0ZWQxLCBlbmNyeXB0ZWQyLCBlbmNyeXB0ZWQzLFxuXG4gICAgLy8gaXRlcmF0aW9uIHZhcmlhYmxlXG4gICAgd29yZEl4O1xuXG4gICAgLy8gcHVsbCBvdXQgdGhlIHdvcmRzIG9mIHRoZSBJViB0byBlbnN1cmUgd2UgZG9uJ3QgbW9kaWZ5IHRoZVxuICAgIC8vIHBhc3NlZC1pbiByZWZlcmVuY2UgYW5kIGVhc2llciBhY2Nlc3NcbiAgICBpbml0MCA9IH5+aW5pdFZlY3RvclswXTtcbiAgICBpbml0MSA9IH5+aW5pdFZlY3RvclsxXTtcbiAgICBpbml0MiA9IH5+aW5pdFZlY3RvclsyXTtcbiAgICBpbml0MyA9IH5+aW5pdFZlY3RvclszXTtcblxuICAgIC8vIGRlY3J5cHQgZm91ciB3b3JkIHNlcXVlbmNlcywgYXBwbHlpbmcgY2lwaGVyLWJsb2NrIGNoYWluaW5nIChDQkMpXG4gICAgLy8gdG8gZWFjaCBkZWNyeXB0ZWQgYmxvY2tcbiAgICBmb3IgKHdvcmRJeCA9IDA7IHdvcmRJeCA8IGVuY3J5cHRlZDMyLmxlbmd0aDsgd29yZEl4ICs9IDQpIHtcbiAgICAgIC8vIGNvbnZlcnQgYmlnLWVuZGlhbiAobmV0d29yayBvcmRlcikgd29yZHMgaW50byBsaXR0bGUtZW5kaWFuXG4gICAgICAvLyAoamF2YXNjcmlwdCBvcmRlcilcbiAgICAgIGVuY3J5cHRlZDAgPSB+fnRoaXMubnRvaChlbmNyeXB0ZWQzMlt3b3JkSXhdKTtcbiAgICAgIGVuY3J5cHRlZDEgPSB+fnRoaXMubnRvaChlbmNyeXB0ZWQzMlt3b3JkSXggKyAxXSk7XG4gICAgICBlbmNyeXB0ZWQyID0gfn50aGlzLm50b2goZW5jcnlwdGVkMzJbd29yZEl4ICsgMl0pO1xuICAgICAgZW5jcnlwdGVkMyA9IH5+dGhpcy5udG9oKGVuY3J5cHRlZDMyW3dvcmRJeCArIDNdKTtcblxuICAgICAgLy8gZGVjcnlwdCB0aGUgYmxvY2tcbiAgICAgIGRlY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkMCxcbiAgICAgICAgICBlbmNyeXB0ZWQxLFxuICAgICAgICAgIGVuY3J5cHRlZDIsXG4gICAgICAgICAgZW5jcnlwdGVkMyxcbiAgICAgICAgICBkZWNyeXB0ZWQzMixcbiAgICAgICAgICB3b3JkSXgpO1xuXG4gICAgICAvLyBYT1Igd2l0aCB0aGUgSVYsIGFuZCByZXN0b3JlIG5ldHdvcmsgYnl0ZS1vcmRlciB0byBvYnRhaW4gdGhlXG4gICAgICAvLyBwbGFpbnRleHRcbiAgICAgIGRlY3J5cHRlZDMyW3dvcmRJeF0gICAgID0gdGhpcy5udG9oKGRlY3J5cHRlZDMyW3dvcmRJeF0gXiBpbml0MCk7XG4gICAgICBkZWNyeXB0ZWQzMlt3b3JkSXggKyAxXSA9IHRoaXMubnRvaChkZWNyeXB0ZWQzMlt3b3JkSXggKyAxXSBeIGluaXQxKTtcbiAgICAgIGRlY3J5cHRlZDMyW3dvcmRJeCArIDJdID0gdGhpcy5udG9oKGRlY3J5cHRlZDMyW3dvcmRJeCArIDJdIF4gaW5pdDIpO1xuICAgICAgZGVjcnlwdGVkMzJbd29yZEl4ICsgM10gPSB0aGlzLm50b2goZGVjcnlwdGVkMzJbd29yZEl4ICsgM10gXiBpbml0Myk7XG5cbiAgICAgIC8vIHNldHVwIHRoZSBJViBmb3IgdGhlIG5leHQgcm91bmRcbiAgICAgIGluaXQwID0gZW5jcnlwdGVkMDtcbiAgICAgIGluaXQxID0gZW5jcnlwdGVkMTtcbiAgICAgIGluaXQyID0gZW5jcnlwdGVkMjtcbiAgICAgIGluaXQzID0gZW5jcnlwdGVkMztcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjcnlwdGVkO1xuICB9XG5cbiAgbG9jYWxEZWNyeXB0KGVuY3J5cHRlZCwga2V5LCBpbml0VmVjdG9yLCBkZWNyeXB0ZWQpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmRvRGVjcnlwdChlbmNyeXB0ZWQsXG4gICAgICAgIGtleSxcbiAgICAgICAgaW5pdFZlY3Rvcik7XG4gICAgZGVjcnlwdGVkLnNldChieXRlcywgZW5jcnlwdGVkLmJ5dGVPZmZzZXQpO1xuICB9XG5cbiAgZGVjcnlwdChlbmNyeXB0ZWQpIHtcbiAgICB2YXJcbiAgICAgIHN0ZXAgPSA0ICogODAwMCxcbiAgICAvL2VuY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZW5jcnlwdGVkLmJ1ZmZlciksXG4gICAgZW5jcnlwdGVkMzIgPSBuZXcgSW50MzJBcnJheShlbmNyeXB0ZWQpLFxuICAgIGRlY3J5cHRlZCA9IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZC5ieXRlTGVuZ3RoKSxcbiAgICBpID0gMDtcblxuICAgIC8vIHNwbGl0IHVwIHRoZSBlbmNyeXB0aW9uIGpvYiBhbmQgZG8gdGhlIGluZGl2aWR1YWwgY2h1bmtzIGFzeW5jaHJvbm91c2x5XG4gICAgdmFyIGtleSA9IHRoaXMua2V5O1xuICAgIHZhciBpbml0VmVjdG9yID0gdGhpcy5pdjtcbiAgICB0aGlzLmxvY2FsRGVjcnlwdChlbmNyeXB0ZWQzMi5zdWJhcnJheShpLCBpICsgc3RlcCksIGtleSwgaW5pdFZlY3RvciwgZGVjcnlwdGVkKTtcblxuICAgIGZvciAoaSA9IHN0ZXA7IGkgPCBlbmNyeXB0ZWQzMi5sZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgaW5pdFZlY3RvciA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgICAgdGhpcy5udG9oKGVuY3J5cHRlZDMyW2kgLSA0XSksXG4gICAgICAgICAgdGhpcy5udG9oKGVuY3J5cHRlZDMyW2kgLSAzXSksXG4gICAgICAgICAgdGhpcy5udG9oKGVuY3J5cHRlZDMyW2kgLSAyXSksXG4gICAgICAgICAgdGhpcy5udG9oKGVuY3J5cHRlZDMyW2kgLSAxXSlcbiAgICAgIF0pO1xuICAgICAgdGhpcy5sb2NhbERlY3J5cHQoZW5jcnlwdGVkMzIuc3ViYXJyYXkoaSwgaSArIHN0ZXApLCBrZXksIGluaXRWZWN0b3IsIGRlY3J5cHRlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY3J5cHRlZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBRVMxMjhEZWNyeXB0ZXI7XG4iLCIvKlxuICogQUVTMTI4IGRlY3J5cHRpb24uXG4gKi9cblxuaW1wb3J0IEFFUzEyOERlY3J5cHRlciBmcm9tICcuL2FlczEyOC1kZWNyeXB0ZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRGVjcnlwdGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IHdpbmRvdyA/IHdpbmRvdy5jcnlwdG8gOiBjcnlwdG87XG4gICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VidGxlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxuXG4gIGRlY3J5cHQoZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlV2ViQ3J5cHRvICYmIHRoaXMuaGxzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgdGhpcy5kZWNyeXB0QnlTb2Z0d2FyZShkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjcnlwdEJ5V2ViQ3J5cHRvKGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBkZWNyeXB0QnlXZWJDcnlwdG8oZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBsb2dnZXIubG9nKCdkZWNyeXB0aW5nIGJ5IFdlYkNyeXB0byBBUEknKTtcblxuICAgIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3Jywga2V5LCB7IG5hbWUgOiAnQUVTLUNCQycsIGxlbmd0aCA6IDEyOCB9LCBmYWxzZSwgWydkZWNyeXB0J10pLlxuICAgICAgdGhlbigoaW1wb3J0ZWRLZXkpID0+IHtcbiAgICAgICAgdGhpcy5zdWJ0bGUuZGVjcnlwdCh7IG5hbWUgOiAnQUVTLUNCQycsIGl2IDogaXYuYnVmZmVyIH0sIGltcG9ydGVkS2V5LCBkYXRhKS5cbiAgICAgICAgICB0aGVuKGNhbGxiYWNrKS5cbiAgICAgICAgICBjYXRjaCAoKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgfSkuXG4gICAgY2F0Y2ggKChlcnIpID0+IHtcbiAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlY3J5cHRCeVNvZnR3YXJlKGRhdGEsIGtleTgsIGl2OCwgY2FsbGJhY2spIHtcbiAgICBsb2dnZXIubG9nKCdkZWNyeXB0aW5nIGJ5IEphdmFTY3JpcHQgSW1wbGVtZW50YXRpb24nKTtcblxuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGtleTguYnVmZmVyKTtcbiAgICB2YXIga2V5ID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAgICAgdmlldy5nZXRVaW50MzIoMCksXG4gICAgICAgIHZpZXcuZ2V0VWludDMyKDQpLFxuICAgICAgICB2aWV3LmdldFVpbnQzMig4KSxcbiAgICAgICAgdmlldy5nZXRVaW50MzIoMTIpXG4gICAgXSk7XG5cbiAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGl2OC5idWZmZXIpO1xuICAgIHZhciBpdiA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgIHZpZXcuZ2V0VWludDMyKDApLFxuICAgICAgICB2aWV3LmdldFVpbnQzMig0KSxcbiAgICAgICAgdmlldy5nZXRVaW50MzIoOCksXG4gICAgICAgIHZpZXcuZ2V0VWludDMyKDEyKVxuICAgIF0pO1xuXG4gICAgdmFyIGRlY3J5cHRlciA9IG5ldyBBRVMxMjhEZWNyeXB0ZXIoa2V5LCBpdik7XG4gICAgY2FsbGJhY2soZGVjcnlwdGVyLmRlY3J5cHQoZGF0YSkuYnVmZmVyKTtcbiAgfVxuXG4gIG9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2Rpc2FibGluZyB0byB1c2UgV2ViQ3J5cHRvIEFQSScpO1xuICAgICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVjcnlwdEJ5U29mdHdhcmUoZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgZGVjcnlwdGluZyBlcnJvciA6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHMgOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLCBmYXRhbCA6IHRydWUsIHJlYXNvbiA6IGVyci5tZXNzYWdlfSk7XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVjcnlwdGVyO1xuIiwiLyoqXG4gKiBBQUMgZGVtdXhlclxuICovXG5pbXBvcnQgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5cbiBjbGFzcyBBQUNEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgaWQsIHJlbXV4ZXJDbGFzcywgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnJlbXV4ZXJDbGFzcyA9IHJlbXV4ZXJDbGFzcztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgdGhpcy5yZW11eGVyQ2xhc3Mob2JzZXJ2ZXIsaWQsIGNvbmZpZyk7XG4gICAgdGhpcy5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gIH1cblxuICBpbnNlcnREaXNjb250aW51aXR5KCkge1xuICAgIHRoaXMuX2FhY1RyYWNrID0ge2NvbnRhaW5lciA6ICdhdWRpby9hZHRzJywgdHlwZTogJ2F1ZGlvJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBBRFRTIHN5bmMgd29yY1xuICAgIHZhciBpZDMgPSBuZXcgSUQzKGRhdGEpLCBvZmZzZXQsbGVuO1xuICAgIGlmKGlkMy5oYXNUaW1lU3RhbXApIHtcbiAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGgsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKGRhdGFbb2Zmc2V0KzFdICYgMHhmMCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgcHVzaChkYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbikge1xuICAgIHZhciB0cmFjayxcbiAgICAgICAgaWQzID0gbmV3IElEMyhkYXRhKSxcbiAgICAgICAgcHRzID0gOTAqaWQzLnRpbWVTdGFtcCxcbiAgICAgICAgY29uZmlnLCBmcmFtZUxlbmd0aCwgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBoZWFkZXJMZW5ndGgsIHN0YW1wLCBsZW4sIGFhY1NhbXBsZTtcblxuICAgIGxldCBjb250aWd1b3VzID0gZmFsc2U7XG4gICAgaWYgKGNjICE9PSB0aGlzLmxhc3RDQykge1xuICAgICAgbG9nZ2VyLmxvZyhgJHt0aGlzLmlkfSBkaXNjb250aW51aXR5IGRldGVjdGVkYCk7XG4gICAgICB0aGlzLmxhc3RDQyA9IGNjO1xuICAgICAgdGhpcy5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gICAgICB0aGlzLnJlbXV4ZXIuc3dpdGNoTGV2ZWwoKTtcbiAgICAgIHRoaXMucmVtdXhlci5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gICAgfSBlbHNlIGlmIChsZXZlbCAhPT0gdGhpcy5sYXN0TGV2ZWwpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2F1ZGlvIHRyYWNrIHN3aXRjaCBkZXRlY3RlZCcpO1xuICAgICAgdGhpcy5sYXN0TGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMucmVtdXhlci5zd2l0Y2hMZXZlbCgpO1xuICAgICAgdGhpcy5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gICAgfSBlbHNlIGlmIChzbiA9PT0gKHRoaXMubGFzdFNOKzEpKSB7XG4gICAgICBjb250aWd1b3VzID0gdHJ1ZTtcbiAgICB9XG4gICAgdHJhY2sgPSB0aGlzLl9hYWNUcmFjaztcbiAgICB0aGlzLmxhc3RTTiA9IHNuO1xuICAgIHRoaXMubGFzdExldmVsID0gbGV2ZWw7XG5cbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgIGZvciAob2Zmc2V0ID0gaWQzLmxlbmd0aCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKGRhdGFbb2Zmc2V0KzFdICYgMHhmMCkgPT09IDB4ZjApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0cmFjay5hdWRpb3NhbXBsZXJhdGUpIHtcbiAgICAgIGNvbmZpZyA9IEFEVFMuZ2V0QXVkaW9Db25maWcodGhpcy5vYnNlcnZlcixkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICAgIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICAgIHRyYWNrLmNvZGVjID0gY29uZmlnLmNvZGVjO1xuICAgICAgdHJhY2suZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSxyYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LG5iIGNoYW5uZWw6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xuICAgIH1cbiAgICBmcmFtZUluZGV4ID0gMDtcbiAgICBmcmFtZUR1cmF0aW9uID0gMTAyNCAqIDkwMDAwIC8gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuICAgIHdoaWxlICgob2Zmc2V0ICsgNSkgPCBsZW4pIHtcbiAgICAgIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgICAgaGVhZGVyTGVuZ3RoID0gKCEhKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxKSA/IDcgOiA5KTtcbiAgICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICAgIGZyYW1lTGVuZ3RoID0gKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcbiAgICAgICAgICAgICAgICAgICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAgICAgICAgICAgICAgICAgKChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDUpO1xuICAgICAgZnJhbWVMZW5ndGggIC09IGhlYWRlckxlbmd0aDtcbiAgICAgIC8vc3RhbXAgPSBwZXMucHRzO1xuXG4gICAgICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuKSkge1xuICAgICAgICBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAvL2xvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0vJHsoc3RhbXAvOTApLnRvRml4ZWQoMCl9YCk7XG4gICAgICAgIGFhY1NhbXBsZSA9IHt1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfTtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY1NhbXBsZSk7XG4gICAgICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoO1xuICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgIGZvciAoIDsgb2Zmc2V0IDwgKGxlbiAtIDEpOyBvZmZzZXQrKykge1xuICAgICAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtdXhlci5yZW11eChsZXZlbCwgc24gLCB0aGlzLl9hYWNUcmFjayx7c2FtcGxlcyA6IFtdfSwge3NhbXBsZXMgOiBbIHsgcHRzOiBwdHMsIGR0cyA6IHB0cywgdW5pdCA6IGlkMy5wYXlsb2FkfSBdfSwgeyBzYW1wbGVzOiBbXSB9LCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUNEZW11eGVyO1xuIiwiLyoqXG4gKiAgQURUUyBwYXJzZXIgaGVscGVyXG4gKi9cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbiBjbGFzcyBBRFRTIHtcblxuICBzdGF0aWMgZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICAgIHZhciBhZHRzT2JqZWN0VHlwZSwgLy8gOmludFxuICAgICAgICBhZHRzU2FtcGxlaW5nSW5kZXgsIC8vIDppbnRcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgICAgIGFkdHNDaGFuZWxDb25maWcsIC8vIDppbnRcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGFkdHNTYW1wbGVpbmdSYXRlcyA9IFtcbiAgICAgICAgICAgIDk2MDAwLCA4ODIwMCxcbiAgICAgICAgICAgIDY0MDAwLCA0ODAwMCxcbiAgICAgICAgICAgIDQ0MTAwLCAzMjAwMCxcbiAgICAgICAgICAgIDI0MDAwLCAyMjA1MCxcbiAgICAgICAgICAgIDE2MDAwLCAxMjAwMCxcbiAgICAgICAgICAgIDExMDI1LCA4MDAwLFxuICAgICAgICAgICAgNzM1MF07XG4gICAgLy8gYnl0ZSAyXG4gICAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweEMwKSA+Pj4gNikgKyAxO1xuICAgIGFkdHNTYW1wbGVpbmdJbmRleCA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M0MpID4+PiAyKTtcbiAgICBpZihhZHRzU2FtcGxlaW5nSW5kZXggPiBhZHRzU2FtcGxlaW5nUmF0ZXMubGVuZ3RoLTEpIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fWB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWR0c0NoYW5lbENvbmZpZyA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4MDEpIDw8IDIpO1xuICAgIC8vIGJ5dGUgM1xuICAgIGFkdHNDaGFuZWxDb25maWcgfD0gKChkYXRhW29mZnNldCArIDNdICYgMHhDMCkgPj4+IDYpO1xuICAgIGxvZ2dlci5sb2coYG1hbmlmZXN0IGNvZGVjOiR7YXVkaW9Db2RlY30sQURUUyBkYXRhOnR5cGU6JHthZHRzT2JqZWN0VHlwZX0sc2FtcGxlaW5nSW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9WyR7YWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF19SHpdLGNoYW5uZWxDb25maWc6JHthZHRzQ2hhbmVsQ29uZmlnfWApO1xuICAgIC8vIGZpcmVmb3g6IGZyZXEgbGVzcyB0aGFuIDI0a0h6ID0gQUFDIFNCUiAoSEUtQUFDKVxuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMSkge1xuICAgICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICB9XG4gICAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKGNocm9tZSAuLi4pXG4gICAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAgICovXG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcbiAgICAgIGlmICgoYXVkaW9Db2RlYyAmJiAoKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XG4gICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSkge1xuICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBBQUMpIEFORCAoZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeiBBTkQgbmIgY2hhbm5lbCBpcyAxKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBhbmQgbW9ubyBhdWRpbylcbiAgICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHx8XG4gICAgICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkpIHtcbiAgICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICB9XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAgIDA6IE51bGxcbiAgICAgIDE6IEFBQyBNYWluXG4gICAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgICBzYW1wbGluZyBmcmVxXG4gICAgICAwOiA5NjAwMCBIelxuICAgICAgMTogODgyMDAgSHpcbiAgICAgIDI6IDY0MDAwIEh6XG4gICAgICAzOiA0ODAwMCBIelxuICAgICAgNDogNDQxMDAgSHpcbiAgICAgIDU6IDMyMDAwIEh6XG4gICAgICA2OiAyNDAwMCBIelxuICAgICAgNzogMjIwNTAgSHpcbiAgICAgIDg6IDE2MDAwIEh6XG4gICAgICA5OiAxMjAwMCBIelxuICAgICAgMTA6IDExMDI1IEh6XG4gICAgICAxMTogODAwMCBIelxuICAgICAgMTI6IDczNTAgSHpcbiAgICAgIDEzOiBSZXNlcnZlZFxuICAgICAgMTQ6IFJlc2VydmVkXG4gICAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICAgKi9cbiAgICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICAgIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XG4gICAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuICAgIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcbiAgICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gICAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgICBjb25maWdbMV0gfD0gYWR0c0NoYW5lbENvbmZpZyA8PCAzO1xuICAgIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4XG4gICAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAgIC8vICAgIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMuZ2l0LysvbWFzdGVyL21lZGlhL2Zvcm1hdHMvbXA0L2FhYy5jY1xuICAgICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcbiAgICAgIGNvbmZpZ1szXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7Y29uZmlnOiBjb25maWcsIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdLCBjaGFubmVsQ291bnQ6IGFkdHNDaGFuZWxDb25maWcsIGNvZGVjOiAoJ21wNGEuNDAuJyArIGFkdHNPYmplY3RUeXBlKX07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQURUUztcbiIsIi8qICBpbmxpbmUgZGVtdXhlci5cbiAqICAgcHJvYmUgZnJhZ21lbnRzIGFuZCBpbnN0YW50aWF0ZSBhcHByb3ByaWF0ZSBkZW11eGVyIGRlcGVuZGluZyBvbiBjb250ZW50IHR5cGUgKFRTRGVtdXhlciwgQUFDRGVtdXhlciwgLi4uKVxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgQUFDRGVtdXhlciBmcm9tICcuLi9kZW11eC9hYWNkZW11eGVyJztcbmltcG9ydCBUU0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvdHNkZW11eGVyJztcbmltcG9ydCBGTFZEZW11eGVyIGZyb20gJy4uL2RlbXV4L2ZsdmRlbXV4ZXInO1xuaW1wb3J0IE1QNFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvbXA0LXJlbXV4ZXInO1xuaW1wb3J0IFBhc3NUaHJvdWdoUmVtdXhlciBmcm9tICcuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyJztcblxuY2xhc3MgRGVtdXhlcklubGluZSB7XG5cbiAgY29uc3RydWN0b3IoaGxzLGlkLCB0eXBlU3VwcG9ydGVkLCBjb25maWc9bnVsbCkge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZyB8fCBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoIWRlbXV4ZXIpIHtcbiAgICAgIGxldCBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICAvLyBwcm9iZSBmb3IgY29udGVudCB0eXBlXG4gICAgICBpZiAoRkxWRGVtdXhlci5wcm9iZShkYXRhKSkge1xuICAgICAgICBkZW11eGVyID0gbmV3IEZMVkRlbXV4ZXIoaGxzLCBpZCwgTVA0UmVtdXhlciwgdGhpcy5jb25maWcpO1xuICAgICAgfSBlbHNlIGlmIChUU0RlbXV4ZXIucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZVN1cHBvcnRlZC5tcDJ0ID09PSB0cnVlKSB7XG4gICAgICAgICAgZGVtdXhlciA9IG5ldyBUU0RlbXV4ZXIoaGxzLCBpZCwgUGFzc1Rocm91Z2hSZW11eGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVtdXhlciA9IG5ldyBUU0RlbXV4ZXIoaGxzLCBpZCwgTVA0UmVtdXhlciwgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoQUFDRGVtdXhlci5wcm9iZShkYXRhKSkge1xuICAgICAgICBkZW11eGVyID0gbmV3IEFBQ0RlbXV4ZXIoaGxzLCBpZCwgTVA0UmVtdXhlciwgdGhpcy5jb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgaWQgOiBpZCwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogJ25vIGRlbXV4IG1hdGNoaW5nIHdpdGggY29udGVudCBmb3VuZCd9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kZW11eGVyID0gZGVtdXhlcjtcbiAgICB9XG4gICAgZGVtdXhlci5wdXNoKGRhdGEsYXVkaW9Db2RlYyx2aWRlb0NvZGVjLHRpbWVPZmZzZXQsY2MsbGV2ZWwsc24sZHVyYXRpb24pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXJJbmxpbmU7XG4iLCIvKiBkZW11eGVyIHdlYiB3b3JrZXIuXG4gKiAgLSBsaXN0ZW4gdG8gd29ya2VyIG1lc3NhZ2UsIGFuZCB0cmlnZ2VyIERlbXV4ZXJJbmxpbmUgdXBvbiByZWNlcHRpb24gb2YgRnJhZ21lbnRzLlxuICogIC0gcHJvdmlkZXMgTVA0IEJveGVzIGJhY2sgdG8gbWFpbiB0aHJlYWQgdXNpbmcgW3RyYW5zZmVyYWJsZSBvYmplY3RzXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KSBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWQuXG4gKi9cblxuIGltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcbiBpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5cbnZhciBEZW11eGVyV29ya2VyID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgdmFyIG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICBvYnNlcnZlci5lbWl0KGV2ZW50LCBldmVudCwgLi4uZGF0YSk7XG4gIH07XG5cbiAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgLi4uZGF0YSkge1xuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcbiAgfTtcbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuICAgIC8vY29uc29sZS5sb2coJ2RlbXV4ZXIgY21kOicgKyBkYXRhLmNtZCk7XG4gICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLCBkYXRhLmlkLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIEpTT04ucGFyc2UoZGF0YS5jb25maWcpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkZW11eCc6XG4gICAgICAgIHNlbGYuZGVtdXhlci5wdXNoKG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YSksIGRhdGEuYXVkaW9Db2RlYywgZGF0YS52aWRlb0NvZGVjLCBkYXRhLnRpbWVPZmZzZXQsIGRhdGEuY2MsIGRhdGEubGV2ZWwsIGRhdGEuc24sIGRhdGEuZHVyYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24oZXYsZGF0YSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe2V2ZW50OiBldiwgZGF0YTpkYXRhIH0pO1xuICB9O1xuXG4gIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IHBhc3MgZGF0YTEvZGF0YTIgYXMgdHJhbnNmZXJhYmxlIG9iamVjdCAobm8gY29weSlcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uKGV2LCBkYXRhKSB7XG4gICAgbGV0IGRhdGExID0gZGF0YS5kYXRhMS5idWZmZXIsIGRhdGEyID0gZGF0YS5kYXRhMi5idWZmZXI7XG4gICAgLy8gcmVtb3ZlIGRhdGExIGFuZCBkYXRhMiByZWZlcmVuY2UgZnJvbSBkYXRhIHRvIGF2b2lkIGNvcHlpbmcgdGhlbSAuLi5cbiAgICBkZWxldGUgZGF0YS5kYXRhMTtcbiAgICBkZWxldGUgZGF0YS5kYXRhMjtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtldmVudDogZXYsIGRhdGE6ZGF0YSAsIGRhdGExIDogZGF0YTEsIGRhdGEyIDogZGF0YTJ9LFtkYXRhMSwgZGF0YTJdKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyV29ya2VyO1xuXG4iLCJpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcbmltcG9ydCBEZW11eGVyV29ya2VyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItd29ya2VyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmNsYXNzIERlbXV4ZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscywgaWQpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQgOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXAydCA6IGhscy5jb25maWcuZW5hYmxlTVAyVFBhc3NUaHJvdWdoICYmIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXAydCcpXG4gICAgfTtcbiAgICBpZiAoaGxzLmNvbmZpZy5lbmFibGVXb3JrZXIgJiYgKHR5cGVvZihXb3JrZXIpICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnZGVtdXhpbmcgaW4gd2Vid29ya2VyJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHdvcmsgPSByZXF1aXJlKCd3ZWJ3b3JraWZ5Jyk7XG4gICAgICAgICAgbGV0IHcgPSB0aGlzLncgPSB3b3JrKERlbXV4ZXJXb3JrZXIpO1xuICAgICAgICAgIHRoaXMub253bXNnID0gdGhpcy5vbldvcmtlck1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICB3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgICAgdy5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHsgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogdHJ1ZSwgZXZlbnQgOiAnZGVtdXhlcldvcmtlcicsIGVyciA6IHsgbWVzc2FnZSA6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKScgfX0pO307XG4gICAgICAgICAgdy5wb3N0TWVzc2FnZSh7Y21kOiAnaW5pdCcsIHR5cGVTdXBwb3J0ZWQgOiB0eXBlU3VwcG9ydGVkLCBpZCA6IGlkLCBjb25maWc6IEpTT04uc3RyaW5naWZ5KGhscy5jb25maWcpfSk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSBpbml0aWFsaXppbmcgRGVtdXhlcldvcmtlciwgZmFsbGJhY2sgb24gRGVtdXhlcklubGluZScpO1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKGhscyxpZCx0eXBlU3VwcG9ydGVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUoaGxzLGlkLHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kZW11eEluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgaWYgKHcpIHtcbiAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICB0aGlzLncgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgZGVjcnlwdGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoRGVjcnlwdGVkKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uKSB7XG4gICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgaWYgKHcpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyAobm8gY29weSlcbiAgICAgIHcucG9zdE1lc3NhZ2Uoe2NtZDogJ2RlbXV4JywgZGF0YTogZGF0YSwgYXVkaW9Db2RlYzogYXVkaW9Db2RlYywgdmlkZW9Db2RlYzogdmlkZW9Db2RlYywgdGltZU9mZnNldDogdGltZU9mZnNldCwgY2M6IGNjLCBsZXZlbDogbGV2ZWwsIHNuIDogc24sIGR1cmF0aW9uOiBkdXJhdGlvbn0sIFtkYXRhXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgZGVtdXhlci5wdXNoKG5ldyBVaW50OEFycmF5KGRhdGEpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVzaChkYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbiwgZGVjcnlwdGRhdGEpIHtcbiAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgIGlmICh0aGlzLmRlY3J5cHRlciA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLmhscyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChkYXRhLCBkZWNyeXB0ZGF0YS5rZXksIGRlY3J5cHRkYXRhLml2LCBmdW5jdGlvbihkZWNyeXB0ZWREYXRhKXtcbiAgICAgICAgbG9jYWx0aGlzLnB1c2hEZWNyeXB0ZWQoZGVjcnlwdGVkRGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaERlY3J5cHRlZChkYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25Xb3JrZXJNZXNzYWdlKGV2KSB7XG4gICAgbGV0IGRhdGEgPSBldi5kYXRhLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAvL2NvbnNvbGUubG9nKCdvbldvcmtlck1lc3NhZ2U6JyArIGRhdGEuZXZlbnQpO1xuICAgIHN3aXRjaChkYXRhLmV2ZW50KSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBkYXRhMSBhbmQgZGF0YTIgYXJlIHRyYW5zZmVyYWJsZSBvYmplY3RzXG4gICAgICBjYXNlIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBOlxuICAgICAgICBkYXRhLmRhdGEuZGF0YTEgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGExKTtcbiAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyO1xuXG4iLCIvKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuKi9cblxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEV4cEdvbG9tYiB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IHRoaXMuZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkKCkge1xuICAgIHZhclxuICAgICAgcG9zaXRpb24gPSB0aGlzLmRhdGEuYnl0ZUxlbmd0aCAtIHRoaXMuYnl0ZXNBdmFpbGFibGUsXG4gICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcbiAgICAgIGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgdGhpcy5ieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICB3b3JraW5nQnl0ZXMuc2V0KHRoaXMuZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgIHRoaXMud29yZCA9IG5ldyBEYXRhVmlldyh3b3JraW5nQnl0ZXMuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfVxuXG4gIC8vIChjb3VudDppbnQpOnZvaWRcbiAgc2tpcEJpdHMoY291bnQpIHtcbiAgICB2YXIgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gKHNraXBCeXRlcyA+PiAzKTtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgcmVhZEJpdHMoc2l6ZSkge1xuICAgIHZhclxuICAgICAgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSksIC8vIDp1aW50XG4gICAgICB2YWx1ID0gdGhpcy53b3JkID4+PiAoMzIgLSBiaXRzKTsgLy8gOnVpbnRcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9XG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgc2tpcExaKCkge1xuICAgIHZhciBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgaWYgKDAgIT09ICh0aGlzLndvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwVUVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHJlYWRVRUcoKSB7XG4gICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRFRygpIHtcbiAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAoMSArIHZhbHUpID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9XG5cbiAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgLy8gOkJvb2xlYW5cbiAgcmVhZEJvb2xlYW4oKSB7XG4gICAgcmV0dXJuIDEgPT09IHRoaXMucmVhZEJpdHMoMSk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVCeXRlKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9XG4gICAgLy8gKCk6aW50XG4gIHJlYWRVSW50KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICBza2lwU2NhbGluZ0xpc3QoY291bnQpIHtcbiAgICB2YXJcbiAgICAgIGxhc3RTY2FsZSA9IDgsXG4gICAgICBuZXh0U2NhbGUgPSA4LFxuICAgICAgaixcbiAgICAgIGRlbHRhU2NhbGU7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2FsZSA9IChuZXh0U2NhbGUgPT09IDApID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXRcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUygpIHtcbiAgICB2YXJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXG4gICAgICBzYXJTY2FsZSA9IDEsXG4gICAgICBwcm9maWxlSWRjLHByb2ZpbGVDb21wYXQsbGV2ZWxJZGMsXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUsIHBpY1dpZHRoSW5NYnNNaW51czEsXG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxuICAgICAgZnJhbWVNYnNPbmx5RmxhZyxcbiAgICAgIHNjYWxpbmdMaXN0Q291bnQsXG4gICAgICBpO1xuICAgIHRoaXMucmVhZFVCeXRlKCk7XG4gICAgcHJvZmlsZUlkYyA9IHRoaXMucmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgcHJvZmlsZUNvbXBhdCA9IHRoaXMucmVhZEJpdHMoNSk7IC8vIGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgIHRoaXMuc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICBsZXZlbElkYyA9IHRoaXMucmVhZFVCeXRlKCk7IC8vbGV2ZWxfaWRjIHUoOClcbiAgICB0aGlzLnNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExMCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMjIgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDQ0ICB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA4MyAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODYgIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExOCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgIHZhciBjaHJvbWFGb3JtYXRJZGMgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgdGhpcy5za2lwQml0cygxKTsgLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcbiAgICAgIH1cbiAgICAgIHRoaXMuc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfbHVtYV9taW51czhcbiAgICAgIHRoaXMuc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgdGhpcy5za2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAodGhpcy5yZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IChjaHJvbWFGb3JtYXRJZGMgIT09IDMpID8gOCA6IDEyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgdGhpcy5za2lwU2NhbGluZ0xpc3QoMTYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5za2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIHZhciBwaWNPcmRlckNudFR5cGUgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICB0aGlzLnJlYWRVRUcoKTsgLy9sb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgdGhpcy5za2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHRoaXMuc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcbiAgICAgIHRoaXMuc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7IGkrKykge1xuICAgICAgICB0aGlzLnNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICB0aGlzLnNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcbiAgICBwaWNXaWR0aEluTWJzTWludXMxID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHRoaXMucmVhZFVFRygpO1xuICAgIGZyYW1lTWJzT25seUZsYWcgPSB0aGlzLnJlYWRCaXRzKDEpO1xuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICB0aGlzLnNraXBCaXRzKDEpOyAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG4gICAgfVxuICAgIHRoaXMuc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAodGhpcy5yZWFkQm9vbGVhbigpKSB7IC8vIGZyYW1lX2Nyb3BwaW5nX2ZsYWdcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHRoaXMucmVhZFVFRygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmICh0aGlzLnJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgIGxldCBzYXJSYXRpbztcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9JZGMgPSB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOiBzYXJSYXRpbyA9IFsxLDFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IHNhclJhdGlvID0gWzEyLDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiBzYXJSYXRpbyA9IFsxMCwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogc2FyUmF0aW8gPSBbMTYsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDU6IHNhclJhdGlvID0gWzQwLDMzXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OiBzYXJSYXRpbyA9IFsyNCwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzogc2FyUmF0aW8gPSBbMjAsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDg6IHNhclJhdGlvID0gWzMyLDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5OiBzYXJSYXRpbyA9IFs4MCwzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6IHNhclJhdGlvID0gWzE4LDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTogc2FyUmF0aW8gPSBbMTUsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEyOiBzYXJSYXRpbyA9IFs2NCwzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6IHNhclJhdGlvID0gWzE2MCw5OV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6IHNhclJhdGlvID0gWzQsM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTU6IHNhclJhdGlvID0gWzMsMl07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6IHNhclJhdGlvID0gWzIsMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgICBzYXJSYXRpbyA9IFt0aGlzLnJlYWRVQnl0ZSgpIDw8IDggfCB0aGlzLnJlYWRVQnl0ZSgpLCB0aGlzLnJlYWRVQnl0ZSgpIDw8IDggfCB0aGlzLnJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FyUmF0aW8pIHtcbiAgICAgICAgICBzYXJTY2FsZSA9IHNhclJhdGlvWzBdIC8gc2FyUmF0aW9bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKCgocGljV2lkdGhJbk1ic01pbnVzMSArIDEpICogMTYpIC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpICogc2FyU2NhbGUpLFxuICAgICAgaGVpZ2h0OiAoKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNikgLSAoKGZyYW1lTWJzT25seUZsYWc/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpKVxuICAgIH07XG4gIH1cblxuICByZWFkU2xpY2VUeXBlKCkge1xuICAgIC8vIHNraXAgTkFMdSB0eXBlXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgdGhpcy5yZWFkVUVHKCk7XG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhwR29sb21iO1xuIiwiLyoqXG4gKiBAZmlsZTogICBmbHYtcGFyc2VyLmpzXG4gKiBAYXV0aG9yOiB0YW5zaGFvaHVpXG4gKiBAZW1haWw6ICB0YW5zaGFvaHVpQGJhaWR1LmNvbVxuICogQGRhdGU6ICAgMjAxNi0wOS0wNyAxNTowNjo0MVxuICogQGxhc3QgbW9kaWZpZWQgYnk6ICAgdGFuc2hhb2h1aVxuICogQGxhc3QgbW9kaWZpZWQgdGltZTogMjAxNi0wOS0wNyAxNjowMzo0NVxuICovXG5cbmNsYXNzIEZMVlBhcnNlciB7XG5cbiAgICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgICAgICB0aGlzLmhhc0F1ZGlvVGFncyA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzVmlkZW9UYWdzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ib2R5T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZEZpbGVIZWFkZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkRmlsZUhlYWRlciAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCBGTFZQYXJzZXIuTUlOX0ZJTEVfSEVBREVSX0JZVEVfQ09VTlQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSB0b28gc2hvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIGlmIChkYXRhWzBdICE9PSAweDQ2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZMVkhlYWRlciBTaWduYXR1cmVbMF0gbm90IFwiRlwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gMHg0Qykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGTFZIZWFkZXIgU2lnbmF0dXJlWzFdIG5vdCBcIkxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFbMl0gIT09IDB4NTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRkxWSGVhZGVyIFNpZ25hdHVyZVsyXSBub3QgXCJWXCInKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGRhdGFbM10gIT09IDB4MDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRkxWSGVhZGVyIFZlcnNpb24gbm90IDB4MDEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IGRhdGFbNF07XG4gICAgICAgIHRoaXMuaGFzQXVkaW9UYWdzID0gKGZsYWdzICYgMHgwNCkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzVmlkZW9UYWdzID0gKGZsYWdzICYgMHgwMSkgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgdGhpcy5ib2R5T2Zmc2V0ID0gbmV3IERhdGFWaWV3KGRhdGEuc2xpY2UoNSkuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG4gICAgICAgIGlmICh0aGlzLmJvZHlPZmZzZXQgPCBGTFZQYXJzZXIuTUlOX0ZJTEVfSEVBREVSX0JZVEVfQ09VTlQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRkxWSGVhZGVyIGJvZHlPZmZzZXQgc21hbGxlciB0aGFuIG1pbmltdW0nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuRkxWUGFyc2VyLk1JTl9GSUxFX0hFQURFUl9CWVRFX0NPVU5UID0gOTtcbkZMVlBhcnNlci5GSUxFX0hFQURFUiA9ICdmaWxlSGVhZGVyJztcbkZMVlBhcnNlci5QUkVWX1RBRyA9ICdwcmV2VGFnJztcbkZMVlBhcnNlci5IRUFERVIgPSAnaGVhZGVyJztcbkZMVlBhcnNlci5EQVRBID0gJ2RhdGEnO1xuXG5leHBvcnQgZGVmYXVsdCBGTFZQYXJzZXI7IiwiLyoqXG4gKiBAZmlsZTogICBmbHYtdGFnLmpzXG4gKiBAYXV0aG9yOiB0YW5zaGFvaHVpXG4gKiBAZW1haWw6ICB0YW5zaGFvaHVpQGJhaWR1LmNvbVxuICogQGRhdGU6ICAgMjAxNi0wOS0wNyAxMjo1NjowOVxuICogQGxhc3QgbW9kaWZpZWQgYnk6ICAgdGFuc2hhb2h1aVxuICogQGxhc3QgbW9kaWZpZWQgdGltZTogMjAxNi0wOS0wNyAyMDo0NDoxOFxuICovXG5cbmNsYXNzIEZMVlRhZyB7XG5cbiAgICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgICAgICB0aGlzLnR5cGUgPSBGTFZUYWcuVEFHX1RZUEVfU0NSSVBUREFUQU9CSkVDVDtcbiAgICAgICAgdGhpcy50YWdEYXRhU2l6ZSA9IDA7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRIZWFkZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkUHJldlRhZ1NpemUgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIH1cblxuICAgIHJlYWRIZWFkZXIgKGRhdGEpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBkYXRhWzBdO1xuICAgICAgICBpZiAodHlwZSA9PT0gRkxWVGFnLlRBR19UWVBFX0FVRElPIHx8IHR5cGUgPT09IEZMVlRhZy5UQUdfVFlQRV9WSURFTyB8fCB0eXBlID09PSBGTFZUYWcuVEFHX1RZUEVfU0NSSVBUREFUQU9CSkVDVCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBGTFZUYWdUeXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhZ0RhdGFTaXplID0gKGRhdGFbMV0gPDwgMTYgfCBkYXRhWzJdIDw8IDggfCBkYXRhWzNdKTtcblxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IChkYXRhWzddIDw8IDI0KSB8IChkYXRhWzRdIDw8IDE2KSB8IChkYXRhWzVdIDw8IDgpIHwgKGRhdGFbNl0pO1xuICAgIH1cblxuICAgIHJlYWREYXRhIChkYXRhKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZMVlRhZy5UQUdfVFlQRV9BVURJTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQXVkaW9EYXRhKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSBGTFZUYWcuVEFHX1RZUEVfVklERU86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFZpZGVvRGF0YShkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgRkxWVGFnLlRBR19UWVBFX1NDUklQVERBVEFPQkpFQ1Q6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBGTFZUYWdUeXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkQXVkaW9EYXRhIChkYXRhKSB7XG4gICAgICAgIHZhciB0YWcgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXVkaW9IZWFkZXIgPSBkYXRhWzBdO1xuICAgICAgICB2YXIgc291bmRGb3JtYXQgPSAoYXVkaW9IZWFkZXIgPj4gNCkgJiAweDBmO1xuICAgICAgICB2YXIgc291bmRSYXRlID0gMDtcbiAgICAgICAgc3dpdGNoICgoYXVkaW9IZWFkZXIgPj4gMikgJiAweDAzKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgc291bmRSYXRlID0gNTUxMi41O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHNvdW5kUmF0ZSA9IDExMDI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHNvdW5kUmF0ZSA9IDIyMDUwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHNvdW5kUmF0ZSA9IDQ0MTAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc291bmRSYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQUFDXG4gICAgICAgIGlmIChzb3VuZEZvcm1hdCA9PT0gMTApIHtcbiAgICAgICAgICAgIGxldCBwYWNrZXRUeXBlID0gZGF0YVsxXTtcbiAgICAgICAgICAgIHRhZy5jb2RlYyA9ICdhYWMnO1xuICAgICAgICAgICAgdGFnLnBrdF90eXBlID0gcGFja2V0VHlwZTtcbiAgICAgICAgICAgIHRhZy5kYXRhID0gZGF0YS5zbGljZSgyKTtcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkVmlkZW9EYXRhIChkYXRhKSB7XG4gICAgICAgIHZhciB0YWcgPSB7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdmlkZW9IZWFkZXIgPSBkYXRhWzBdO1xuICAgICAgICB2YXIgY29kZWNJRCA9ICh2aWRlb0hlYWRlciAmIDB4MGYpO1xuICAgICAgICAvLyBBVkMgXG4gICAgICAgIGlmIChjb2RlY0lEID09PSA3KSB7XG4gICAgICAgICAgICBsZXQgcGFja2V0VHlwZSA9IGRhdGFbMV07XG4gICAgICAgICAgICB0YWcuY29kZWMgPSAnYXZjJztcbiAgICAgICAgICAgIHRhZy5wa3RfdHlwZSA9IHBhY2tldFR5cGU7XG4gICAgICAgICAgICBpZiAocGFja2V0VHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCBjb21wb3NpdGlvblRpbWUgPSBkYXRhWzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uVGltZSB8PSBkYXRhWzNdIDw8IDg7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25UaW1lIHw9IGRhdGFbNF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uVGltZSAmIDB4MDA4MDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25UaW1lIHw9IDB4ZmYwMDAwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnLmRhdGEgPSBkYXRhLnNsaWNlKDUpO1xuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5GTFZUYWcuUFJFVl9UQUdfQllURV9DT1VOVCA9IDQ7XG5GTFZUYWcuVEFHX1RZUEVfQVVESU8gPSAweDA4O1xuRkxWVGFnLlRBR19UWVBFX1ZJREVPID0gMHgwOTtcbkZMVlRhZy5UQUdfVFlQRV9TQ1JJUFREQVRBT0JKRUNUID0gMHgxMjtcbkZMVlRhZy5UQUdfSEVBREVSX0JZVEVfQ09VTlQgPSAxMTtcblxuZXhwb3J0IGRlZmF1bHQgRkxWVGFnOyIsIi8qKlxuICogQGZpbGU6ICAgZmx2ZGVtdXhlci5qc1xuICogQGF1dGhvcjogdGFuc2hhb2h1aVxuICogQGVtYWlsOiAgdGFuc2hhb2h1aUBiYWlkdS5jb21cbiAqIEBkYXRlOiAgIDIwMTYtMDktMDcgMTA6MjM6NTdcbiAqIEBsYXN0IG1vZGlmaWVkIGJ5OiAgIHRhbnNoYW9odWlcbiAqIEBsYXN0IG1vZGlmaWVkIHRpbWU6IDIwMTYtMDktMDcgMjA6NDU6MDBcbiAqL1xuXG5pbXBvcnQgRkxWUGFyc2VyIGZyb20gJy4vZmx2L2Zsdi1wYXJzZXInO1xuaW1wb3J0IEZMVlRhZyBmcm9tICcuL2Zsdi9mbHYtdGFnJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBGTFZEZW11eGVyIHtcblxuICAgIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgaWQsIHJlbXV4ZXJDbGFzcywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnJlbXV4ZXJDbGFzcyA9IHJlbXV4ZXJDbGFzcztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubGFzdENDID0gMDtcbiAgICAgICAgdGhpcy5mbHZQYXJzZXIgPSBuZXcgRkxWUGFyc2VyKCk7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IG5ldyB0aGlzLnJlbXV4ZXJDbGFzcyhvYnNlcnZlciwgaWQsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2ZsdlBhcnNlclN0YXRlID0gRkxWUGFyc2VyLkZJTEVfSEVBREVSO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xuICAgICAgICAvLyBmbHYgc3RhcnRpbmcgd2l0aCAweDQ2IDB4NEMgMHg1NiwgMHgwMVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiBGTFZQYXJzZXIuTUlOX0ZJTEVfSEVBREVSX0JZVEVfQ09VTlQgJiYgZGF0YVswXSA9PT0gMHg0NiAmJiBkYXRhWzFdID09PSAweDRDICYmIGRhdGFbMl0gPT09IDB4NTYgJiYgZGF0YVszXSA9PT0gMHgwMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2hMZXZlbCAoKSB7XG4gICAgICAgIHRoaXMuX2F2Y1RyYWNrID0ge2NvbnRhaW5lciA6ICd2aWRlby94LWZsdicsIHR5cGU6ICd2aWRlbycsIGlkIDotMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMCwgbmJOYWx1IDogMCwgZHJvcHBlZCA6IDB9O1xuICAgICAgICB0aGlzLl9hYWNUcmFjayA9IHtjb250YWluZXIgOiAndmlkZW8veC1mbHYnLCB0eXBlOiAnYXVkaW8nLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDB9O1xuICAgICAgICB0aGlzLl9pZDNUcmFjayA9IHt0eXBlOiAnaWQzJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICAgICAgdGhpcy5fdHh0VHJhY2sgPSB7dHlwZTogJ3RleHQnLCBpZDogLTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzOiBbXSwgbGVuOiAwfTtcbiAgICAgICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hYWNMYXN0UFRTID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdmNOYWx1U3RhdGUgPSAwO1xuICAgICAgICB0aGlzLnJlbXV4ZXIuc3dpdGNoTGV2ZWwoKTtcbiAgICB9XG5cbiAgICBpbnNlcnREaXNjb250aW51aXR5ICgpIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hMZXZlbCgpO1xuICAgICAgICB0aGlzLnJlbXV4ZXIuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgIH1cblxuICAgIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgICBwdXNoIChkYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgc3RhcnQsIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgY1RhZyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICAgICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAgICAgdGhpcy5jb250aWd1b3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZsdlBhcnNlclN0YXRlID0gRkxWUGFyc2VyLkZJTEVfSEVBREVSO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG4gICAgICAgIGlmIChjYyAhPT0gdGhpcy5sYXN0Q0MpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ2Rpc2NvbnRpbnVpdHkgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q0MgPSBjYztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgIT09IHRoaXMubGFzdExldmVsKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdsZXZlbCBzd2l0Y2ggZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExldmVsID0gbGV2ZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoc24gPT09ICh0aGlzLmxhc3RTTiArIDEpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFNOID0gc247XG5cbiAgICAgICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbGVuOyApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fZmx2UGFyc2VyU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEZMVlBhcnNlci5GSUxFX0hFQURFUjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHZQYXJzZXIucmVhZEZpbGVIZWFkZXIoZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBGTFZQYXJzZXIuTUlOX0ZJTEVfSEVBREVSX0JZVEVfQ09VTlQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmx2UGFyc2VyU3RhdGUgPSBGTFZQYXJzZXIuUFJFVl9UQUc7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMuZmx2UGFyc2VyLmJvZHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRkxWUGFyc2VyLlBSRVZfVEFHOlxuICAgICAgICAgICAgICAgICAgICBjVGFnID0gbmV3IEZMVlRhZygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mbHZQYXJzZXJTdGF0ZSA9IEZMVlBhcnNlci5IRUFERVI7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IEZMVlRhZy5QUkVWX1RBR19CWVRFX0NPVU5UO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZMVlBhcnNlci5IRUFERVI6XG4gICAgICAgICAgICAgICAgICAgIGNUYWcucmVhZEhlYWRlcihkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIEZMVlRhZy5UQUdfSEVBREVSX0JZVEVfQ09VTlQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmx2UGFyc2VyU3RhdGUgPSBGTFZQYXJzZXIuREFUQTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gRkxWVGFnLlRBR19IRUFERVJfQllURV9DT1VOVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGTFZQYXJzZXIuREFUQTpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZyA9IGNUYWcucmVhZERhdGEoZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjVGFnLnRhZ0RhdGFTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgJiYgdGFnLmNvZGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnLmNvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcucGt0X3R5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBQUNUYWcodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZy5wa3RfdHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hYWNUcmFjay5jb25maWcgPSBbNDEsIDE0NSwgMTM2LCAwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWFjVHJhY2suYXVkaW9zYW1wbGVyYXRlID0gNDgwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FhY1RyYWNrLmNoYW5uZWxDb3VudCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FhY1RyYWNrLmNvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FhY1RyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnLmNvZGVjID09PSAnYXZjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcucGt0X3R5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBVkNUYWcodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZy5wa3RfdHlwZSA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZsdlBhcnNlclN0YXRlID0gRkxWUGFyc2VyLlBSRVZfVEFHO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCArPSBjVGFnLnRhZ0RhdGFTaXplO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgRkxWUGFyc2VyU3RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtdXgobGV2ZWwsIHNuLCBudWxsKTtcbiAgICB9XG5cbiAgICByZW11eCAobGV2ZWwsIHNuLCBkYXRhKSB7XG4gICAgICAgIHRoaXMucmVtdXhlci5yZW11eChsZXZlbCwgc24sIHRoaXMuX2FhY1RyYWNrLCB0aGlzLl9hdmNUcmFjaywgdGhpcy5faWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aGlzLnRpbWVPZmZzZXQsIHRoaXMuY29udGlndW91cywgZGF0YSk7XG4gICAgfVxuXG4gICAgZGVzdHJveSAoKSB7XG4gICAgfVxuXG4gICAgX3BhcnNlQUFDVGFnICh0YWcpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy5fYWFjVHJhY2s7XG4gICAgICAgIHZhciBwdHMgPSAwO1xuICAgICAgICB2YXIgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUztcbiAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSAxMDI0ICogOTAwMDAgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICAgIGlmIChhYWNMYXN0UFRTKSB7XG4gICAgICAgICAgICBwdHMgPSBhYWNMYXN0UFRTICsgZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB0cyA9IHRhZy50aW1lc3RhbXAgKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgICAgdW5pdDogdGFnLmRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYWNrLmxlbiArPSB0YWcuZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWFjTGFzdFBUUyA9IHB0cztcbiAgICB9XG5cbiAgICBfcGFyc2VBVkNUYWcgKHRhZykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaztcbiAgICAgICAgdmFyIHVuaXRzID0gdGhpcy5fcGFyc2VBVkNOQUx1KHRhZy5kYXRhKTtcbiAgICB9XG5cbiAgICBfcGFyc2VBVkNOQUx1IChhcnJheSkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWUsIG92ZXJmbG93LCBzdGF0ZSA9IHRoaXMuYXZjTmFsdVN0YXRlO1xuICAgICAgICB2YXIgdW5pdHMgPSBbXSxcbiAgICAgICAgICAgIHVuaXQsIHVuaXRUeXBlLCBsYXN0VW5pdFN0YXJ0LCBsYXN0VW5pdFR5cGU7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAgICAgICAvLyBmaW5kaW5nIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzICgwMCAwMCAwMSBPUiAwMCAwMCAwMCAwMSlcbiAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEgJiYgaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0ID0geyBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBpIC0gc3RhdGUgLSAxKSwgdHlwZTogbGFzdFVuaXRUeXBlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgc3RhcnQgY29kZSBkZWxpbWl0ZXIgaXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiAyIFBFUyBwYWNrZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0YXRlID0gdGhpcy5hdmNOYWx1U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiAoaSA8PSA0IC0gbGFzdFN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCBzdGFydCBkZWxpbWl0ZXIgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGxhc3QgTkFMIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdHMgPSBsYXN0YXZjU2FtcGxlLnVuaXRzLnVuaXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVbml0ID0gbGFzdFVuaXRzW2xhc3RVbml0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RhdmNTYW1wbGUudW5pdHMubGVuZ3RoIC09IGxhc3RTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gbGFzdFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0YXZjU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVbml0cyA9IGxhc3RhdmNTYW1wbGUudW5pdHMudW5pdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVuaXQgPSBsYXN0VW5pdHNbbGFzdFVuaXRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0YXZjU2FtcGxlLnVuaXRzLmxlbmd0aCArPSBvdmVyZmxvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBvdmVyZmxvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQpIHtcbiAgICAgICAgICAgIHVuaXQgPSB7IGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksIHR5cGU6IGxhc3RVbml0VHlwZSwgc3RhdGU6IHN0YXRlIH07XG4gICAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmF2Y05hbHVTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRkxWRGVtdXhlcjsiLCIvKipcbiAqIElEMyBwYXJzZXJcbiAqL1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG4vL2ltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcblxuIGNsYXNzIElEMyB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX2hhc1RpbWVTdGFtcCA9IGZhbHNlO1xuICAgIHZhciBvZmZzZXQgPSAwLCBieXRlMSxieXRlMixieXRlMyxieXRlNCx0YWdTaXplLGVuZFBvcyxoZWFkZXIsbGVuO1xuICAgICAgZG8ge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsMyk7XG4gICAgICAgIG9mZnNldCs9MztcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgSUQzIGhlYWRlclxuICAgICAgICAgIGlmIChoZWFkZXIgPT09ICdJRDMnKSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgMjQgYml0c1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGFnKHMpIGxlbmd0aFxuICAgICAgICAgICAgICBieXRlMSA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgYnl0ZTIgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgICAgICAgIGJ5dGUzID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICBieXRlNCA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgdGFnU2l6ZSA9IChieXRlMSA8PCAyMSkgKyAoYnl0ZTIgPDwgMTQpICsgKGJ5dGUzIDw8IDcpICsgYnl0ZTQ7XG4gICAgICAgICAgICAgIGVuZFBvcyA9IG9mZnNldCArIHRhZ1NpemU7XG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSUQzIHRhZyBmb3VuZCwgc2l6ZS9lbmQ6ICR7dGFnU2l6ZX0vJHtlbmRQb3N9YCk7XG5cbiAgICAgICAgICAgICAgLy8gcmVhZCBJRDMgdGFnc1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlEM0ZyYW1lcyhkYXRhLCBvZmZzZXQsZW5kUG9zKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gZW5kUG9zO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnM0RJJykge1xuICAgICAgICAgICAgICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi40LjAtc3RydWN0dXJlIGNoYXB0ZXIgMy40LiAgIElEM3YyIGZvb3RlclxuICAgICAgICAgICAgICBvZmZzZXQgKz0gNztcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYDNESSBmb290ZXIgZm91bmQsIGVuZDogJHtvZmZzZXR9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICAgIGxlbiA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYElEMyBsZW46ICR7bGVufWApO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNUaW1lU3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0lEMyB0YWcgZm91bmQsIGJ1dCBubyB0aW1lc3RhbXAnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BheWxvYWQgPSBkYXRhLnN1YmFycmF5KDAsbGVuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgcmVhZFVURihkYXRhLHN0YXJ0LGxlbikge1xuXG4gICAgdmFyIHJlc3VsdCA9ICcnLG9mZnNldCA9IHN0YXJ0LCBlbmQgPSBzdGFydCArIGxlbjtcbiAgICBkbyB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW29mZnNldCsrXSk7XG4gICAgfSB3aGlsZShvZmZzZXQgPCBlbmQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfcGFyc2VJRDNGcmFtZXMoZGF0YSxvZmZzZXQsZW5kUG9zKSB7XG4gICAgdmFyIHRhZ0lkLHRhZ0xlbix0YWdTdGFydCx0YWdGbGFncyx0aW1lc3RhbXA7XG4gICAgd2hpbGUob2Zmc2V0ICsgOCA8PSBlbmRQb3MpIHtcbiAgICAgIHRhZ0lkID0gdGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQpO1xuICAgICAgb2Zmc2V0ICs9NDtcblxuICAgICAgdGFnTGVuID0gZGF0YVtvZmZzZXQrK10gPDwgMjQgK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdIDw8IDE2ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXTtcblxuICAgICAgdGFnRmxhZ3MgPSBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdO1xuXG4gICAgICB0YWdTdGFydCA9IG9mZnNldDtcbiAgICAgIC8vbG9nZ2VyLmxvZyhcIklEMyB0YWcgaWQ6XCIgKyB0YWdJZCk7XG4gICAgICBzd2l0Y2godGFnSWQpIHtcbiAgICAgICAgY2FzZSAnUFJJVic6XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ3BhcnNlIGZyYW1lOicgKyBIZXguaGV4RHVtcChkYXRhLnN1YmFycmF5KG9mZnNldCxlbmRQb3MpKSk7XG4gICAgICAgICAgICAvLyBvd25lciBzaG91bGQgYmUgXCJjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcFwiXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQ0KSA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCs9NDQ7XG4gICAgICAgICAgICAgICAgLy8gc21lbGxpbmcgZXZlbiBiZXR0ZXIgISB3ZSBmb3VuZCB0aGUgcmlnaHQgZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgIC8vIHNraXAgbnVsbCBjaGFyYWN0ZXIgKHN0cmluZyBlbmQpICsgMyBmaXJzdCBieXRlc1xuICAgICAgICAgICAgICAgIG9mZnNldCs9IDQ7XG5cbiAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLCB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgICAgICAgICAgICAgIHZhciBwdHMzM0JpdCAgPSBkYXRhW29mZnNldCsrXSAmIDB4MTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUaW1lU3RhbXAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gKChkYXRhW29mZnNldCsrXSA8PCAyMykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQrK10gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0KytdIDw8ICA3KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdKSAvNDU7XG5cbiAgICAgICAgICAgICAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wICAgKz0gNDc3MjE4NTguODQ7IC8vIDJeMzIgLyA5MFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBJRDMgdGltZXN0YW1wIGZvdW5kOiAke3RpbWVzdGFtcH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBoYXNUaW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfVxuXG4gIGdldCBwYXlsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXlsb2FkO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUQzO1xuXG4iLCIvKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuKi9cblxuIGltcG9ydCBBRFRTIGZyb20gJy4vYWR0cyc7XG4gaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG4gaW1wb3J0IEV4cEdvbG9tYiBmcm9tICcuL2V4cC1nb2xvbWInO1xuLy8gaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuIGltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuIGltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4gY2xhc3MgVFNEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgaWQsIHJlbXV4ZXJDbGFzcywgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnJlbXV4ZXJDbGFzcyA9IHJlbXV4ZXJDbGFzcztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmxhc3RDQyA9IDA7XG4gICAgdGhpcy5yZW11eGVyID0gbmV3IHRoaXMucmVtdXhlckNsYXNzKG9ic2VydmVyLCBpZCwgY29uZmlnKTtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDMqMTg4ICYmIGRhdGFbMF0gPT09IDB4NDcgJiYgZGF0YVsxODhdID09PSAweDQ3ICYmIGRhdGFbMioxODhdID09PSAweDQ3KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaExldmVsKCkge1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl9hdmNUcmFjayA9IHtjb250YWluZXIgOiAndmlkZW8vbXAydCcsIHR5cGU6ICd2aWRlbycsIGlkIDotMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMCwgbmJOYWx1IDogMCwgZHJvcHBlZCA6IDB9O1xuICAgIHRoaXMuX2FhY1RyYWNrID0ge2NvbnRhaW5lciA6ICd2aWRlby9tcDJ0JywgdHlwZTogJ2F1ZGlvJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHt0eXBlOiAnaWQzJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICB0aGlzLl90eHRUcmFjayA9IHt0eXBlOiAndGV4dCcsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXM6IFtdLCBsZW46IDB9O1xuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuYXZjTmFsdVN0YXRlID0gMDtcbiAgICB0aGlzLnJlbXV4ZXIuc3dpdGNoTGV2ZWwoKTtcbiAgfVxuXG4gIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbCgpO1xuICAgIHRoaXMucmVtdXhlci5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgYXZjRGF0YSwgYWFjRGF0YSwgaWQzRGF0YSxcbiAgICAgICAgc3RhcnQsIGxlbiA9IGRhdGEubGVuZ3RoLCBzdHQsIHBpZCwgYXRmLCBvZmZzZXQsXG4gICAgICAgIGNvZGVjc09ubHkgPSB0aGlzLnJlbXV4ZXIucGFzc3Rocm91Z2gsXG4gICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuY29udGlndW91cyA9IGZhbHNlO1xuICAgIGlmIChjYyAhPT0gdGhpcy5sYXN0Q0MpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2Rpc2NvbnRpbnVpdHkgZGV0ZWN0ZWQnKTtcbiAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgICAgdGhpcy5sYXN0Q0MgPSBjYztcbiAgICB9XG4gICAgaWYgKGxldmVsICE9PSB0aGlzLmxhc3RMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZygnbGV2ZWwgc3dpdGNoIGRldGVjdGVkJyk7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKCk7XG4gICAgICB0aGlzLmxhc3RMZXZlbCA9IGxldmVsO1xuICAgIH0gZWxzZSBpZiAoc24gPT09ICh0aGlzLmxhc3RTTisxKSkge1xuICAgICAgdGhpcy5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0U04gPSBzbjtcblxuICAgIHZhciBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCxcbiAgICAgICAgYXZjSWQgPSB0aGlzLl9hdmNUcmFjay5pZCxcbiAgICAgICAgYWFjSWQgPSB0aGlzLl9hYWNUcmFjay5pZCxcbiAgICAgICAgaWQzSWQgPSB0aGlzLl9pZDNUcmFjay5pZCxcbiAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZDtcblxuICAgIHZhciBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULFxuICAgICAgICBwYXJzZVBNVCA9IHRoaXMuX3BhcnNlUE1ULFxuICAgICAgICBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLFxuICAgICAgICBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksXG4gICAgICAgIHBhcnNlQUFDUEVTID0gdGhpcy5fcGFyc2VBQUNQRVMuYmluZCh0aGlzKSxcbiAgICAgICAgcGFyc2VJRDNQRVMgID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcblxuICAgIC8vIGRvbid0IHBhcnNlIGxhc3QgVFMgcGFja2V0IGlmIGluY29tcGxldGVcbiAgICBsZW4gLT0gbGVuICUgMTg4O1xuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcbiAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHBpZCkge1xuICAgICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VBVkNQRVMocGFyc2VQRVMoYXZjRGF0YSkpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlY3NPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHZpZGVvIGNvZGVjIGluZm8gQU5EXG4gICAgICAgICAgICAgICAgICAvLyBpZiBhdWRpbyBQSUQgaXMgdW5kZWZpbmVkIE9SIGlmIHdlIGhhdmUgYXVkaW8gY29kZWMgaW5mbyxcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxsIGNvZGVjIGluZm8gIVxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F2Y1RyYWNrLmNvZGVjICYmIChhYWNJZCA9PT0gLTEgfHwgdGhpcy5fYWFjVHJhY2suY29kZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtdXgobGV2ZWwsc24sZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXZjRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhYWNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGFhY0RhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwYXJzZVBFUyhhYWNEYXRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjc09ubHkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGhlcmUgd2Ugbm93IHRoYXQgd2UgaGF2ZSBhdWRpbyBjb2RlYyBpbmZvXG4gICAgICAgICAgICAgICAgICAvLyBpZiB2aWRlbyBQSUQgaXMgdW5kZWZpbmVkIE9SIGlmIHdlIGhhdmUgdmlkZW8gY29kZWMgaW5mbyxcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxsIGNvZGVjIGluZm9zICFcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hYWNUcmFjay5jb2RlYyAmJiAoYXZjSWQgPT09IC0xIHx8IHRoaXMuX2F2Y1RyYWNrLmNvZGVjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbXV4KGxldmVsLHNuLGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFhY0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFhY0RhdGEpIHtcbiAgICAgICAgICAgICAgYWFjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGFhY0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VJRDNQRVMocGFyc2VQRVMoaWQzRGF0YSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkM0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYXZjSWQgPSB0aGlzLl9hdmNUcmFjay5pZCA9IHBhcnNlZFBJRHMuYXZjO1xuICAgICAgICAgICAgYWFjSWQgPSB0aGlzLl9hYWNUcmFjay5pZCA9IHBhcnNlZFBJRHMuYWFjO1xuICAgICAgICAgICAgaWQzSWQgPSB0aGlzLl9pZDNUcmFjay5pZCA9IHBhcnNlZFBJRHMuaWQzO1xuICAgICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgIHN0YXJ0ID0gLTE4ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnVFMgcGFja2V0IGRpZCBub3Qgc3RhcnQgd2l0aCAweDQ3J30pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwYXJzZSBsYXN0IFBFUyBwYWNrZXRcbiAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgcGFyc2VBVkNQRVMocGFyc2VQRVMoYXZjRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoYWFjRGF0YSkge1xuICAgICAgcGFyc2VBQUNQRVMocGFyc2VQRVMoYWFjRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgcGFyc2VJRDNQRVMocGFyc2VQRVMoaWQzRGF0YSkpO1xuICAgIH1cbiAgICB0aGlzLnJlbXV4KGxldmVsLHNuLG51bGwpO1xuICB9XG5cbiAgcmVtdXgobGV2ZWwsIHNuLCBkYXRhKSB7XG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KGxldmVsLCBzbiwgdGhpcy5fYWFjVHJhY2ssIHRoaXMuX2F2Y1RyYWNrLCB0aGlzLl9pZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRoaXMudGltZU9mZnNldCwgdGhpcy5jb250aWd1b3VzLCBkYXRhKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbCgpO1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgfVxuXG4gIF9wYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gICAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgICAvL2xvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gIH1cblxuICBfcGFyc2VQTVQoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdmFyIHNlY3Rpb25MZW5ndGgsIHRhYmxlRW5kLCBwcm9ncmFtSW5mb0xlbmd0aCwgcGlkLCByZXN1bHQgPSB7IGFhYyA6IC0xLCBhdmMgOiAtMSwgaWQzIDogLTF9O1xuICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgIHN3aXRjaChkYXRhW29mZnNldF0pIHtcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYWFjID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmFhYyA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnSUQzIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYXZjID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgICBsb2dnZXIud2FybignSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCwgbm90IHN1cHBvcnRlZCBmb3Igbm93Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX3BhcnNlUEVTKHN0cmVhbSkge1xuICAgIHZhciBpID0gMCwgZnJhZywgcGVzRmxhZ3MsIHBlc1ByZWZpeCwgcGVzTGVuLCBwZXNIZHJMZW4sIHBlc0RhdGEsIHBlc1B0cywgcGVzRHRzLCBwYXlsb2FkU3RhcnRPZmZzZXQsIGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAgIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgICB3aGlsZShkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgICBkYXRhLnNwbGljZSgxLDEpO1xuICAgIH1cbiAgICAvL3JldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICAgIGZyYWcgPSBkYXRhWzBdO1xuICAgIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweEMwKSB7XG4gICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxuICAgICAgICAgIChmcmFnWzEwXSAmIDB4RkYpICogNDE5NDMwNCArLy8gMSA8PCAyMlxuICAgICAgICAgIChmcmFnWzExXSAmIDB4RkUpICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XG4gICAgICAgICAgKGZyYWdbMTNdICYgMHhGRSkgLyAyO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXG4gICAgICAgICAgaWYgKHBlc1B0cyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgICBwZXNQdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcbiAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBFICkgKiA1MzY4NzA5MTIgKy8vIDEgPDwgMjlcbiAgICAgICAgICAgIChmcmFnWzE1XSAmIDB4RkYgKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcbiAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUgKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XG4gICAgICAgICAgICAoZnJhZ1sxN10gJiAweEZGICkgKiAxMjggKy8vIDEgPDwgN1xuICAgICAgICAgICAgKGZyYWdbMThdICYgMHhGRSApIC8gMjtcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgIGlmIChwZXNEdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgcGVzRHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG5cbiAgICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgIC8vcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGZyYWcgPSBkYXRhLnNoaWZ0KCk7XG4gICAgICAgIHZhciBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldC09bGVuO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgICBsZW4tPXBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgICBpKz1sZW47XG4gICAgICB9XG4gICAgICByZXR1cm4ge2RhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW59O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfcGFyc2VBVkNQRVMocGVzKSB7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxuICAgICAgICB1bml0cyA9IHRoaXMuX3BhcnNlQVZDTkFMdShwZXMuZGF0YSksXG4gICAgICAgIHVuaXRzMiA9IFtdLFxuICAgICAgICBkZWJ1ZyA9IGZhbHNlLFxuICAgICAgICBrZXkgPSBmYWxzZSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgZXhwR29sb21iRGVjb2RlcixcbiAgICAgICAgYXZjU2FtcGxlLFxuICAgICAgICBwdXNoLFxuICAgICAgICBpO1xuICAgIC8vIG5vIE5BTHUgZm91bmRcbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwICYmIHNhbXBsZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICB2YXIgbGFzdGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0VW5pdCA9IGxhc3RhdmNTYW1wbGUudW5pdHMudW5pdHNbbGFzdGF2Y1NhbXBsZS51bml0cy51bml0cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBwZXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICB0bXAuc2V0KHBlcy5kYXRhLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgIGxhc3RhdmNTYW1wbGUudW5pdHMubGVuZ3RoICs9IHBlcy5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICB0cmFjay5sZW4gKz0gcGVzLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgLy9mcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG4gICAgdmFyIGRlYnVnU3RyaW5nID0gJyc7XG5cbiAgICB2YXIgcHVzaEFjY2VzVW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHVuaXRzMi5sZW5ndGgpIHtcbiAgICAgICAgLy8gb25seSBwdXNoIEFWQyBzYW1wbGUgaWYgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lIGlzIG5vdCBtYW5kYXRvcnkgT1JcbiAgICAgICAgLy8gICAgaWYga2V5ZnJhbWUgYWxyZWFkeSBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IE9SXG4gICAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAgIC8vICAgICAgICAgIHNhbXBsZXMgYWxyZWFkeSBhcHBlbmRlZCAod2UgYWxyZWFkeSBmb3VuZCBhIGtleWZyYW1lIGluIHRoaXMgZnJhZ21lbnQpIE9SIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXNcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5IHx8XG4gICAgICAgICAgICBrZXkgPT09IHRydWUgfHxcbiAgICAgICAgICAgICh0cmFjay5zcHMgJiYgKHNhbXBsZXMubGVuZ3RoIHx8IHRoaXMuY29udGlndW91cykpKSB7XG4gICAgICAgICAgYXZjU2FtcGxlID0ge3VuaXRzOiB7IHVuaXRzIDogdW5pdHMyLCBsZW5ndGggOiBsZW5ndGh9LCBwdHM6IHBlcy5wdHMsIGR0czogcGVzLmR0cywga2V5OiBrZXl9O1xuICAgICAgICAgIHNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICAgICAgICAgIHRyYWNrLmxlbiArPSBsZW5ndGg7XG4gICAgICAgICAgdHJhY2submJOYWx1ICs9IHVuaXRzMi5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZHJvcHBlZCBzYW1wbGVzLCB0cmFjayBpdFxuICAgICAgICAgIHRyYWNrLmRyb3BwZWQrKztcbiAgICAgICAgfVxuICAgICAgICB1bml0czIgPSBbXTtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgc3dpdGNoKHVuaXQudHlwZSkge1xuICAgICAgICAvL05EUlxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgaWYoZGVidWcpIHtcbiAgICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICdORFIgJztcbiAgICAgICAgICAgfVxuICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9JRFJcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmKGRlYnVnKSB7XG4gICAgICAgICAgICBkZWJ1Z1N0cmluZyArPSAnSURSICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vU0VJXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ1NFSSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih0aGlzLmRpc2NhcmRFUEIodW5pdC5kYXRhKSk7XG5cbiAgICAgICAgICAvLyBza2lwIGZyYW1lVHlwZVxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYiA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAoIWVuZE9mQ2FwdGlvbnMgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSA+IDEpIHtcbiAgICAgICAgICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxuICAgICAgICAgICAgLy8gVE9ETzogbmVlZCB0byByZWFkIHR5cGUgYW5kIHNpemUgaW4gYSB3aGlsZSBsb29wIHRvIGdldCB0aGVtIGFsbFxuICAgICAgICAgICAgaWYgKHBheWxvYWRUeXBlID09PSA0ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcblxuICAgICAgICAgICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxDQ3MgPSAzMSAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gW2ZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBieXRlcyBwZXIgQ0NcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTYW1wbGVJbk9yZGVyKHRoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGk8cGF5bG9hZFNpemU7IGkrKylcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vU1BTXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ1NQUyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighdHJhY2suc3BzKSB7XG4gICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih1bml0LmRhdGEpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvZGVjYXJyYXkgPSB1bml0LmRhdGEuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL1BQU1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYoZGVidWcpIHtcbiAgICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICdQUFMgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ0FVRCAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoQWNjZXNVbml0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYocHVzaCkge1xuICAgICAgICB1bml0czIucHVzaCh1bml0KTtcbiAgICAgICAgbGVuZ3RoKz11bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihkZWJ1ZyB8fCBkZWJ1Z1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coZGVidWdTdHJpbmcpO1xuICAgIH1cbiAgICBwdXNoQWNjZXNVbml0KCk7XG4gIH1cblxuICBfaW5zZXJ0U2FtcGxlSW5PcmRlcihhcnIsIGRhdGEpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgaWYgKGRhdGEucHRzID49IGFycltsZW4tMV0ucHRzKVxuICAgICAge1xuICAgICAgICBhcnIucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICBpZiAoZGF0YS5wdHMgPCBhcnJbcG9zXS5wdHMpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIF9wYXJzZUFWQ05BTHUoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGgsIHZhbHVlLCBvdmVyZmxvdywgc3RhdGUgPSB0aGlzLmF2Y05hbHVTdGF0ZTtcbiAgICB2YXIgdW5pdHMgPSBbXSwgdW5pdCwgdW5pdFR5cGUsIGxhc3RVbml0U3RhcnQsIGxhc3RVbml0VHlwZTtcbiAgICAvL2xvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xuICAgICAgLy8gZmluZGluZyAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyAoMDAgMDAgMDEgT1IgMDAgMDAgMDAgMDEpXG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiggdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaWYoIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgICBpZiAobGFzdFVuaXRTdGFydCkge1xuICAgICAgICAgICAgICB1bml0ID0ge2RhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLCB0eXBlOiBsYXN0VW5pdFR5cGV9O1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgICAgIGxldCBsYXN0U3RhdGUgPSB0aGlzLmF2Y05hbHVTdGF0ZTtcbiAgICAgICAgICAgICAgaWYobGFzdFN0YXRlICYmICAoaSA8PSA0IC0gbGFzdFN0YXRlKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGxhc3RhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdFVuaXRzID0gbGFzdGF2Y1NhbXBsZS51bml0cy51bml0cyxcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdCA9IGxhc3RVbml0c1tsYXN0VW5pdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RhdmNTYW1wbGUudW5pdHMubGVuZ3RoIC09IGxhc3RTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2subGVuIC09IGxhc3RTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuICAgICAgICAgICAgICBvdmVyZmxvdyAgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdHMgPSBsYXN0YXZjU2FtcGxlLnVuaXRzLnVuaXRzLFxuICAgICAgICAgICAgICAgICAgICAgIGxhc3RVbml0ID0gbGFzdFVuaXRzW2xhc3RVbml0cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgICAgICAgbGFzdGF2Y1NhbXBsZS51bml0cy5sZW5ndGggKz0gb3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gb3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCkge1xuICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlIDogc3RhdGV9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgICAgdGhpcy5hdmNOYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICAgKi9cbiAgZGlzY2FyZEVQQihkYXRhKSB7XG4gICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgRVBCUG9zaXRpb25zID0gW10sXG4gICAgICAgIGkgPSAxLFxuICAgICAgICBuZXdMZW5ndGgsIG5ld0RhdGE7XG5cbiAgICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJlxuICAgICAgICAgIGRhdGFbaSArIDFdID09PSAwICYmXG4gICAgICAgICAgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgICAvLyBhcnJheVxuICAgIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICAgIG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gICAgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG5cbiAgX3BhcnNlQUFDUEVTKHBlcykge1xuICAgIHZhciB0cmFjayA9IHRoaXMuX2FhY1RyYWNrLFxuICAgICAgICBkYXRhID0gcGVzLmRhdGEsXG4gICAgICAgIHB0cyA9IHBlcy5wdHMsXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuYXVkaW9Db2RlYyxcbiAgICAgICAgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93LFxuICAgICAgICBhYWNMYXN0UFRTID0gdGhpcy5hYWNMYXN0UFRTLFxuICAgICAgICBjb25maWcsIGZyYW1lTGVuZ3RoLCBmcmFtZUR1cmF0aW9uLCBmcmFtZUluZGV4LCBvZmZzZXQsIGhlYWRlckxlbmd0aCwgc3RhbXAsIGxlbiwgYWFjU2FtcGxlO1xuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGFhY092ZXJGbG93LmJ5dGVMZW5ndGggKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgdG1wLnNldChhYWNPdmVyRmxvdywgMCk7XG4gICAgICB0bXAuc2V0KGRhdGEsIGFhY092ZXJGbG93LmJ5dGVMZW5ndGgpO1xuICAgICAgLy9sb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2FhY092ZXJGbG93LmJ5dGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICBkYXRhID0gdG1wO1xuICAgIH1cbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmIChkYXRhW29mZnNldCsxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHZhciByZWFzb24sIGZhdGFsO1xuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcbiAgICAgICAgcmVhc29uID0gYEFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDoke29mZnNldH1gO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYXRhbCwgcmVhc29uOiByZWFzb259KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5hdWRpb3NhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgIHRyYWNrLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30scmF0ZToke2NvbmZpZy5zYW1wbGVyYXRlfSxuYiBjaGFubmVsOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgICB9XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IDEwMjQgKiA5MDAwMCAvIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZTtcblxuICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgIGlmKGFhY092ZXJGbG93ICYmIGFhY0xhc3RQVFMpIHtcbiAgICAgIHZhciBuZXdQVFMgPSBhYWNMYXN0UFRTK2ZyYW1lRHVyYXRpb247XG4gICAgICBpZihNYXRoLmFicyhuZXdQVFMtcHRzKSA+IDEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSAke01hdGgucm91bmQoKG5ld1BUUy1wdHMpLzkwKX1gKTtcbiAgICAgICAgcHRzPW5ld1BUUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoKG9mZnNldCArIDUpIDwgbGVuKSB7XG4gICAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICAgIGhlYWRlckxlbmd0aCA9ICghIShkYXRhW29mZnNldCArIDFdICYgMHgwMSkgPyA3IDogOSk7XG4gICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgICBmcmFtZUxlbmd0aCA9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExKSB8XG4gICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgICAgICAgICAgICAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcbiAgICAgIGZyYW1lTGVuZ3RoICAtPSBoZWFkZXJMZW5ndGg7XG4gICAgICAvL3N0YW1wID0gcGVzLnB0cztcblxuICAgICAgaWYgKChmcmFtZUxlbmd0aCA+IDApICYmICgob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpIDw9IGxlbikpIHtcbiAgICAgICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgLy9sb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgICAgICBhYWNTYW1wbGUgPSB7dW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcH07XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XG4gICAgICAgIG9mZnNldCArPSBmcmFtZUxlbmd0aCArIGhlYWRlckxlbmd0aDtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgICBmb3IgKCA7IG9mZnNldCA8IChsZW4gLSAxKTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBsZW4pO1xuICAgICAgLy9sb2dnZXIubG9nKGBBQUM6IG92ZXJmbG93IGRldGVjdGVkOiR7bGVuLW9mZnNldH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gYWFjT3ZlckZsb3c7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XG4gIH1cblxuICBfcGFyc2VJRDNQRVMocGVzKSB7XG4gICAgdGhpcy5faWQzVHJhY2suc2FtcGxlcy5wdXNoKHBlcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVFNEZW11eGVyO1xuIiwiZXhwb3J0IGNvbnN0IEVycm9yVHlwZXMgPSB7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICBORVRXT1JLX0VSUk9SOiAnbmV0d29ya0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgTUVESUFfRVJST1I6ICdtZWRpYUVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xuICBPVEhFUl9FUlJPUjogJ290aGVyRXJyb3InXG59O1xuXG5leHBvcnQgY29uc3QgRXJyb3JEZXRhaWxzID0ge1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfRVJST1I6ICdtYW5pZmVzdExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX1RJTUVPVVQ6ICdtYW5pZmVzdExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIE1BTklGRVNUX1BBUlNJTkdfRVJST1I6ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3Qgd2l0aCBvbmx5IGluY29tcGF0aWJsZSBjb2RlY3MgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUjogJ21hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfRVJST1I6ICdsZXZlbExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX1RJTUVPVVQ6ICdsZXZlbExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBzd2l0Y2ggZXJyb3IgLSBkYXRhOiB7IGxldmVsIDogZmF1bHR5IGxldmVsIElkLCBldmVudCA6IGVycm9yIGRlc2NyaXB0aW9ufVxuICBMRVZFTF9TV0lUQ0hfRVJST1I6ICdsZXZlbFN3aXRjaEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjogJ2F1ZGlvVHJhY2tMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVDogJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEZSQUdfTE9BRF9FUlJPUjogJ2ZyYWdMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb29wIGxvYWRpbmcgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOiAnZnJhZ0xvb3BMb2FkaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9USU1FT1VUOiAnZnJhZ0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YTogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvblxuICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBwYXJzaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvblxuICBGUkFHX1BBUlNJTkdfRVJST1I6ICdmcmFnUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgS0VZX0xPQURfRVJST1I6ICdrZXlMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FEX1RJTUVPVVQ6ICdrZXlMb2FkVGltZU91dCcsXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgIGVyciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SOiAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5EX0VSUk9SOiAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORElOR19FUlJPUjogJ2J1ZmZlckFwcGVuZGluZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICBCVUZGRVJfU1RBTExFRF9FUlJPUjogJ2J1ZmZlclN0YWxsZWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgQlVGRkVSX0ZVTExfRVJST1I6ICdidWZmZXJGdWxsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxuICBCVUZGRVJfU0VFS19PVkVSX0hPTEU6ICdidWZmZXJTZWVrT3ZlckhvbGUnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nXG59O1xuIiwiLypcbipcbiogQWxsIG9iamVjdHMgaW4gdGhlIGV2ZW50IGhhbmRsaW5nIGNoYWluIHNob3VsZCBpbmhlcml0IGZyb20gdGhpcyBjbGFzc1xuKlxuKi9cblxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMnO1xuXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscywgLi4uZXZlbnRzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVkRXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMudXNlR2VuZXJpY0hhbmRsZXIgPSB0cnVlO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGlzRXZlbnRIYW5kbGVyKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5oYW5kbGVkRXZlbnRzID09PSAnb2JqZWN0JyAmJiB0aGlzLmhhbmRsZWRFdmVudHMubGVuZ3RoICYmIHR5cGVvZiB0aGlzLm9uRXZlbnQgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdobHNFdmVudEdlbmVyaWMnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JiaWRkZW4gZXZlbnQgbmFtZTogJyArIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy5vbihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmhscy5vZmYoZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBhcmd1bWVudHM6IGV2ZW50IChzdHJpbmcpLCBkYXRhIChhbnkpXG4gICAqL1xuICBvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XG4gIH1cblxuICBvbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSkge1xuICAgIHZhciBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gJ29uJyArIGV2ZW50LnJlcGxhY2UoJ2hscycsICcnKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCAke2V2ZW50fSBoYXMgbm8gZ2VuZXJpYyBoYW5kbGVyIGluIHRoaXMgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNsYXNzICh0cmllZCAke2Z1bmNOYW1lfSlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW2Z1bmNOYW1lXS5iaW5kKHRoaXMsIGRhdGEpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGV2ZW50VG9GdW5jdGlvbi5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKS5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIHByb2Nlc3NpbmcgJHtldmVudH06JHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogZmFsc2UsIGV2ZW50IDogZXZlbnQsIGVyciA6IGVycn0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEhhbmRsZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlyZWQgYmVmb3JlIE1lZGlhU291cmNlIGlzIGF0dGFjaGluZyB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyBtZWRpYSB9XG4gIE1FRElBX0FUVEFDSElORzogJ2hsc01lZGlhQXR0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0FUVEFDSEVEOiAnaGxzTWVkaWFBdHRhY2hlZCcsXG4gIC8vIGZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNIRUQ6ICdobHNNZWRpYURldGFjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXR0ZWRcbiAgQlVGRkVSX1JFU0VUOiAnaGxzQnVmZmVyUmVzZXQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XG4gIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgZGF0YTogeyB0cmFja3MgOiB0cmFja3N9XG4gIEJVRkZFUl9DUkVBVEVEOiAnaGxzQnVmZmVyQ3JlYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gIEJVRkZFUl9BUFBFTkRJTkc6ICdobHNCdWZmZXJBcHBlbmRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcgfVxuICBCVUZGRVJfQVBQRU5ERUQ6ICdobHNCdWZmZXJBcHBlbmRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhXG4gIEJVRkZFUl9FT1M6ICdobHNCdWZmZXJFb3MnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgc2hvdWxkIGJlIGZsdXNoZWQgLSBkYXRhIHtzdGFydE9mZnNldCwgZW5kT2Zmc2V0fVxuICBCVUZGRVJfRkxVU0hJTkc6ICdobHNCdWZmZXJGbHVzaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGhhcyBiZWVuIGZsdXNoZWRcbiAgQlVGRkVSX0ZMVVNIRUQ6ICdobHNCdWZmZXJGbHVzaGVkJyxcbiAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gIE1BTklGRVNUX0xPQURJTkc6ICdobHNNYW5pZmVzdExvYWRpbmcnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdICwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XG4gIE1BTklGRVNUX0xPQURFRDogJ2hsc01hbmlmZXN0TG9hZGVkJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSAsIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgTUFOSUZFU1RfUEFSU0VEOiAnaGxzTWFuaWZlc3RQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGxldmVsIFVSTCAgbGV2ZWwgOiBpZCBvZiBsZXZlbCBiZWluZyBsb2FkZWR9XG4gIExFVkVMX0xPQURJTkc6ICdobHNMZXZlbExvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIExFVkVMX0xPQURFRDogJ2hsc0xldmVsTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQuIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgTEVWRUxfVVBEQVRFRDogJ2hsc0xldmVsVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIFBUUyBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFmdGVyIHBhcnNpbmcgYSBmcmFnbWVudCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCwgZHJpZnQ6IFBUUyBkcmlmdCBvYnNlcnZlZCB3aGVuIHBhcnNpbmcgbGFzdCBmcmFnbWVudCB9XG4gIExFVkVMX1BUU19VUERBVEVEOiAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENIOiAnaGxzTGV2ZWxTd2l0Y2gnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIGRhdGE6IHsgYXVkaW9UcmFja3MgOiBhdWRpb1RyYWNrc31cbiAgQVVESU9fVFJBQ0tTX1VQREFURUQ6ICdobHNBdWRpb1RyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7ICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19TV0lUQ0g6ICdobHNBdWRpb1RyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogYXVkaW8gdHJhY2sgVVJMICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19MT0FESU5HOiAnaGxzQXVkaW9UcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBBVURJT19UUkFDS19MT0FERUQ6ICdobHNBdWRpb1RyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPQURJTkc6ICdobHNGcmFnTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZH19XG4gIEZSQUdfTE9BRF9QUk9HUkVTUzogJ2hsc0ZyYWdMb2FkUHJvZ3Jlc3MnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGFib3J0aW5nIGZvciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gLSBkYXRhOiB7ZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEOiAnaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGh9fVxuICBGUkFHX0xPQURFRDogJ2hsc0ZyYWdMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBsZXZlbCA6IGxldmVsSWQsIHNuIDogc2VxdWVuY2UgbnVtYmVyLCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudH1cbiAgRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVDogJ2hsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgc2VpIHRleHQgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsICwgbGV2ZWwgOiBsZXZlbElkLCBzbiA6IHNlcXVlbmNlIG51bWJlciwgc2FtcGxlcyA6IFsgc2VpIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfVVNFUkRBVEE6ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgLCBsZXZlbCA6IGxldmVsSWQsIHNuIDogc2VxdWVuY2UgbnVtYmVyLCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19NRVRBREFUQTogJ2hsc0ZyYWdQYXJzaW5nTWV0YWRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgRlJBR19QQVJTSU5HX0RBVEE6ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQ7IGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIH1cbiAgRlJBR19QQVJTRUQ6ICdobHNGcmFnUGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCByZW11eGVkIE1QNCBib3hlcyBoYXZlIGFsbCBiZWVuIGFwcGVuZGVkIGludG8gU291cmNlQnVmZmVyIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCB0cGFyc2VkLCB0YnVmZmVyZWQsIGxlbmd0aH0gfVxuICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0NIQU5HRUQ6ICdobHNGcmFnQ2hhbmdlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7Y3VyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lc31cbiAgRlBTX0RST1A6ICdobHNGcHNEcm9wJyxcbiAgLy90cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7bGV2ZWwsIGRyb3BwZWRsZXZlbH1cbiAgRlBTX0RST1BfTEVWRUxfQ0FQUElORzogJ2hsc0Zwc0Ryb3BMZXZlbENhcHBpbmcnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBlcnJvciBldmVudCAtIGRhdGE6IHsgdHlwZSA6IGVycm9yIHR5cGUsIGRldGFpbHMgOiBlcnJvciBkZXRhaWxzLCBmYXRhbCA6IGlmIHRydWUsIGhscy5qcyBjYW5ub3Qvd2lsbCBub3QgdHJ5IHRvIHJlY292ZXIsIGlmIGZhbHNlLCBobHMuanMgd2lsbCB0cnkgdG8gcmVjb3ZlcixvdGhlciBlcnJvciBzcGVjaWZpYyBkYXRhfVxuICBFUlJPUjogJ2hsc0Vycm9yJyxcbiAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGVcbiAgREVTVFJPWUlORzogJ2hsc0Rlc3Ryb3lpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FESU5HOiAnaGxzS2V5TG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGtleSBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aH19XG4gIEtFWV9MT0FERUQ6ICdobHNLZXlMb2FkZWQnLFxuICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YToge3ByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZX1cbiAgU1RSRUFNX1NUQVRFX1RSQU5TSVRJT046ICdobHNTdHJlYW1TdGF0ZVRyYW5zaXRpb24nXG59O1xuIiwiLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG5cbmNsYXNzIEFBQyB7XG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjaGFubmVsQ291bnQpIHtcbiAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUM7XG4iLCIvKipcbiAqIEJ1ZmZlciBIZWxwZXIgY2xhc3MsIHByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgYnVmZmVyIGxlbmd0aCByZXRyaWV2YWxcbiovXG5cblxuY2xhc3MgQnVmZmVySGVscGVyIHtcblxuICBzdGF0aWMgYnVmZmVySW5mbyhtZWRpYSwgcG9zLG1heEhvbGVEdXJhdGlvbikge1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdmFyIHZidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkLCBidWZmZXJlZCA9IFtdLGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcmVkLnB1c2goe3N0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLHBvcyxtYXhIb2xlRHVyYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge2xlbjogMCwgc3RhcnQ6IDAsIGVuZDogMCwgbmV4dFN0YXJ0IDogdW5kZWZpbmVkfSA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGJ1ZmZlcmVkSW5mbyhidWZmZXJlZCxwb3MsbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgdmFyIGJ1ZmZlcmVkMiA9IFtdLFxuICAgICAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxuICAgICAgICBidWZmZXJMZW4sYnVmZmVyU3RhcnQsIGJ1ZmZlckVuZCxidWZmZXJTdGFydE5leHQsaTtcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgLy8gY29uc2lkZXIgdGhhdCBob2xlcyBzbWFsbGVyIHRoYW4gbWF4SG9sZUR1cmF0aW9uIGFyZSBpcnJlbGV2YW50IGFuZCBidWlsZCBhbm90aGVyXG4gICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBidWYybGVuID0gYnVmZmVyZWQyLmxlbmd0aDtcbiAgICAgIGlmKGJ1ZjJsZW4pIHtcbiAgICAgICAgdmFyIGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcbiAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgaWYoKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCkgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgIGlmKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBidWZmZXJMZW4gPSAwLCBidWZmZXJTdGFydCA9IGJ1ZmZlckVuZCA9IHBvczsgaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0ID0gIGJ1ZmZlcmVkMltpXS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBidWZmZXJlZDJbaV0uZW5kO1xuICAgICAgLy9sb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPCBzdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydCA6IGJ1ZmZlclN0YXJ0TmV4dH07XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJIZWxwZXI7XG4iLCIvKipcbiAqIExldmVsIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4qL1xuXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgTGV2ZWxIZWxwZXIge1xuXG4gIHN0YXRpYyBtZXJnZURldGFpbHMob2xkRGV0YWlscyxuZXdEZXRhaWxzKSB7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgob2xkRGV0YWlscy5zdGFydFNOLG5ld0RldGFpbHMuc3RhcnRTTiktbmV3RGV0YWlscy5zdGFydFNOLFxuICAgICAgICBlbmQgPSBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLG5ld0RldGFpbHMuZW5kU04pLW5ld0RldGFpbHMuc3RhcnRTTixcbiAgICAgICAgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgIG9sZGZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICBuZXdmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgY2NPZmZzZXQgPTAsXG4gICAgICAgIFBUU0ZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgICBpZiAoIGVuZCA8IHN0YXJ0KSB7XG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgICBmb3IodmFyIGkgPSBzdGFydCA7IGkgPD0gZW5kIDsgaSsrKSB7XG4gICAgICB2YXIgb2xkRnJhZyA9IG9sZGZyYWdtZW50c1tkZWx0YStpXSxcbiAgICAgICAgICBuZXdGcmFnID0gbmV3ZnJhZ21lbnRzW2ldO1xuICAgICAgaWYgKG5ld0ZyYWcgJiYgb2xkRnJhZykge1xuICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgICBpZiAoIWlzTmFOKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihjY09mZnNldCkge1xuICAgICAgbG9nZ2VyLmxvZyhgZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50YCk7XG4gICAgICBmb3IoaSA9IDAgOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICBuZXdmcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG4gICAgaWYoUFRTRnJhZykge1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhuZXdEZXRhaWxzLFBUU0ZyYWcuc24sUFRTRnJhZy5zdGFydFBUUyxQVFNGcmFnLmVuZFBUUyxQVFNGcmFnLnN0YXJ0RFRTLFBUU0ZyYWcuZW5kRFRTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZGZyYWdtZW50cyByYW5nZVxuICAgICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgICBpZiAoZGVsdGEgPj0gMCAmJiBkZWx0YSA8IG9sZGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWRqdXN0IHN0YXJ0IGJ5IHNsaWRpbmcgb2Zmc2V0XG4gICAgICAgIHZhciBzbGlkaW5nID0gb2xkZnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcbiAgICAgICAgZm9yKGkgPSAwIDsgaSA8IG5ld2ZyYWdtZW50cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICBuZXdmcmFnbWVudHNbaV0uc3RhcnQgKz0gc2xpZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgaXQgbWVhbnMgd2UgaGF2ZSBmcmFnbWVudHMgb3ZlcmxhcHBpbmcgYmV0d2VlblxuICAgIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXG4gICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG9sZERldGFpbHMuUFRTS25vd247XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscyxzbixzdGFydFBUUyxlbmRQVFMsc3RhcnREVFMsZW5kRFRTKSB7XG4gICAgdmFyIGZyYWdJZHgsIGZyYWdtZW50cywgZnJhZywgaTtcbiAgICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICAgIGlmIChzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gICAgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnSWR4XTtcbiAgICBpZighaXNOYU4oZnJhZy5zdGFydFBUUykpIHtcbiAgICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgICAgbGV0IGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZy5zdGFydFBUUy1zdGFydFBUUyk7XG4gICAgICBpZiAoaXNOYU4oZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLGZyYWcuZGVsdGFQVFMpO1xuICAgICAgfVxuICAgICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUyxmcmFnLnN0YXJ0UFRTKTtcbiAgICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZy5lbmRQVFMpO1xuICAgICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUyxmcmFnLnN0YXJ0RFRTKTtcbiAgICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICAgIH1cblxuICAgIHZhciBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcblxuICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gICAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gICAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICAgIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICAgIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gICAgZm9yKGkgPSBmcmFnSWR4IDsgaSA+IDAgOyBpLS0pIHtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsaSxpLTEpO1xuICAgIH1cblxuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gICAgZm9yKGkgPSBmcmFnSWR4IDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxIDsgaSsrKSB7XG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVQVFMoZnJhZ21lbnRzLGksaSsxKTtcbiAgICB9XG4gICAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XG4gICAgLy9sb2dnZXIubG9nKGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgc3RhcnQvZW5kOiR7c3RhcnRQVFMudG9GaXhlZCgzKX0vJHtlbmRQVFMudG9GaXhlZCgzKX1gKTtcblxuICAgIHJldHVybiBkcmlmdDtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVQVFMoZnJhZ21lbnRzLGZyb21JZHgsIHRvSWR4KSB7XG4gICAgdmFyIGZyYWdGcm9tID0gZnJhZ21lbnRzW2Zyb21JZHhdLGZyYWdUbyA9IGZyYWdtZW50c1t0b0lkeF0sIGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUztcbiAgICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgIGlmKCFpc05hTihmcmFnVG9QVFMpKSB7XG4gICAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgICAgZnJhZ0Zyb20uZHVyYXRpb24gPSBmcmFnVG9QVFMtZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICAgIGlmKGZyYWdGcm9tLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnRnJvbS5zbn0sbGV2ZWwgJHtmcmFnRnJvbS5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgICAgaWYoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnVG8uc259LGxldmVsICR7ZnJhZ1RvLmxldmVsfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExldmVsSGVscGVyO1xuIiwiLyoqXG4gKiBITFMgaW50ZXJmYWNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCBGcmFnbWVudExvYWRlciBmcm9tICcuL2xvYWRlci9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IEFickNvbnRyb2xsZXIgZnJvbSAgICAnLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyJztcbmltcG9ydCBCdWZmZXJDb250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBMZXZlbENvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBUaW1lbGluZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQge2xvZ2dlciwgZW5hYmxlTG9nc30gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuLy9pbXBvcnQgRmV0Y2hMb2FkZXIgZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IEtleUxvYWRlciBmcm9tICcuL2xvYWRlci9rZXktbG9hZGVyJztcbmltcG9ydCBDdWVzIGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5cbmNsYXNzIEhscyB7XG5cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIC8vIHJlcGxhY2VkIHdpdGggYnJvd3NlcmlmeS12ZXJzaW9uaWZ5IHRyYW5zZm9ybVxuICAgIHJldHVybiAnX19WRVJTSU9OX18nO1xuICB9XG5cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAod2luZG93Lk1lZGlhU291cmNlICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnRzKCkge1xuICAgIHJldHVybiBFdmVudDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpIHtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzKCkge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcoKSB7XG4gICAgaWYoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgSGxzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgICAgICAgICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAgICAgICAgIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAgICAgICAgIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gICAgICAgICAgbWF4QnVmZmVySG9sZTogMC41LFxuICAgICAgICAgIG1heFNlZWtIb2xlOiAyLFxuICAgICAgICAgIHNlZWtIb2xlTnVkZ2VEdXJhdGlvbiA6IDAuMDEsXG4gICAgICAgICAgc3RhbGxlZEluQnVmZmVyZWROdWRnZVRocmVzaG9sZDogMTAsXG4gICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA6IDAuMixcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6MyxcbiAgICAgICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LFxuICAgICAgICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsXG4gICAgICAgICAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAgICAgICAgIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAgICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgICAgICAgICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgICAgICAgICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgICAgICAgICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgICAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgICAgICAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgICAgICAgICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICAgICAgICAgIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICAgICAgICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgICAgICAgZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkOiAzLFxuICAgICAgICAgIHN0YXJ0RnJhZ1ByZWZldGNoIDogZmFsc2UsXG4gICAgICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsXG4gICAgICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgICAgICAgICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLFxuICAgICAgICAgIGxvYWRlcjogWGhyTG9hZGVyLFxuICAgICAgICAgIC8vbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgICAgICAgICBmTG9hZGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgcExvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGFickNvbnRyb2xsZXIgOiBBYnJDb250cm9sbGVyLFxuICAgICAgICAgIGJ1ZmZlckNvbnRyb2xsZXIgOiBCdWZmZXJDb250cm9sbGVyLFxuICAgICAgICAgIGNhcExldmVsQ29udHJvbGxlciA6IENhcExldmVsQ29udHJvbGxlcixcbiAgICAgICAgICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXI6IFN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgYXVkaW9TdHJlYW1Db250cm9sbGVyIDogQXVkaW9TdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgIHRpbWVsaW5lQ29udHJvbGxlcjogVGltZWxpbmVDb250cm9sbGVyLFxuICAgICAgICAgIGN1ZUhhbmRsZXI6IEN1ZXMsXG4gICAgICAgICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsXG4gICAgICAgICAgZW5hYmxlTVAyVFBhc3NUaHJvdWdoIDogZmFsc2UsXG4gICAgICAgICAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsXG4gICAgICAgICAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgICAgICAgICBhYnJFd21hRmFzdExpdmU6IDUsXG4gICAgICAgICAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAgICAgICAgIGFickV3bWFGYXN0Vm9EOiA0LFxuICAgICAgICAgIGFickV3bWFTbG93Vm9EOiAxNSxcbiAgICAgICAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzXG4gICAgICAgICAgYWJyQmFuZFdpZHRoRmFjdG9yIDogMC44LFxuICAgICAgICAgIGFickJhbmRXaWR0aFVwRmFjdG9yIDogMC43XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIHN0YXRpYyBzZXQgRGVmYXVsdENvbmZpZyhkZWZhdWx0Q29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB2YXIgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xuXG4gICAgaWYgKChjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpICYmIChjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb25cXCd0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb24nKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgaWYgKHByb3AgaW4gY29uZmlnKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGNvbmZpZ1twcm9wXSA9IGRlZmF1bHRDb25maWdbcHJvcF07XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgICB9XG5cbiAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1Zyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xuICAgICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICAgIH07XG5cbiAgICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gb2JzZXJ2ZXIub24uYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy5vZmYgPSBvYnNlcnZlci5vZmYuYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy50cmlnZ2VyID0gb2JzZXJ2ZXIudHJpZ2dlci5iaW5kKG9ic2VydmVyKTtcbiAgICB0aGlzLnBsYXlsaXN0TG9hZGVyID0gbmV3IFBsYXlsaXN0TG9hZGVyKHRoaXMpO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIodGhpcyk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IGNvbmZpZy5zdHJlYW1Db250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyID0gbmV3IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IEF1ZGlvVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMua2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5ERVNUUk9ZSU5HKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5wbGF5bGlzdExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcHNDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICB0aGlzLm9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNISU5HLCB7bWVkaWE6IG1lZGlhfSk7XG4gIH1cblxuICBkZXRhY2hNZWRpYSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgbG9hZFNvdXJjZSh1cmwpIHtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7dXJsfWApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BRElORywge3VybDogdXJsfSk7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbj0tMSkge1xuICAgIGxvZ2dlci5sb2coJ3N0YXJ0TG9hZCcpO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICB9XG5cbiAgc3RvcExvYWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG5cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gYWxsIHF1YWxpdHkgbGV2ZWxzICoqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gIH1cblxuICAvKiogUmV0dXJuIGN1cnJlbnQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAqKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qIHNldCBxdWFsaXR5IGxldmVsIGltbWVkaWF0ZWx5ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqIFJldHVybiBuZXh0IHBsYXliYWNrIHF1YWxpdHkgbGV2ZWwgKHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBmcmFnbWVudCkgKiovXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBmb3IgbmV4dCBmcmFnbWVudCAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIGN1cnJlbnQvbGFzdCBsb2FkZWQgZnJhZ21lbnQgKiovXG4gIGdldCBsb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG5cbiAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgZm9yIGN1cnJlbnQvbmV4dCBsb2FkZWQgZnJhZ21lbnQgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKiBzZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAqKi9cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWw7XG4gIH1cblxuICAvKiogc2V0IGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAqKi9cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgZmlyc3RMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgKiovXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICB9XG5cbiAgLyoqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgKiovXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiBjaGVjayBpZiB3ZSBhcmUgaW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBtb2RlICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkKCkge1xuICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcbiAgfVxuXG4gIC8qIHJldHVybiBtYW51YWwgbGV2ZWwgKi9cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcztcbiAgfVxuXG4gIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cykgKiovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgcmV0dXJuIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjaztcbiAgfVxuXG4gIC8qKiBzZWxlY3QgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cyoqL1xuICBzZXQgYXVkaW9UcmFjayhhdWRpb1RyYWNrSWQpIHtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIbHM7XG4iLCIvLyBUaGlzIGlzIG1vc3RseSBmb3Igc3VwcG9ydCBvZiB0aGUgZXM2IG1vZHVsZSBleHBvcnRcbi8vIHN5bnRheCB3aXRoIHRoZSBiYWJlbCBjb21waWxlciwgaXQgbG9va3MgbGlrZSBpdCBkb2VzbnQgc3VwcG9ydFxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9obHMuanMnKS5kZWZhdWx0O1xuIiwiLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25GcmFnTG9hZGluZyhkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgZnJhZy5sb2FkZWQgPSAwO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBmcmFnbWVudCBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIGxvYWRlciAgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBmcmFnLmxvYWRlciA9IHR5cGVvZihjb25maWcuZkxvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5mTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuXG4gICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IGZyYWcudXJsLCBmcmFnIDogZnJhZywgcmVzcG9uc2VUeXBlIDogJ2FycmF5YnVmZmVyJywgcHJvZ3Jlc3NEYXRhIDogZmFsc2V9O1xuICAgIGxldCBzdGFydCA9IGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQsIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgIGlmICghaXNOYU4oc3RhcnQpICYmICFpc05hTihlbmQpKSB7XG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBlbmQ7XG4gICAgfVxuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5IDogMCAsIHJldHJ5RGVsYXkgOiAwLCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcbiAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzcyA6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvciA6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0IDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBvblByb2dyZXNzOiB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpfTtcbiAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kYXRhLCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURFRCwge3BheWxvYWQ6IHBheWxvYWQsIGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0c30pO1xuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gIH0gXG5cbiAgbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWd9KTtcbiAgfVxuXG4gIC8vIGRhdGEgd2lsbCBiZSB1c2VkIGZvciBwcm9ncmVzc2l2ZSBwYXJzaW5nXG4gIGxvYWRwcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBmcmFnLmxvYWRlZCA9IHN0YXRzLmxvYWRlZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywge2ZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0c30pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZyYWdtZW50TG9hZGVyO1xuIiwiLypcbiAqIERlY3J5cHQga2V5IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgS2V5TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LktFWV9MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgIHRoaXMuZGVjcnlwdHVybCA9IG51bGw7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGluZyhkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhLFxuICAgICAgICB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgICAgIC8vIGlmIHVyaSBpcyBkaWZmZXJlbnQgZnJvbSBwcmV2aW91cyBvbmUgb3IgaWYgZGVjcnlwdCBrZXkgbm90IHJldHJpZXZlZCB5ZXRcbiAgICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZToke3R5cGV9YCk7XG4gICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5sb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgICAgICB0aGlzLmRlY3J5cHR1cmwgPSB1cmk7XG4gICAgICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG5cbiAgICAgICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmwgOiB1cmksIGZyYWcgOiBmcmFnLCByZXNwb25zZVR5cGUgOiAnYXJyYXlidWZmZXInfTtcbiAgICAgICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSAsIHJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcbiAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XG4gICAgICAgIGZyYWcubG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgbG9hZGVkIHRoaXMga2V5LCByZXR1cm4gaXRcbiAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0gdGhpcy5kZWNyeXB0a2V5O1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHtmcmFnOiBmcmFnfSk7XG4gICAgICB9XG4gIH1cblxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7ZnJhZzogZnJhZ30pO1xuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gIH1cblxuICBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleUxvYWRlcjtcbiIsIi8qKlxuICogUGxheWxpc3QgTG9hZGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBVUkxIZWxwZXIgZnJvbSAnLi4vdXRpbHMvdXJsJztcbmltcG9ydCBBdHRyTGlzdCBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcpO1xuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbWFuaWZlc3QnfSk7XG4gIH1cblxuICBvbkxldmVsTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbGV2ZWwnLCBsZXZlbCA6IGRhdGEubGV2ZWwsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnYXVkaW9UcmFjaycsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgbG9hZCh1cmwsIGNvbnRleHQpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgICByZXRyeSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgcmV0cnlEZWxheSxcbiAgICAgICAgbWF4UmV0cnlEZWxheTtcbiAgICBpZihjb250ZXh0LnR5cGUgPT09ICdtYW5pZmVzdCcpIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVPdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVPdXQ7XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsZXQgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IHVybCkge1xuICAgICAgICBsb2dnZXIud2FybihgcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6JHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXIgID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBjb250ZXh0LmxvYWRlciA9IHR5cGVvZihjb25maWcucExvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5wTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgIGNvbnRleHQudXJsID0gdXJsO1xuICAgIGNvbnRleHQucmVzcG9uc2VUeXBlID0gJyc7XG5cbiAgICBsZXQgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogdGltZW91dCwgbWF4UmV0cnkgOiByZXRyeSAsIHJldHJ5RGVsYXkgOiByZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5IDogbWF4UmV0cnlEZWxheX07XG4gICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcbiAgfVxuXG4gIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgcmV0dXJuIFVSTEhlbHBlci5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCk7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIGxldCBsZXZlbHMgPSBbXSwgcmVzdWx0O1xuXG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbiAgICBjb25zdCByZSA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCl7XG4gICAgICBjb25zdCBsZXZlbCA9IHt9O1xuXG4gICAgICB2YXIgYXR0cnMgPSBsZXZlbC5hdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgbGV2ZWwudXJsID0gdGhpcy5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG5cbiAgICAgIHZhciByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgIGlmKHJlc29sdXRpb24pIHtcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcblxuICAgICAgdmFyIGNvZGVjcyA9IGF0dHJzLkNPREVDUztcbiAgICAgIGlmKGNvZGVjcykge1xuICAgICAgICBjb2RlY3MgPSBjb2RlY3Muc3BsaXQoJywnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IHRoaXMuYXZjMXRvYXZjb3RpKGNvZGVjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IGNvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbHM7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlKSB7XG4gICAgbGV0IHJlc3VsdCwgbWVkaWFzID0gW107XG5cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbSBpcyB5b3VyIGZyaWVuZFxuICAgIGNvbnN0IHJlID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG4gICAgd2hpbGUgKChyZXN1bHQgPSByZS5leGVjKHN0cmluZykpICE9IG51bGwpe1xuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcbiAgICAgIHZhciBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgaWYoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XG4gICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5mb3JjZWQgPSAoYXR0cnMuRk9SQ0VEID09PSAnWUVTJyk7XG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICBtZWRpYS51cmwgPSB0aGlzLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGlmKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgICBtZWRpYS5uYW1lID0gbWVkaWEubGFuZztcbiAgICAgICAgfVxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZWRpYXM7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gY3JlYXRlIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3IgYSBnaXZlbiBzZWdtZW50XG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3IgKHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgdWludDhWaWV3W2ldID0gKHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGdldCBhIGZyYWdtZW50J3MgZGVjcnlwdGlvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBwYXJzZWQgZW5jcnlwdGlvbiBrZXkgZGF0YVxuICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXG4gICAqIEBwYXJhbSBzZWdtZW50TnVtYmVyIC0gdGhlIGZyYWdtZW50J3Mgc2VnbWVudCBudW1iZXJcbiAgICogQHJldHVybnMgeyp9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAqL1xuICBmcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5IChsZXZlbGtleSwgc2VnbWVudE51bWJlcikge1xuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGxldmVsa2V5O1xuXG4gICAgaWYgKGxldmVsa2V5ICYmIGxldmVsa2V5Lm1ldGhvZCAmJiBsZXZlbGtleS51cmkgJiYgIWxldmVsa2V5Lml2KSB7XG4gICAgICBkZWNyeXB0ZGF0YSA9IHRoaXMuY2xvbmVPYmoobGV2ZWxrZXkpO1xuICAgICAgZGVjcnlwdGRhdGEuaXYgPSB0aGlzLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgfVxuXG4gIGF2YzF0b2F2Y290aShjb2RlYykge1xuICAgIHZhciByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29kZWM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjbG9uZU9iaihvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxuXG4gIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlKSB7XG4gICAgdmFyIGN1cnJlbnRTTiA9IDAsXG4gICAgICAgIGZyYWdkZWNyeXB0ZGF0YSxcbiAgICAgICAgdG90YWxkdXJhdGlvbiA9IDAsXG4gICAgICAgIGxldmVsID0ge3R5cGU6IG51bGwsIHZlcnNpb246IG51bGwsIHVybDogYmFzZXVybCwgZnJhZ21lbnRzOiBbXSwgbGl2ZTogdHJ1ZSwgc3RhcnRTTjogMH0sXG4gICAgICAgIGxldmVsa2V5ID0ge21ldGhvZCA6IG51bGwsIGtleSA6IG51bGwsIGl2IDogbnVsbCwgdXJpIDogbnVsbH0sXG4gICAgICAgIGNjID0gMCxcbiAgICAgICAgcHJvZ3JhbURhdGVUaW1lID0gbnVsbCxcbiAgICAgICAgZnJhZyA9IG51bGwsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgcmVnZXhwLFxuICAgICAgICBkdXJhdGlvbiA9IG51bGwsXG4gICAgICAgIHRpdGxlID0gbnVsbCxcbiAgICAgICAgYnl0ZVJhbmdlRW5kT2Zmc2V0ID0gbnVsbCxcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBudWxsLFxuICAgICAgICB0YWdMaXN0ID0gW107XG5cbiAgICByZWdleHAgPSAvKD86KD86IyhFWFRNM1UpKXwoPzojRVhULVgtKFBMQVlMSVNULVRZUEUpOiguKykpfCg/OiNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOihcXGQrKSl8KD86I0VYVC1YLShUQVJHRVREVVJBVElPTik6KFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVChJTkYpOihcXGQrKD86XFwuXFxkKyk/KSg/OiwoLiopKT8pfCg/Oig/ISMpKCkoXFxTLispKXwoPzojRVhULVgtKEJZVEVSQU5HRSk6KFxcZCsoPzpAXFxkKyg/OlxcLlxcZCspPyk/KXwoPzojRVhULVgtKEVORExJU1QpKXwoPzojRVhULVgtKERJUylDT05USU5VSVRZKSl8KD86I0VYVC1YLShQUk9HUkFNLURBVEUtVElNRSk6KC4rKSl8KD86I0VYVC1YLShWRVJTSU9OKTooXFxkKykpfCg/OigjKSguKik6KC4qKSl8KD86KCMpKC4qKSkpKD86LiopXFxyP1xcbj8vZztcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ2V4cC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuc2hpZnQoKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24obikgeyByZXR1cm4gKG4gIT09IHVuZGVmaW5lZCk7IH0pO1xuICAgICAgc3dpdGNoIChyZXN1bHRbMF0pIHtcbiAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgbGV2ZWwudHlwZSA9IHJlc3VsdFsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHJlc3VsdFsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IHBhcnNlRmxvYXQocmVzdWx0WzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHJlc3VsdFsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICBjYysrO1xuICAgICAgICAgIHRhZ0xpc3QucHVzaChyZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdCWVRFUkFOR0UnOlxuICAgICAgICAgIHZhciBwYXJhbXMgPSByZXN1bHRbMV0uc3BsaXQoJ0AnKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnl0ZVJhbmdlRW5kT2Zmc2V0ID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJTkYnOlxuICAgICAgICAgIGR1cmF0aW9uID0gcGFyc2VGbG9hdChyZXN1bHRbMV0pO1xuICAgICAgICAgIHRpdGxlID0gcmVzdWx0WzJdID8gcmVzdWx0WzJdIDogbnVsbDtcbiAgICAgICAgICB0YWdMaXN0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJzogLy8gdXJsXG4gICAgICAgICAgaWYgKCFpc05hTihkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgICAgZnJhZ2RlY3J5cHRkYXRhID0gdGhpcy5mcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5KGxldmVsa2V5LCBzbik7XG4gICAgICAgICAgICB2YXIgdXJsID0gcmVzdWx0WzFdID8gdGhpcy5yZXNvbHZlKHJlc3VsdFsxXSwgYmFzZXVybCkgOiBudWxsO1xuICAgICAgICAgICAgZnJhZyA9IHt1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc246IHNuLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICAgICAgZGVjcnlwdGRhdGEgOiBmcmFnZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW1EYXRlVGltZTogcHJvZ3JhbURhdGVUaW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0OiB0YWdMaXN0fTtcbiAgICAgICAgICAgIC8vIG9ubHkgaW5jbHVkZSBieXRlIHJhbmdlIG9wdGlvbnMgaWYgdXNlZC9uZWVkZWRcbiAgICAgICAgICAgIGlmKGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQgPSBieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC5mcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZHVyYXRpb247XG4gICAgICAgICAgICBkdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aXRsZSA9IG51bGw7XG4gICAgICAgICAgICBieXRlUmFuZ2VTdGFydE9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICBwcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICAgICAgdGFnTGlzdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgIHZhciBkZWNyeXB0cGFyYW1zID0gcmVzdWx0WzFdO1xuICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChkZWNyeXB0cGFyYW1zKTtcbiAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgICBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJLFxuICAgICAgICAgICAgICBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgIGxldmVsa2V5ID0geyBtZXRob2Q6IG51bGwsIGtleTogbnVsbCwgaXY6IG51bGwsIHVyaTogbnVsbCB9O1xuICAgICAgICAgICAgaWYgKChkZWNyeXB0dXJpKSAmJiAoZGVjcnlwdG1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xuICAgICAgICAgICAgICBsZXZlbGtleS5tZXRob2QgPSBkZWNyeXB0bWV0aG9kO1xuICAgICAgICAgICAgICAvLyBVUkkgdG8gZ2V0IHRoZSBrZXlcbiAgICAgICAgICAgICAgbGV2ZWxrZXkudXJpID0gdGhpcy5yZXNvbHZlKGRlY3J5cHR1cmksIGJhc2V1cmwpO1xuICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICBsZXQgc3RhcnRQYXJhbXMgPSByZXN1bHRbMV07XG4gICAgICAgICAgbGV0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRQYXJhbXMpO1xuICAgICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQpIHtcbiAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1BST0dSQU0tREFURS1USU1FJzpcbiAgICAgICAgICBwcm9ncmFtRGF0ZVRpbWUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKHJlc3VsdFsxXSkpO1xuICAgICAgICAgIHRhZ0xpc3QucHVzaChyZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICByZXN1bHQuc2hpZnQoKTtcbiAgICAgICAgICB0YWdMaXN0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy9sb2dnZXIubG9nKCdmb3VuZCAnICsgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCArICcgZnJhZ21lbnRzJyk7XG4gICAgaWYoZnJhZyAmJiAhZnJhZy51cmwpIHtcbiAgICAgIGxldmVsLmZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24tPWZyYWcuZHVyYXRpb247XG4gICAgfVxuICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xuICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgIGxldmVsLmVuZFNOID0gY3VycmVudFNOIC0gMTtcbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cblxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RyaW5nID0gcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgdXJsID0gcmVzcG9uc2UudXJsLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlLFxuICAgICAgICBpZCA9IGNvbnRleHQuaWQsXG4gICAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbCxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG5cbiAgICB0aGlzLmxvYWRlcnNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgLy8gcmVzcG9uc2VVUkwgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzIChpdCBpcyB1c2VkIHRvIGRldGVjdCBVUkwgcmVkaXJlY3Rpb24pXG4gICAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIGluaXRpYWwgVVJMXG4gICAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgICB9XG4gICAgc3RhdHMudGxvYWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvL3N0YXRzLm10aW1lID0gbmV3IERhdGUodGFyZ2V0LmdldFJlc3BvbnNlSGVhZGVyKCdMYXN0LU1vZGlmaWVkJykpO1xuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpID09PSAwKSB7XG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRJTkY6JykgPiAwKSB7XG4gICAgICAgIGxldCBpc0xldmVsID0gKHR5cGUgIT09ICdhdWRpb1RyYWNrJyksXG4gICAgICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLnBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIHVybCwgbGV2ZWwgfHwgaWQgfHwgMCwgaXNMZXZlbCA/ICdtYWluJyA6ICdhdWRpbycpO1xuICAgICAgICAgICAgbGV2ZWxEZXRhaWxzLnRsb2FkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWFuaWZlc3QnKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlcXVlc3QsIHN0cmVhbSBtYW5pZmVzdCAobm8gbWFzdGVyIHBsYXlsaXN0KSwgZmlyZSBtYW5pZmVzdCBsb2FkZWQgZXZlbnQgd2l0aCBsZXZlbCBkZXRhaWxzXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7bGV2ZWxzOiBbe3VybDogdXJsLCBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzfV0sIHVybDogdXJsLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChpc0xldmVsKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBsZXZlbDogbGV2ZWwgfHwgMCwgaWQ6IGlkIHx8IDAsIHN0YXRzOiBzdGF0c30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCwge2RldGFpbHM6IGxldmVsRGV0YWlscywgaWQ6IGlkLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxldmVscyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XG4gICAgICAgIC8vIG11bHRpIGxldmVsIHBsYXlsaXN0LCBwYXJzZSBsZXZlbCBpbmZvXG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGF1ZGlvdHJhY2tzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdBVURJTycpO1xuICAgICAgICAgIGlmIChhdWRpb3RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgICAgICAgbGV0IGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgYXVkaW90cmFja3MuZm9yRWFjaChhdWRpb1RyYWNrID0+IHtcbiAgICAgICAgICAgICAgaWYoIWF1ZGlvVHJhY2sudXJsKSB7XG4gICAgICAgICAgICAgICAgZW1iZWRkZWRBdWRpb0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrXG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkQXVkaW9Gb3VuZCA9PT0gZmFsc2UgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgICAgICAgYXVkaW90cmFja3MudW5zaGlmdCh7IHR5cGUgOiAnbWFpbicsIG5hbWUgOiAnbWFpbid9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7bGV2ZWxzOiBsZXZlbHMsIGF1ZGlvVHJhY2tzIDogYXVkaW90cmFja3MsIHVybDogdXJsLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ25vIEVYVE0zVSBkZWxpbWl0ZXInfSk7XG4gICAgfVxuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGRldGFpbHMsIGZhdGFsLGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIHN3aXRjaChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21hbmlmZXN0JzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGV2ZWwnOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXVkaW9UcmFjayc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGRldGFpbHMsIGZhdGFsOiBmYXRhbCwgdXJsOiBsb2FkZXIudXJsLCBsb2FkZXI6IGxvYWRlciwgcmVzcG9uc2U6IHJlc3BvbnNlLCBjb250ZXh0IDogY29udGV4dH0pO1xuICB9XG5cbiAgbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICB2YXIgZGV0YWlscywgZmF0YWwsIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIHN3aXRjaChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21hbmlmZXN0JzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZXZlbCc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGRldGFpbHMsIGZhdGFsOiBmYXRhbCwgdXJsOiBsb2FkZXIudXJsLCBsb2FkZXI6IGxvYWRlciwgY29udGV4dCA6IGNvbnRleHR9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5bGlzdExvYWRlcjtcbiIsIi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuKi9cblxuLy9pbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgbXZleDogW10sXG4gICAgICBtdmhkOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW1xuICAgICAgICAgIGkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMSksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgzKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgICAweDZmLCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgdmFyIGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLCAweDZmLCAweDc1LCAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG5cbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgICd2aWRlbyc6IHZpZGVvSGRscixcbiAgICAgICdhdWRpbyc6IGF1ZGlvSGRsclxuICAgIH07XG5cbiAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcblxuICAgIHZhciBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcblxuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG5cbiAgICBNUDQuU1RTWiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcblxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOy8vIGVudHJ5X2NvdW50XG5cbiAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsMTE1LDExMSwxMDldKTsgLy8gaXNvbVxuICAgIHZhciBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsMTE4LDk5LDQ5XSk7IC8vIGF2YzFcbiAgICB2YXIgbWlub3JWZXJzaW9uID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcblxuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG5cbiAgc3RhdGljIGJveCh0eXBlKSB7XG4gIHZhclxuICAgIHBheWxvYWQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgIHNpemUgPSA4LFxuICAgIGkgPSBwYXlsb2FkLmxlbmd0aCxcbiAgICBsZW4gPSBpLFxuICAgIHJlc3VsdDtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG5cbiAgc3RhdGljIG1kYXQoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+ICA4KSAmIDB4RkYsXG4gICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgIChkdXJhdGlvbiA+PiAyNCksXG4gICAgICAoZHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgIChkdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxuICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgMHg1NSwgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAgIDB4MDAsIDB4MDBcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgbWRpYSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH1cblxuICBzdGF0aWMgbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAyNCksXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMTYpICYgMHhGRixcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAgOCkgJiAweEZGLFxuICAgICAgc2VxdWVuY2VOdW1iZXIgJiAweEZGLCAvLyBzZXF1ZW5jZV9udW1iZXJcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIG1vb2Yoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICB9XG4vKipcbiAqIEBwYXJhbSB0cmFja3MuLi4gKG9wdGlvbmFsKSB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcbiAqL1xuICBzdGF0aWMgbW9vdih0cmFja3MpIHtcbiAgICB2YXJcbiAgICAgIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgICAgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmV4KHRyYWNrcykge1xuICAgIHZhclxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xuICB9XG5cbiAgc3RhdGljIG12aGQodGltZXNjYWxlLGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24qPXRpbWVzY2FsZTtcbiAgICB2YXJcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAgOCkgJiAweEZGLFxuICAgICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgICAgKGR1cmF0aW9uID4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4gIDgpICYgMHhGRixcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxuICAgICAgICAweDAxLCAweDAwLCAvLyAxLjAgdm9sdW1lXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgICBdKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHNkdHAodHJhY2spIHtcbiAgICB2YXJcbiAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxuICAgICAgZmxhZ3MsXG4gICAgICBpO1xuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSAoZmxhZ3MuZGVwZW5kc09uIDw8IDQpIHxcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyKSB8XG4gICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHN0YmwodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICB9XG5cbiAgc3RhdGljIGF2YzEodHJhY2spIHtcbiAgICB2YXIgc3BzID0gW10sIHBwcyA9IFtdLCBpLCBkYXRhLCBsZW47XG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgc3BzLnB1c2goKGxlbiAmIDB4RkYpKTtcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpOyAvLyBTUFNcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgcHBzLnB1c2goKGxlbiAmIDB4RkYpKTtcbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIHZhciBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMSwgICAvLyB2ZXJzaW9uXG4gICAgICAgICAgICBzcHNbM10sIC8vIHByb2ZpbGVcbiAgICAgICAgICAgIHNwc1s0XSwgLy8gcHJvZmlsZSBjb21wYXRcbiAgICAgICAgICAgIHNwc1s1XSwgLy8gbGV2ZWxcbiAgICAgICAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgICAgICAgICAgMHhFMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICAgICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW1xuICAgICAgICAgICAgdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICAgICAgXSkuY29uY2F0KHBwcykpKSwgLy8gXCJQUFNcIlxuICAgICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgLy9jb25zb2xlLmxvZygnYXZjYzonICsgSGV4LmhleER1bXAoYXZjYykpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICAgIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcbiAgICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICAgIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cbiAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gdmVydHJlc29sdXRpb25cbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcbiAgICAgICAgMHgxMixcbiAgICAgICAgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QywgLy9kYWlseW1vdGlvbi9obHMuanNcbiAgICAgICAgMHg3OSwgMHg2RCwgMHg2RiwgMHg3NCxcbiAgICAgICAgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRixcbiAgICAgICAgMHg2OCwgMHg2QywgMHg3MywgMHgyRSxcbiAgICAgICAgMHg2QSwgMHg3MywgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAgICAgMHgwMCwgMHgxOCwgICAvLyBkZXB0aCA9IDI0XG4gICAgICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgICAgIGF2Y2MsXG4gICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXSkpIC8vIGF2Z0JpdHJhdGVcbiAgICAgICAgICApO1xuICB9XG5cbiAgc3RhdGljIGVzZHModHJhY2spIHtcbiAgICB2YXIgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuXG4gICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MTcrY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4MDAsIDB4MDEsIC8vZXNfaWRcbiAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgICAweDA0LCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MGYrY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4NDAsIC8vY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgICAgMHgxNSwgLy8gc3RyZWFtX3R5cGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gIH1cblxuICBzdGF0aWMgbXA0YSh0cmFjaykge1xuICAgIHZhciBhdWRpb3NhbXBsZXJhdGUgPSB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxuICAgICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgKGF1ZGlvc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXG4gICAgICBhdWRpb3NhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gIH1cblxuICBzdGF0aWMgc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGtoZCh0cmFjaykge1xuICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uKnRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDcsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgKGlkID4+IDI0KSAmIDB4RkYsXG4gICAgICAoaWQgPj4gMTYpICYgMHhGRixcbiAgICAgIChpZCA+PiA4KSAmIDB4RkYsXG4gICAgICBpZCAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgKGR1cmF0aW9uID4+IDI0KSxcbiAgICAgIChkdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGR1cmF0aW9uID4+ICA4KSAmIDB4RkYsXG4gICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGxheWVyXG4gICAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICB3aWR0aCAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwLCAvLyB3aWR0aFxuICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICBoZWlnaHQgJiAweEZGLFxuICAgICAgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgdHJhZih0cmFjayxiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKSxcbiAgICAgICAgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZixcbiAgICAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgICAgICAgICAgIChpZCA+PiAyNCksXG4gICAgICAgICAgICAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAoaWQgPj4gOCkgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAoaWQgJiAweEZGKSAvLyB0cmFja19JRFxuICAgICAgICAgICAgICAgXSkpLFxuICAgICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgPj4yNCksXG4gICAgICAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDBYRkYsXG4gICAgICAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMFhGRixcbiAgICAgICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKSAvLyBiYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgICAgICAgICAgICBdKSksXG4gICAgICAgICAgICAgICBNUDQudHJ1bih0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gdGZoZFxuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIHRmZHRcbiAgICAgICAgICAgICAgICAgICAgOCArICAvLyB0cmFmIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIG1maGRcbiAgICAgICAgICAgICAgICAgICAgOCArICAvLyBtb29mIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICA4KSwgIC8vIG1kYXQgaGVhZGVyXG4gICAgICAgICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcbiAgICovXG4gIHN0YXRpYyB0cmFrKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH1cblxuICBzdGF0aWMgdHJleCh0cmFjaykge1xuICAgIHZhciBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgIChpZCA+PiAyNCksXG4gICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAoaWQgPj4gOCkgJiAwWEZGLFxuICAgICAoaWQgJiAweEZGKSwgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICB2YXIgc2FtcGxlcz0gdHJhY2suc2FtcGxlcyB8fCBbXSxcbiAgICAgICAgbGVuID0gc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgIGFycmF5bGVuID0gMTIgKyAoMTYgKiBsZW4pLFxuICAgICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKSxcbiAgICAgICAgaSxzYW1wbGUsZHVyYXRpb24sc2l6ZSxmbGFncyxjdHM7XG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICBhcnJheS5zZXQoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDBmLCAweDAxLCAvLyBmbGFnc1xuICAgICAgKGxlbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgIChsZW4gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAobGVuID4+PiA4KSAmIDB4RkYsXG4gICAgICBsZW4gJiAweEZGLCAvLyBzYW1wbGVfY291bnRcbiAgICAgIChvZmZzZXQgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAob2Zmc2V0ID4+PiAxNikgJiAweEZGLFxuICAgICAgKG9mZnNldCA+Pj4gOCkgJiAweEZGLFxuICAgICAgb2Zmc2V0ICYgMHhGRiAvLyBkYXRhX29mZnNldFxuICAgIF0sMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW1xuICAgICAgICAoZHVyYXRpb24gPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIGR1cmF0aW9uICYgMHhGRiwgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIChzaXplID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoc2l6ZSA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKHNpemUgPj4+IDgpICYgMHhGRixcbiAgICAgICAgc2l6ZSAmIDB4RkYsIC8vIHNhbXBsZV9zaXplXG4gICAgICAgIChmbGFncy5pc0xlYWRpbmcgPDwgMikgfCBmbGFncy5kZXBlbmRzT24sXG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgNikgfFxuICAgICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQpIHxcbiAgICAgICAgICAoZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcbiAgICAgICAgICBmbGFncy5pc05vblN5bmMsXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweEYwIDw8IDgsXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgKGN0cyA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKGN0cyA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKGN0cyA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBjdHMgJiAweEZGIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwxMisxNippKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbml0U2VnbWVudCh0cmFja3MpIHtcbiAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgTVA0LmluaXQoKTtcbiAgICB9XG4gICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKSwgcmVzdWx0O1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1QNC5GVFlQLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KE1QNC5GVFlQKTtcbiAgICByZXN1bHQuc2V0KG1vdmllLCBNUDQuRlRZUC5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNDtcbiIsIi8qKlxuICogZk1QNCByZW11eGVyXG4qL1xuXG5cbmltcG9ydCBBQUMgZnJvbSAnLi4vaGVscGVyL2FhYyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IE1QNCBmcm9tICcuLi9yZW11eC9tcDQtZ2VuZXJhdG9yJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0ICcuLi91dGlscy9wb2x5ZmlsbCc7XG5cbmNsYXNzIE1QNFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgaWQsIGNvbmZpZykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuUEVTMk1QNFNDQUxFRkFDVE9SID0gNDtcbiAgICB0aGlzLlBFU19USU1FU0NBTEUgPSA5MDAwMDtcbiAgICB0aGlzLk1QNF9USU1FU0NBTEUgPSB0aGlzLlBFU19USU1FU0NBTEUgLyB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUjtcbiAgfVxuXG4gIGdldCBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbiAgaW5zZXJ0RGlzY29udGludWl0eSgpIHtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN3aXRjaExldmVsKCkge1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbXV4KGxldmVsLHNuLGF1ZGlvVHJhY2ssdmlkZW9UcmFjayxpZDNUcmFjayx0ZXh0VHJhY2ssdGltZU9mZnNldCwgY29udGlndW91cykge1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnNuID0gc247XG4gICAgLy8gZ2VuZXJhdGUgSW5pdCBTZWdtZW50IGlmIG5lZWRlZFxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssdmlkZW9UcmFjayx0aW1lT2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEFhY1B0cywgd2hpY2ggaXNcbiAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQUFDIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBhdWRpb1RyYWNrTGVuZ3RoO1xuICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpb0RhdGEuZW5kUFRTIC0gYXVkaW9EYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjayx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMsYXVkaW9UcmFja0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2aWRlb0RhdGE7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZpZGVvRGF0YSA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvRGF0YSAmJiBhdWRpb1RyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgdGhpcy5yZW11eEVtcHR5QXVkaW8oYXVkaW9UcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvL2xvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhJRDMoaWQzVHJhY2ssdGltZU9mZnNldCk7XG4gICAgfVxuICAgIC8vbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjayx0aW1lT2Zmc2V0KTtcbiAgICB9XG4gICAgLy9ub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQsIHsgaWQgOiB0aGlzLmlkICwgbGV2ZWwgOiB0aGlzLmxldmVsLCBzbiA6IHRoaXMuc259KTtcbiAgfVxuXG4gIGdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLFxuICAgICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcyxcbiAgICAgICAgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICB0cmFja3MgPSB7fSxcbiAgICAgICAgZGF0YSA9IHsgaWQgOiB0aGlzLmlkLCBsZXZlbCA6IHRoaXMubGV2ZWwsIHNuIDogdGhpcy5zbiwgdHJhY2tzIDogdHJhY2tzLCB1bmlxdWUgOiBmYWxzZSB9LFxuICAgICAgICBjb21wdXRlUFRTRFRTID0gKHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgIGluaXRQVFMsIGluaXREVFM7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICAvLyBNUDQgZHVyYXRpb24gKHRyYWNrIGR1cmF0aW9uIGluIHNlY29uZHMgbXVsdGlwbGllZCBieSB0aW1lc2NhbGUpIGlzIGNvZGVkIG9uIDMyIGJpdHNcbiAgICAgIC8vIHdlIGtub3cgdGhhdCBlYWNoIEFBQyBzYW1wbGUgY29udGFpbnMgMTAyNCBmcmFtZXMuLi4uXG4gICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBvdmVyZmxvd2luZyB0aGUgMzIgYml0IGNvdW50ZXIgZm9yIGxhcmdlIGR1cmF0aW9uLCB3ZSB1c2Ugc21hbGxlciB0aW1lc2NhbGUgKHRpbWVzY2FsZS9nY2QpXG4gICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW5zdXJlIHRoYXQgQUFDIHNhbXBsZSBkdXJhdGlvbiB3aWxsIHN0aWxsIGJlIGFuIGludGVnZXIgKHdpbGwgYmUgMTAyNC9nY2QpXG4gICAgICBpZiAoYXVkaW9UcmFjay50aW1lc2NhbGUgKiBhdWRpb1RyYWNrLmR1cmF0aW9uID4gTWF0aC5wb3coMiwgMzIpKSB7XG4gICAgICAgIGxldCBncmVhdGVzdENvbW1vbkRpdmlzb3IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZiAoICEgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYik7XG4gICAgICAgIH07XG4gICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUgLyBncmVhdGVzdENvbW1vbkRpdmlzb3IoYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUsMTAyNCk7XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nICgnYXVkaW8gbXA0IHRpbWVzY2FsZSA6JysgYXVkaW9UcmFjay50aW1lc2NhbGUpO1xuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXIgOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWMgOiAgYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgY2hhbm5lbENvdW50IDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTICsgRFRTIC4uLlxuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBwZXNUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IHRoaXMuTVA0X1RJTUVTQ0FMRTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyIDogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjIDogIHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50IDogTVA0LmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhIDoge1xuICAgICAgICAgIHdpZHRoIDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgOiB2aWRlb1RyYWNrLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsdmlkZW9TYW1wbGVzWzBdLnB0cyAtIHBlc1RpbWVTY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUyx2aWRlb1NhbXBsZXNbMF0uZHRzIC0gcGVzVGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxkYXRhKTtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGlkIDogdGhpcy5pZCwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJ30pO1xuICAgIH1cbiAgfVxuXG4gIHJlbXV4VmlkZW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpIHtcbiAgICB2YXIgb2Zmc2V0ID0gOCxcbiAgICAgICAgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICBwZXMybXA0U2NhbGVGYWN0b3IgPSB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUixcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgIG1kYXQsIG1vb2YsXG4gICAgICAgIGZpcnN0UFRTLCBmaXJzdERUUyxcbiAgICAgICAgbmV4dERUUyxcbiAgICAgICAgbGFzdFBUUywgbGFzdERUUyxcbiAgICAgICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcyxcbiAgICAgICAgb3V0cHV0U2FtcGxlcyA9IFtdO1xuXG4gIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcbiAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgbGV0IG5leHRBdmNEdHM7XG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcbiAgICAgIG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgIG5leHRBdmNEdHMgPSB0aW1lT2Zmc2V0KnBlc1RpbWVTY2FsZTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIGZpcnN0IERUUyBhbmQgbGFzdCBEVFMsIG5vcm1hbGl6ZSB0aGVtIGFnYWluc3QgcmVmZXJlbmNlIHZhbHVlXG4gICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcbiAgICBmaXJzdERUUyA9ICBNYXRoLm1heCh0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLmR0cyAtIHRoaXMuX2luaXREVFMsbmV4dEF2Y0R0cyksMCk7XG4gICAgZmlyc3RQVFMgPSAgTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpLDApO1xuXG4gICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgIGxldCBkZWx0YSA9IE1hdGgucm91bmQoKGZpcnN0RFRTIC0gbmV4dEF2Y0R0cykgLyA5MCk7XG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQVZDOiR7ZGVsdGF9IG1zIGhvbGUgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHsoLWRlbHRhKX0gbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgaG9sZS9nYXAgOiBzZXQgRFRTIHRvIG5leHQgZXhwZWN0ZWQgRFRTXG4gICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTICsgdGhpcy5faW5pdERUUztcbiAgICAgICAgLy8gb2Zmc2V0IFBUUyBhcyB3ZWxsLCBlbnN1cmUgdGhhdCBQVFMgaXMgc21hbGxlciBvciBlcXVhbCB0aGFuIG5ldyBEVFNcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChmaXJzdFBUUyAtIGRlbHRhLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTICsgdGhpcy5faW5pdERUUztcbiAgICAgICAgbG9nZ2VyLmxvZyhgVmlkZW8vUFRTL0RUUyBhZGp1c3RlZDogJHtmaXJzdFBUU30vJHtmaXJzdERUU30sZGVsdGE6JHtkZWx0YX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV4dERUUyA9IGZpcnN0RFRTO1xuXG4gICAgLy8gY29tcHV0ZSBsYXN0UFRTL2xhc3REVFNcbiAgICBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aC0xXTtcbiAgICBsYXN0RFRTID0gTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpICwwKTtcbiAgICBsYXN0UFRTID0gTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpICwwKTtcbiAgICBsYXN0UFRTID0gTWF0aC5tYXgobGFzdFBUUywgbGFzdERUUyk7XG5cbiAgICBsZXQgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvciwgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgaXNTYWZhcmkgPSB2ZW5kb3IgJiYgdmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJiB1c2VyQWdlbnQgJiYgIXVzZXJBZ2VudC5tYXRjaCgnQ3JpT1MnKTtcblxuICAgICAgLy8gb24gU2FmYXJpIGxldCdzIHNpZ25hbCB0aGUgc2FtZSBzYW1wbGUgZHVyYXRpb24gZm9yIGFsbCBzYW1wbGVzXG4gICAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMtZmlyc3REVFMpLyhwZXMybXA0U2NhbGVGYWN0b3IqKGlucHV0U2FtcGxlcy5sZW5ndGgtMSkpKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgYWxsIFBUUy9EVFMgbm93IC4uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgIC8vIHNhbXBsZSBEVFMgaXMgY29tcHV0ZWQgdXNpbmcgYSBjb25zdGFudCBkZWNvZGluZyBvZmZzZXQgKG1wNFNhbXBsZUR1cmF0aW9uKSBiZXR3ZWVuIHNhbXBsZXNcbiAgICAgICAgc2FtcGxlLmR0cyA9IGZpcnN0RFRTICsgaSpwZXMybXA0U2NhbGVGYWN0b3IqbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHRoaXMuX1BUU05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gdGhpcy5faW5pdERUUywgbmV4dEF2Y0R0cyksZmlyc3REVFMpO1xuICAgICAgICAvLyBlbnN1cmUgZHRzIGlzIGEgbXVsdGlwbGUgb2Ygc2NhbGUgZmFjdG9yIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlc1xuICAgICAgICBzYW1wbGUuZHRzID0gTWF0aC5yb3VuZChzYW1wbGUuZHRzL3BlczJtcDRTY2FsZUZhY3RvcikqcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgICAgLy8gd2Ugbm9ybWFsaXplIFBUUyBhZ2FpbnN0IG5leHRBdmNEdHMsIHdlIGFsc28gc3Vic3RyYWN0IGluaXREVFMgKHNvbWUgc3RyZWFtcyBkb24ndCBzdGFydCBAIFBUUyBPKVxuICAgICAgLy8gYW5kIHdlIGVuc3VyZSB0aGF0IGNvbXB1dGVkIHZhbHVlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiBzYW1wbGUgRFRTXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpICwgc2FtcGxlLmR0cyk7XG4gICAgICAvLyBlbnN1cmUgcHRzIGlzIGEgbXVsdGlwbGUgb2Ygc2NhbGUgZmFjdG9yIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlc1xuICAgICAgc2FtcGxlLnB0cyA9IE1hdGgucm91bmQoc2FtcGxlLnB0cy9wZXMybXA0U2NhbGVGYWN0b3IpKnBlczJtcDRTY2FsZUZhY3RvcjtcbiAgICB9XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KHRyYWNrLmxlbiArICg0ICogdHJhY2submJOYWx1KSArIDgpO1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0LmJ5dGVMZW5ndGgpO1xuICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXZjU2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLFxuICAgICAgICAgIG1wNFNhbXBsZUxlbmd0aCA9IDAsXG4gICAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0O1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgd2hpbGUgKGF2Y1NhbXBsZS51bml0cy51bml0cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHVuaXQgPSBhdmNTYW1wbGUudW5pdHMudW5pdHMuc2hpZnQoKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0LmRhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYoIWlzU2FmYXJpKSB7XG4gICAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgICBpZiAoaSA8IGlucHV0U2FtcGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbaSsxXS5kdHMgLSBhdmNTYW1wbGUuZHRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgbGFzdEZyYW1lRHVyYXRpb24gPSBhdmNTYW1wbGUuZHRzIC0gaW5wdXRTYW1wbGVzW2kgPiAwID8gaS0xIDogaV0uZHRzO1xuICAgICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjaykge1xuICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIHRoZSBtaW5pbXVtIG9mIG1heEJ1ZmZlckhvbGUgYW5kXG4gICAgICAgICAgICAvLyBtYXhTZWVrSG9sZS4gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgICAgbGV0IG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSxcbiAgICAgICAgICAgICAgICBtYXhTZWVrSG9sZSA9IGNvbmZpZy5tYXhTZWVrSG9sZSxcbiAgICAgICAgICAgICAgICBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKE1hdGgubWluKG1heEJ1ZmZlckhvbGUsIG1heFNlZWtIb2xlKSAqIHBlc1RpbWVTY2FsZSksXG4gICAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiBwZXNUaW1lU2NhbGUgOiB0aGlzLm5leHRBYWNQdHMpIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUvbWF4U2Vla0hvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZC85MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbi85MH0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gLz0gcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cykgLyBwZXMybXA0U2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5tYXgoMCxtcDRTYW1wbGVEdXJhdGlvbipNYXRoLnJvdW5kKChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cykvKHBlczJtcDRTY2FsZUZhY3RvciptcDRTYW1wbGVEdXJhdGlvbikpKTtcbiAgICAgIH1cblxuXG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXZjU2FtcGxlLnB0c30vJHthdmNTYW1wbGUuZHRzfS8ke3RoaXMuX2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdmNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2goe1xuICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxuICAgICAgICBkdXJhdGlvbjogbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgIGN0czogY29tcG9zaXRpb25UaW1lT2Zmc2V0LFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgIGRlcGVuZHNPbiA6IGF2Y1NhbXBsZS5rZXkgPyAyIDogMSxcbiAgICAgICAgICBpc05vblN5bmMgOiBhdmNTYW1wbGUua2V5ID8gMCA6IDFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbipwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgbGV0IGRyb3BwZWQgPSB0cmFjay5kcm9wcGVkO1xuICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgdHJhY2submJOYWx1ID0gMDtcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICBpZihvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgbGV0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAvLyBjaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTIC8gcGVzMm1wNFNjYWxlRmFjdG9yLCB0cmFjayk7XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuXG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICBsZXZlbCA6IHRoaXMubGV2ZWwsXG4gICAgICBzbiA6IHRoaXMuc24sXG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgZW5kUFRTOiAobGFzdFBUUyArIHBlczJtcDRTY2FsZUZhY3RvciAqIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHBlc1RpbWVTY2FsZSxcbiAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgIGVuZERUUzogdGhpcy5uZXh0QXZjRHRzIC8gcGVzVGltZVNjYWxlLFxuICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQgOiBkcm9wcGVkXG4gICAgfTtcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cykge1xuICAgIGxldCBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgcGVzMm1wNFNjYWxlRmFjdG9yID0gcGVzVGltZVNjYWxlL21wNHRpbWVTY2FsZSxcbiAgICAgICAgZXhwZWN0ZWRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLnRpbWVzY2FsZSAqIDEwMjQgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgdmFyIHZpZXcsXG4gICAgICAgIG9mZnNldCA9IDgsXG4gICAgICAgIGFhY1NhbXBsZSwgbXA0U2FtcGxlLFxuICAgICAgICB1bml0LFxuICAgICAgICBtZGF0LCBtb29mLFxuICAgICAgICBmaXJzdFBUUywgZmlyc3REVFMsIGxhc3REVFMsXG4gICAgICAgIHB0cywgZHRzLCBwdHNub3JtLCBkdHNub3JtLFxuICAgICAgICBzYW1wbGVzID0gW10sXG4gICAgICAgIHNhbXBsZXMwID0gW10sXG4gICAgICAgIGZpbGxGcmFtZSwgbmV3U3RhbXA7XG5cbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cy1iLnB0cyk7XG4gICAgfSk7XG4gICAgc2FtcGxlczAgPSB0cmFjay5zYW1wbGVzO1xuXG4gICAgbGV0IG5leHRBYWNQdHMgPSAoY29udGlndW91cyA/IHRoaXMubmV4dEFhY1B0cyA6IHRpbWVPZmZzZXQqcGVzVGltZVNjYWxlKTtcblxuICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgIC8vIGZyYW1lLlxuICAgIGNvbnN0IHBlc0ZyYW1lRHVyYXRpb24gPSBleHBlY3RlZFNhbXBsZUR1cmF0aW9uICogcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgIGxldCBuZXh0UHRzTm9ybSA9IG5leHRBYWNQdHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzMC5sZW5ndGg7ICkge1xuICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICB2YXIgc2FtcGxlID0gc2FtcGxlczBbaV0sXG4gICAgICAgICAgcHRzTm9ybSA9IHRoaXMuX1BUU05vcm1hbGl6ZShzYW1wbGUucHRzIC0gdGhpcy5faW5pdERUUywgbmV4dEFhY1B0cyksXG4gICAgICAgICAgZGVsdGEgPSBwdHNOb3JtIC0gbmV4dFB0c05vcm07XG5cbiAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBoYWxmIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGVcbiAgICAgIGlmIChkZWx0YSA8ICgtMC41ICogcGVzRnJhbWVEdXJhdGlvbikpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgRHJvcHBpbmcgZnJhbWUgZHVlIHRvICR7TWF0aC5yb3VuZChNYXRoLmFicyhkZWx0YSAvIDkwKSl9IG1zIG92ZXJsYXAuYCk7XG4gICAgICAgIHNhbXBsZXMwLnNwbGljZShpLCAxKTtcbiAgICAgICAgdHJhY2subGVuIC09IHNhbXBsZS51bml0Lmxlbmd0aDtcbiAgICAgICAgLy8gRG9uJ3QgdG91Y2ggbmV4dFB0c05vcm0gb3IgaVxuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGF3YXkgZnJvbSB3aGVyZSB3ZSBzaG91bGQgYmUsIGluc2VydCBtaXNzaW5nIGZyYW1lc1xuICAgICAgZWxzZSBpZiAoZGVsdGEgPiAoMC41ICogcGVzRnJhbWVEdXJhdGlvbikpIHtcbiAgICAgICAgdmFyIG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgIGxvZ2dlci5sb2coYEluamVjdGluZyAke21pc3Npbmd9IGZyYW1lJHttaXNzaW5nID4gMSA/ICdzJyA6ICcnfSBvZiBtaXNzaW5nIGF1ZGlvIGR1ZSB0byAke01hdGgucm91bmQoZGVsdGEgLyA5MCl9IG1zIGdhcC5gKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICBuZXdTdGFtcCA9IHNhbXBsZS5wdHMgLSAobWlzc2luZyAtIGopICogcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICBuZXdTdGFtcCA9IE1hdGgubWF4KG5ld1N0YW1wLCB0aGlzLl9pbml0RFRTKTtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zbGljZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FtcGxlczAuc3BsaWNlKGksIDAsIHt1bml0OiBmaWxsRnJhbWUsIHB0czogbmV3U3RhbXAsIGR0czogbmV3U3RhbXB9KTtcbiAgICAgICAgICB0cmFjay5sZW4gKz0gZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3Qgc2FtcGxlIHRvIG5leHQgZXhwZWN0ZWQgcHRzXG4gICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGVzMFtpIC0gMV0ucHRzICsgcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgbmV4dFB0c05vcm0gPSB0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLnB0cyArIHBlc0ZyYW1lRHVyYXRpb24gLSB0aGlzLl9pbml0RFRTLCBuZXh0QWFjUHRzKTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSB3aXRoaW4gaGFsZiBhIGZyYW1lIGR1cmF0aW9uLCBzbyBqdXN0IGFkanVzdCBwdHNcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gKDAuMSAqIHBlc0ZyYW1lRHVyYXRpb24pKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQocHRzTm9ybSAtIG5leHRQdHNOb3JtICsgcGVzRnJhbWVEdXJhdGlvbil9IGF0IFBUUyAke01hdGgucm91bmQocHRzTm9ybSAvIDkwKX0gKHNob3VsZCBiZSAke01hdGgucm91bmQocGVzRnJhbWVEdXJhdGlvbil9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0UHRzTm9ybSArPSBwZXNGcmFtZUR1cmF0aW9uO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIHNhbXBsZS5wdHMgPSB0aGlzLl9pbml0RFRTICsgbmV4dEFhY1B0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlczBbaSAtIDFdLnB0cyArIHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChzYW1wbGVzMC5sZW5ndGgpIHtcbiAgICAgIGFhY1NhbXBsZSA9IHNhbXBsZXMwLnNoaWZ0KCk7XG4gICAgICB1bml0ID0gYWFjU2FtcGxlLnVuaXQ7XG4gICAgICBwdHMgPSBhYWNTYW1wbGUucHRzIC0gdGhpcy5faW5pdERUUztcbiAgICAgIGR0cyA9IGFhY1NhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTO1xuICAgICAgLy9sb2dnZXIubG9nKGBBdWRpby9QVFM6JHtNYXRoLnJvdW5kKHB0cy85MCl9YCk7XG4gICAgICAvLyBpZiBub3QgZmlyc3Qgc2FtcGxlXG4gICAgICBpZiAobGFzdERUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB0c25vcm0gPSB0aGlzLl9QVFNOb3JtYWxpemUocHRzLCBsYXN0RFRTKTtcbiAgICAgICAgZHRzbm9ybSA9IHRoaXMuX1BUU05vcm1hbGl6ZShkdHMsIGxhc3REVFMpO1xuICAgICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChkdHNub3JtIC0gbGFzdERUUykgLyBwZXMybXA0U2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHRzbm9ybSA9IHRoaXMuX1BUU05vcm1hbGl6ZShwdHMsIG5leHRBYWNQdHMpO1xuICAgICAgICBkdHNub3JtID0gdGhpcy5fUFRTTm9ybWFsaXplKGR0cywgbmV4dEFhY1B0cyk7XG4gICAgICAgIGxldCBkZWx0YSA9IE1hdGgucm91bmQoMTAwMCAqIChwdHNub3JtIC0gbmV4dEFhY1B0cykgLyBwZXNUaW1lU2NhbGUpLFxuICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IDA7XG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgICAgICBpZiAoY29udGlndW91cykge1xuICAgICAgICAgIC8vIGxvZyBkZWx0YVxuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gTWF0aC5yb3VuZCgocHRzbm9ybSAtIG5leHRBYWNQdHMpIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYCR7ZGVsdGF9IG1zIGhvbGUgYmV0d2VlbiBBQUMgc2FtcGxlcyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gbnVtTWlzc2luZ0ZyYW1lcyAqIGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBvdmVybGFwLCBvdmVybGFwcGluZyBmb3IgbW9yZSB0aGFuIGhhbGYgYSBmcmFtZSBkdXJhaW9uXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEyKSB7XG4gICAgICAgICAgICAgIC8vIGRyb3Agb3ZlcmxhcHBpbmcgYXVkaW8gZnJhbWVzLi4uIGJyb3dzZXIgd2lsbCBkZWFsIHdpdGggaXRcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgJHsoLWRlbHRhKX0gbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBBQUMgc2FtcGxlcyBkZXRlY3RlZCwgZHJvcCBmcmFtZWApO1xuICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICAgIHB0c25vcm0gPSBkdHNub3JtID0gbmV4dEFhY1B0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhYWNTYW1wbGVzLCBlbnN1cmUgdmFsdWUgaXMgcG9zaXRpdmVcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heCgwLCBwdHNub3JtKTtcbiAgICAgICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBkdHNub3JtKTtcbiAgICAgICAgaWYodHJhY2subGVuID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheSh0cmFjay5sZW4gKyA4KTtcbiAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0LmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcbiAgICAgICAgICBuZXdTdGFtcCA9IHB0c25vcm0gLSAobnVtTWlzc2luZ0ZyYW1lcyAtIGkpICogcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyB0aGlzIGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnNsaWNlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZGF0LnNldChmaWxsRnJhbWUsIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZpbGxGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIG1wNFNhbXBsZSA9IHtcbiAgICAgICAgICAgIHNpemU6IGZpbGxGcmFtZS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgY3RzOiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDEwMjQsXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgICAgZGVwZW5kc09uOiAxLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgLy9jb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2FhY1NhbXBsZS5wdHN9LyR7YWFjU2FtcGxlLmR0c30vJHt0aGlzLl9pbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYWFjU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICBzaXplOiB1bml0LmJ5dGVMZW5ndGgsXG4gICAgICAgIGN0czogMCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uOiAxLFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICBsYXN0RFRTID0gZHRzbm9ybTtcbiAgICB9XG4gICAgdmFyIGxhc3RTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmFyIG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgIC8vc2V0IGxhc3Qgc2FtcGxlIGR1cmF0aW9uIGFzIGJlaW5nIGlkZW50aWNhbCB0byBwcmV2aW91cyBzYW1wbGVcbiAgICBpZiAobmJTYW1wbGVzID49IDIpIHtcbiAgICAgIGxhc3RTYW1wbGVEdXJhdGlvbiA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMl0uZHVyYXRpb247XG4gICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgfVxuICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgIC8vIG5leHQgYWFjIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgICB0aGlzLm5leHRBYWNQdHMgPSBwdHNub3JtICsgcGVzMm1wNFNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgLy9sb2dnZXIubG9nKCdBdWRpby9QVFMvUFRTZW5kOicgKyBhYWNTYW1wbGUucHRzLnRvRml4ZWQoMCkgKyAnLycgKyB0aGlzLm5leHRBYWNEdHMudG9GaXhlZCgwKSk7XG4gICAgICB0cmFjay5sZW4gPSAwO1xuICAgICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMgLyBwZXMybXA0U2NhbGVGYWN0b3IsIHRyYWNrKTtcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgIGxldCBhdWRpb0RhdGEgPSB7XG4gICAgICAgIGlkIDogdGhpcy5pZCxcbiAgICAgICAgbGV2ZWwgOiB0aGlzLmxldmVsLFxuICAgICAgICBzbiA6IHRoaXMuc24sXG4gICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICBlbmRQVFM6IHRoaXMubmV4dEFhY1B0cyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICBlbmREVFM6IChkdHNub3JtICsgcGVzMm1wNFNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uKSAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgbmI6IG5iU2FtcGxlc1xuICAgICAgfTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgYXVkaW9EYXRhKTtcbiAgICAgIHJldHVybiBhdWRpb0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICBsZXQgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGUgPyB0cmFjay50aW1lc2NhbGUgOiB0cmFjay5hdWRpb3NhbXBsZXJhdGUsXG4gICAgICAgIHBlczJtcDRTY2FsZUZhY3RvciA9IHBlc1RpbWVTY2FsZS9tcDR0aW1lU2NhbGUsXG5cbiAgICAgICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXG4gICAgICAgIHN0YXJ0RFRTID0gdmlkZW9EYXRhLnN0YXJ0RFRTICogcGVzVGltZVNjYWxlICsgdGhpcy5faW5pdERUUyxcbiAgICAgICAgZW5kRFRTID0gdmlkZW9EYXRhLmVuZERUUyAqIHBlc1RpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsXG5cbiAgICAgICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gMTAyNCxcbiAgICAgICAgZnJhbWVEdXJhdGlvbiA9IHBlczJtcDRTY2FsZUZhY3RvciAqIHNhbXBsZUR1cmF0aW9uLFxuXG4gICAgICAgIC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cbiAgICAgICAgbmJTYW1wbGVzID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKSxcblxuICAgICAgICAvLyBzaWxlbnQgZnJhbWVcbiAgICAgICAgc2lsZW50RnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcblxuICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHNhbXBsZXMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIHZhciBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goe3VuaXQ6IHNpbGVudEZyYW1lLnNsaWNlKDApLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfSk7XG4gICAgICB0cmFjay5sZW4gKz0gc2lsZW50RnJhbWUubGVuZ3RoO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcblxuICAgIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cyk7XG4gIH1cblxuICByZW11eElEMyh0cmFjayx0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgaWYobGVuZ3RoKSB7XG4gICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gdGhpcy5faW5pdFBUUykgLyB0aGlzLlBFU19USU1FU0NBTEUpO1xuICAgICAgICBzYW1wbGUuZHRzID0gKChzYW1wbGUuZHRzIC0gdGhpcy5faW5pdERUUykgLyB0aGlzLlBFU19USU1FU0NBTEUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwge1xuICAgICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICAgIGxldmVsIDogdGhpcy5sZXZlbCxcbiAgICAgICAgc24gOiB0aGlzLnNuLFxuICAgICAgICBzYW1wbGVzOnRyYWNrLnNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgfVxuXG4gIHJlbXV4VGV4dCh0cmFjayx0aW1lT2Zmc2V0KSB7XG4gICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYS5wdHMtYi5wdHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgaWYobGVuZ3RoKSB7XG4gICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIHRoaXMuX2luaXRQVFMpIC8gdGhpcy5QRVNfVElNRVNDQUxFKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHtcbiAgICAgICAgaWQgOiB0aGlzLmlkLFxuICAgICAgICBsZXZlbCA6IHRoaXMubGV2ZWwsXG4gICAgICAgIHNuIDogdGhpcy5zbixcbiAgICAgICAgc2FtcGxlczp0cmFjay5zYW1wbGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gIH1cblxuICBfUFRTTm9ybWFsaXplKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgICB2YXIgb2Zmc2V0O1xuICAgIGlmIChyZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAgIC8vIC0gMl4zM1xuICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICsgMl4zM1xuICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICB9XG4gICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNFJlbXV4ZXI7XG4iLCIvKipcbiAqIHBhc3N0aHJvdWdoIHJlbXV4ZXJcbiovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsaWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxuICBpbnNlcnREaXNjb250aW51aXR5KCkge1xuICB9XG5cbiAgc3dpdGNoTGV2ZWwoKSB7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgcmVtdXgoYXVkaW9UcmFjayx2aWRlb1RyYWNrLGlkM1RyYWNrLHRleHRUcmFjayx0aW1lT2Zmc2V0LHJhd0RhdGEpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIC8vIGdlbmVyYXRlIEluaXQgU2VnbWVudCBpZiBuZWVkZWRcbiAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIHZhciB0cmFja3MgPSB7fSxcbiAgICAgICAgICBkYXRhID0geyBpZCA6IHRoaXMuaWQsIHRyYWNrcyA6IHRyYWNrcywgdW5pcXVlIDogdHJ1ZSB9LFxuICAgICAgICAgIHRyYWNrID0gdmlkZW9UcmFjayxcbiAgICAgICAgICBjb2RlYyA9IHRyYWNrLmNvZGVjO1xuXG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgZGF0YS50cmFja3MudmlkZW8gPSB7XG4gICAgICAgICAgY29udGFpbmVyIDogdHJhY2suY29udGFpbmVyLFxuICAgICAgICAgIGNvZGVjIDogIGNvZGVjLFxuICAgICAgICAgIG1ldGFkYXRhIDoge1xuICAgICAgICAgICAgd2lkdGggOiB0cmFjay53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA6IHRyYWNrLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdHJhY2sgPSBhdWRpb1RyYWNrO1xuICAgICAgY29kZWMgPSB0cmFjay5jb2RlYztcbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBkYXRhLnRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgICBjb250YWluZXIgOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgY29kZWMgOiAgY29kZWMsXG4gICAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgICBjaGFubmVsQ291bnQgOiB0cmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxkYXRhKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwge1xuICAgICAgaWQgOiB0aGlzLmlkLFxuICAgICAgZGF0YTE6IHJhd0RhdGEsXG4gICAgICBzdGFydFBUUzogdGltZU9mZnNldCxcbiAgICAgIHN0YXJ0RFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgdHlwZTogJ2F1ZGlvdmlkZW8nLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkIDogMFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NUaHJvdWdoUmVtdXhlcjtcbiIsIlxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuY2xhc3MgQXR0ckxpc3Qge1xuXG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIGZvcih2YXIgYXR0ciBpbiBhdHRycyl7XG4gICAgICBpZihhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxKSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cblxuICBkZWNpbWFsRmxvYXRpbmdQb2ludChhdHRyTmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfVxuXG4gIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XG4gIH1cblxuICBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZSkge1xuICAgIGNvbnN0IHJlcyA9IC9eKFxcZCspeChcXGQrKSQvLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUF0dHJMaXN0KGlucHV0KSB7XG4gICAgY29uc3QgcmUgPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7XG4gICAgdmFyIG1hdGNoLCBhdHRycyA9IHt9O1xuICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdLCBxdW90ZSA9ICdcIic7XG5cbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxuICAgICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gKHZhbHVlLmxlbmd0aC0xKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBdHRyTGlzdDtcbiIsInZhciBCaW5hcnlTZWFyY2ggPSB7XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmlzb25GdW5jdGlvblxuICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBvYmplY3QgaWYgaXQgaXMgZm91bmQgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VhcmNoOiBmdW5jdGlvbihsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgXG4gICAgICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRnVuY3Rpb24oY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5U2VhcmNoO1xuIiwiLyoqXG4gKlxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gKlxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxuICpcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcbiAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcbiAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbiAgICAvKipcbiAgICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAgICAgKi9cblxudmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAgIDB4MmEgOiAweGUxLCAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gICAgMHg1YyA6IDB4ZTksIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVlIDogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAgIDB4NWYgOiAweGYzLCAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gICAgMHg2MCA6IDB4ZmEsIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgICAweDdiIDogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gICAgMHg3YyA6IDB4ZjcsIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAgIDB4N2QgOiAweGQxLCAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAgIDB4N2UgOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAgIDB4N2YgOiAweDI1ODgsIC8vIEZ1bGwgYmxvY2tcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAxNiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAgIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgICAweDgwIDogMHhhZSwgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gICAgMHg4MSA6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXG4gICAgMHg4MiA6IDB4YmQsIC8vIDEvMiBzeW1ib2xcbiAgICAweDgzIDogMHhiZiwgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgICAweDg0IDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgICAweDg1IDogMHhhMiwgLy8gQ2VudHMgc3ltYm9sXG4gICAgMHg4NiA6IDB4YTMsIC8vIFBvdW5kcyBzdGVybGluZ1xuICAgIDB4ODcgOiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxuICAgIDB4ODggOiAweGUwLCAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4OSA6IDB4MjAsIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAgIDB4OGEgOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4YiA6IDB4ZTIsIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGMgOiAweGVhLCAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhkIDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZSA6IDB4ZjQsIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGYgOiAweGZiLCAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4OTAgOiAweGMxLCAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgICAweDkxIDogMHhjOSwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gICAgMHg5MiA6IDB4ZDMsIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAgIDB4OTMgOiAweGRhLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgICAweDk0IDogMHhkYywgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gICAgMHg5NSA6IDB4ZmMsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAgIDB4OTYgOiAweDIwMTgsIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gICAgMHg5NyA6IDB4YTEsIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgICAweDk4IDogMHgyYSwgLy8gYXN0ZXJpc2tcbiAgICAweDk5IDogMHgyMDE5LCAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAgIDB4OWEgOiAweDI1MDEsIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gICAgMHg5YiA6IDB4YTksIC8vIGNvcHlyaWdodCBzaWduXG4gICAgMHg5YyA6IDB4MjEyMCwgLy8gU2VydmljZSBtYXJrXG4gICAgMHg5ZCA6IDB4MjAyMiwgLy8gKHJvdW5kKSBidWxsZXRcbiAgICAweDllIDogMHgyMDFjLCAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4OWYgOiAweDIwMWQsIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4YTAgOiAweGMwLCAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhMSA6IDB4YzIsIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gICAgMHhhMiA6IDB4YzcsIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAgIDB4YTMgOiAweGM4LCAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhNCA6IDB4Y2EsIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gICAgMHhhNSA6IDB4Y2IsIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTYgOiAweGViLCAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTcgOiAweGNlLCAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAgIDB4YTggOiAweGNmLCAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTkgOiAweGVmLCAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YWEgOiAweGQ0LCAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAgIDB4YWIgOiAweGQ5LCAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhYyA6IDB4ZjksIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgICAweGFkIDogMHhkYiwgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgICAweGFlIDogMHhhYiwgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweGFmIDogMHhiYiwgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgICAweGIwIDogMHhjMywgLy8gVXBwZXJjYXNlIEEsIHRpbGRlXG4gICAgMHhiMSA6IDB4ZTMsIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxuICAgIDB4YjIgOiAweGNkLCAvLyBVcHBlcmNhc2UgSSwgYWN1dGUgYWNjZW50XG4gICAgMHhiMyA6IDB4Y2MsIC8vIFVwcGVyY2FzZSBJLCBncmF2ZSBhY2NlbnRcbiAgICAweGI0IDogMHhlYywgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxuICAgIDB4YjUgOiAweGQyLCAvLyBVcHBlcmNhc2UgTywgZ3JhdmUgYWNjZW50XG4gICAgMHhiNiA6IDB4ZjIsIC8vIExvd2VyY2FzZSBvLCBncmF2ZSBhY2NlbnRcbiAgICAweGI3IDogMHhkNSwgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXG4gICAgMHhiOCA6IDB4ZjUsIC8vIExvd2VyY2FzZSBvLCB0aWxkZVxuICAgIDB4YjkgOiAweDdiLCAvLyBPcGVuIGN1cmx5IGJyYWNlXG4gICAgMHhiYSA6IDB4N2QsIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcbiAgICAweGJiIDogMHg1YywgLy8gQmFja3NsYXNoXG4gICAgMHhiYyA6IDB4NWUsIC8vIENhcmV0XG4gICAgMHhiZCA6IDB4NWYsIC8vIFVuZGVyc2NvcmVcbiAgICAweGJlIDogMHg3YywgLy8gUGlwZSAodmVydGljYWwgbGluZSlcbiAgICAweGJmIDogMHgyMjNjLCAvLyBUaWxkZSBvcGVyYXRvclxuICAgIDB4YzAgOiAweGM0LCAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XG4gICAgMHhjMSA6IDB4ZTQsIC8vIExvd2VyY2FzZSBBLCB1bWxhdXRcbiAgICAweGMyIDogMHhkNiwgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxuICAgIDB4YzMgOiAweGY2LCAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XG4gICAgMHhjNCA6IDB4ZGYsIC8vIEVzc3pldHQgKHNoYXJwIFMpXG4gICAgMHhjNSA6IDB4YTUsIC8vIFllbiBzeW1ib2xcbiAgICAweGM2IDogMHhhNCwgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXG4gICAgMHhjNyA6IDB4MjUwMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHZlcnRpY2FsXG4gICAgMHhjOCA6IDB4YzUsIC8vIFVwcGVyY2FzZSBBLCByaW5nXG4gICAgMHhjOSA6IDB4ZTUsIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gICAgMHhjYSA6IDB4ZDgsIC8vIFVwcGVyY2FzZSBPLCBzdHJva2VcbiAgICAweGNiIDogMHhmOCwgLy8gTG93ZXJjYXNlIG8sIHN0cm9rXG4gICAgMHhjYyA6IDB4MjUwZiwgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XG4gICAgMHhjZCA6IDB4MjUxMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIGxlZnRcbiAgICAweGNlIDogMHgyNTE3LCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIHJpZ2h0XG4gICAgMHhjZiA6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24oYnl0ZSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGJ5dGU7XG4gICAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5cbnZhciBOUl9ST1dTID0gMTUsXG4gICAgTlJfQ09MUyA9IDMyO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbnZhciByb3dzTG93Q2gxID0gezB4MTEgOiAxLCAweDEyIDogMywgMHgxNSA6IDUsIDB4MTYgOiA3LCAweDE3IDogOSwgMHgxMCA6IDExLCAweDEzIDogMTIsIDB4MTQgOiAxNH07XG52YXIgcm93c0hpZ2hDaDEgPSB7MHgxMSA6IDIsIDB4MTIgOiA0LCAweDE1IDogNiwgMHgxNiA6IDgsIDB4MTcgOiAxMCwgMHgxMyA6IDEzLCAweDE0IDogMTV9O1xudmFyIHJvd3NMb3dDaDIgPSB7MHgxOSA6IDEsIDB4MUEgOiAzLCAweDFEIDogNSwgMHgxRSA6IDcsIDB4MUYgOiA5LCAweDE4IDogMTEsIDB4MUIgOiAxMiwgMHgxQyA6IDE0fTtcbnZhciByb3dzSGlnaENoMiA9IHsweDE5IDogMiwgMHgxQSA6IDQsIDB4MUQgOiA2LCAweDFFIDogOCwgMHgxRiA6IDEwLCAweDFCIDogMTMsIDB4MUMgOiAxNX07XG5cbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG5cbi8qKlxuICogU2ltcGxlIGxvZ2dlciBjbGFzcyB0byBiZSBhYmxlIHRvIHdyaXRlIHdpdGggdGltZS1zdGFtcHMgYW5kIGZpbHRlciBvbiBsZXZlbC5cbiAqL1xudmFyIGxvZ2dlciA9IHtcbiAgICB2ZXJib3NlRmlsdGVyIDogeydEQVRBJyA6IDMsICdERUJVRycgOiAzLCAnSU5GTycgOiAyLCAnV0FSTklORycgOiAyLCAnVEVYVCcgOiAxLCAnRVJST1InIDogMH0sXG4gICAgdGltZSA6IG51bGwsXG4gICAgdmVyYm9zZUxldmVsIDogMCwgLy8gT25seSB3cml0ZSBlcnJvcnNcbiAgICBzZXRUaW1lIDogZnVuY3Rpb24obmV3VGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSBuZXdUaW1lO1xuICAgIH0sXG4gICAgbG9nIDogZnVuY3Rpb24oc2V2ZXJpdHksIG1zZykge1xuICAgICAgICB2YXIgbWluTGV2ZWwgPSB0aGlzLnZlcmJvc2VGaWx0ZXJbc2V2ZXJpdHldO1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGltZSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uKG51bUFycmF5KSB7XG4gICAgdmFyIGhleEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhBcnJheTtcbn07XG5cbmNsYXNzIFBlblN0YXRlIHtcblxuICAgIGNvbnN0cnVjdG9yKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZCB8fCAnd2hpdGUnO1xuICAgICAgICB0aGlzLnVuZGVybGluZSA9IHVuZGVybGluZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCAnYmxhY2snO1xuICAgICAgICB0aGlzLmZsYXNoID0gZmxhc2ggfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0U3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2gpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKCAodGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcykgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoKSApO1xuICAgIH1cblxuICAgIGNvcHkobmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgK1xuICAgICAgICAgICAgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2gpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXJcbntcblxuICAgIGNvbnN0cnVjdG9yKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSB1Y2hhciB8fCAnICc7IC8vIHVuaWNvZGUgY2hhcmFjdGVyXG4gICAgICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICAgIH1cblxuICAgIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgICB9XG5cbiAgICBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGNvcHkobmV3Q2hhcikge1xuICAgICAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBSb3cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTOyBpICsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cblxuICAgIGNvcHkob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAgICovXG4gICAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgICAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgICAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wb3MrMTsgaSA8IG5ld1BvcysxIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGJhY2tTcGFjZSgpIHtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9XG5cbiAgICBpbnNlcnRDaGFyKGJ5dGUpIHtcbiAgICAgICAgaWYgKGJ5dGUgPj0gMHg5MCkgeyAvL0V4dGVuZGVkIGNoYXJcbiAgICAgICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ0Nhbm5vdCBpbnNlcnQgJyArIGJ5dGUudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihjaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgICB9XG5cbiAgICBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0UG9zIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICAgIH1cblxuICAgIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICAgICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICAgIH1cblxuICAgIGdldFRleHRTdHJpbmcoKSB7XG4gICAgICAgIHZhciBjaGFycyA9IFtdO1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICAgICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICB2YXIgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICAgICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuKi9cbmNsYXNzIENhcHRpb25TY3JlZW4ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCAgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KCkpOyAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgICAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cblxuICAgIGNvcHkob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICBiYWNrU3BhY2UoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LmJhY2tTcGFjZSgpO1xuICAgIH1cblxuICAgIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICAgKi9cbiAgICBpbnNlcnRDaGFyKGNoYXIpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuaW5zZXJ0Q2hhcihjaGFyKTtcbiAgICB9XG5cbiAgICBzZXRQZW4oc3R5bGVzKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xuICAgIH1cblxuICAgIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcbiAgICB9XG5cbiAgICBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XG4gICAgfVxuXG4gICAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICAgICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXdSb3cgPSB0aGlzLm5yUm9sbFVwUm93cy0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgICAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50LTEsIDApO1xuICAgICAgICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmb3JlZ3JvdW5kIDogcGFjRGF0YS5jb2xvciwgdW5kZXJsaW5lIDogcGFjRGF0YS51bmRlcmxpbmUsIGl0YWxpY3MgOiBwYWNEYXRhLml0YWxpY3MsIGJhY2tncm91bmQgOiAnYmxhY2snLCBmbGFzaCA6IGZhbHNlfTtcbiAgICAgICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICovXG4gICAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG5cbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy9TcGFjZVxuICAgIH1cblxuICAgIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XG4gICAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICAgIH1cblxuICAgIHJvbGxVcCgpIHtcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcbiAgICAgICAgICAgIHJldHVybjsgLy9Ob3QgcHJvcGVybHkgc2V0dXBcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICAgICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgICB2YXIgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XG4gICAgICAgIHRvcFJvdy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSb2xsaW5nIHVwJyk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYWxsIG5vbi1lbXB0eSByb3dzIHdpdGggYXMgdW5pY29kZSB0ZXh0LlxuICAgICovXG4gICAgZ2V0RGlzcGxheVRleHQoYXNPbmVSb3cpIHtcbiAgICAgICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGRpc3BsYXlUZXh0ID0gW107XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciByb3dOciA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICAgICAgICAgIHJvd05yID0gaSsxO1xuICAgICAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgJzogXFwnJyArIHJvd1RleHQgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzO1xuICAgIH1cbn1cblxuLy92YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xuXG5jbGFzcyBDZWE2MDhDaGFubmVsXG57XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XG5cbiAgICAgICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MtMV07XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTLTFdO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q3VlRW5kVGltZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICAgIH1cblxuICAgIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gICAgfVxuXG4gICAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICB9XG5cbiAgICBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICAgICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB9XG5cbiAgICBpbnNlcnRDaGFycyhjaGFycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBjaGFycy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjY1JDTCgpIHsgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICAgIH1cblxuICAgIGNjQlMoKSB7IC8vIEJhY2tTcGFjZVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNjQU9GKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2NBT04oKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNjREVSKCkgeyAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NSVShuclJvd3MpIHsgLy9Sb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsnKSAtIFJvbGwgVXAnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgICB9XG5cbiAgICBjY0ZPTigpIHsgLy9GbGFzaCBPblxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0ZPTiAtIEZsYXNoIE9uJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtmbGFzaCA6IHRydWV9KTtcbiAgICB9XG5cbiAgICBjY1JEQygpIHsgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgICB9XG5cbiAgICBjY1RSKCkgeyAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RSJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gICAgfVxuXG4gICAgY2NSVEQoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JURCcpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH1cblxuICAgIGNjRURNKCkgeyAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBjY0NSKCkgeyAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICAgICAgbG9nZ2VyLmxvZygnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NFTk0oKSB7IC8vRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIH1cblxuICAgIGNjRU9DKCkgeyAvL0VuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNjVE8obnJDb2xzKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICAgIH1cblxuICAgIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHsgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmbGFzaCA6IGZhbHNlfTtcbiAgICAgICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgICAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUvMikgLSAweDEwO1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICBvdXRwdXREYXRhVXBkYXRlKCkge1xuICAgICAgICB2YXIgdCA9IGxvZ2dlci50aW1lO1xuICAgICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENlYTYwOFBhcnNlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7J3BhZGRpbmcnIDogMCwgJ2NoYXInIDogMCwgJ2NtZCcgOiAwLCAnb3RoZXInIDogMH07XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xuICAgIH1cblxuICAgIHNldEhhbmRsZXIoaW5kZXgsIG5ld0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAgICovXG4gICAgYWRkRGF0YSh0LCBieXRlTGlzdCkge1xuICAgICAgICB2YXIgY21kRm91bmQsIGEsIGIsXG4gICAgICAgIGNoYXJzRm91bmQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gdDtcbiAgICAgICAgbG9nZ2VyLnNldFRpbWUodCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYnl0ZUxpc3QubGVuZ3RoIDsgaSs9Mikge1xuICAgICAgICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgICAgICAgIGIgPSBieXRlTGlzdFtpKzFdICYgMHg3ZjtcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RBVEEnLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpKzFdXSkgKyddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnItMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jaGFyICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2krMV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICovXG4gICAgcGFyc2VDbWQoYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MkYpO1xuICAgICAgICB2YXIgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFGKSAmJiAoMHgyMSA8PSBiICYmIGIgPD0gMHgyMyk7XG4gICAgICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hOciA9IDI7IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG5cbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJCKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJDKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkUpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgcGFyc2VNaWRyb3coYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgaWYgKCAoKGEgPT09IDB4MTEpIHx8IChhID09PSAweDE5KSkgJiYgMHgyMCA8PSBiICYmIGIgPD0gMHgyZikge1xuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBjaE5yID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgIGNoTnIgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VyckNoTnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnItMV07XG4gICAgICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgKi9cbiAgICBwYXJzZVBBQyhhLCBiKSB7XG5cbiAgICAgICB2YXIgY2hOciA9IG51bGw7XG4gICAgICAgdmFyIHJvdyA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKCgweDExIDw9IGEgICYmIGEgPD0gMHgxNykgfHwgKDB4MTkgPD0gYSAmJiBhIDw9IDB4MUYpKSAmJiAoMHg0MCA8PSBiICYmIGIgPD0gMHg3Rik7XG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKTtcbiAgICAgICAgaWYgKCEgKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNoTnIgPSAoYSA8PSAweDE3KSA/IDEgOiAyO1xuXG4gICAgICAgIGlmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKSB7XG4gICAgICAgICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICAgICAgfSBlbHNlIHsgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY0RhdGEgPSB0aGlzLmludGVycHJldFBBQyhyb3csIGIpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRQQUMocGFjRGF0YSk7XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgaW50ZXJwcmV0UEFDKHJvdywgYnl0ZSkge1xuICAgICAgICB2YXIgcGFjSW5kZXggPSBieXRlO1xuICAgICAgICB2YXIgcGFjRGF0YSA9IHtjb2xvciA6IG51bGwsIGl0YWxpY3MgOiBmYWxzZSwgaW5kZW50IDogbnVsbCwgdW5kZXJsaW5lIDogZmFsc2UsIHJvdyA6IHJvd307XG5cbiAgICAgICAgaWYgKGJ5dGUgPiAweDVGKSB7XG4gICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICAgICAgfVxuICAgICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgICAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleC8yKV07XG4gICAgICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICAgICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleC0weDEwKS8yKSkqNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXJzZUNoYXJzKGEsIGIpIHtcblxuICAgICAgIHZhciAgY2hhbm5lbE5yID0gbnVsbCxcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IG51bGwsXG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBudWxsO1xuXG4gICAgICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGlmICgweDExIDw9IGNoYXJDb2RlMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBvbmVDb2RlID0gYjtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgICAgICB9IGVsc2UgaWYgKDB4MjAgPD0gYSAmJiBhIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IChiID09PSAwKSA/IFthXSA6IFthLCBiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICAgICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFyQ29kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAqL1xuICAgIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgICAgIHZhciAgYmtnRGF0YSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY2hOcixcbiAgICAgICAgICAgIGNoYW5uZWw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MmYpO1xuICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAoMHgyZCA8PWIgJiYgYiA8PSAweDJmKTtcbiAgICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYmtnRGF0YSA9IHt9O1xuICAgICAgICBpZiAoYSAgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiLTB4MjApLzIpO1xuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hOciA9IChhIDwgMHgxOCkgPyAxIDogMjtcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBmb3IgKHZhciBpPTAgOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wIDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0uY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlYTYwOFBhcnNlcjtcbiIsInZhciBDdWVzID0ge1xuXG4gIG5ld0N1ZTogZnVuY3Rpb24odHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgY2FwdGlvblNjcmVlbikge1xuICAgIHZhciByb3c7XG4gICAgdmFyIGN1ZTtcbiAgICB2YXIgaW5kZW50aW5nO1xuICAgIHZhciBpbmRlbnQ7XG4gICAgdmFyIHRleHQ7XG4gICAgdmFyIFZUVEN1ZSA9IHdpbmRvdy5WVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcblxuICAgIGZvciAodmFyIHI9MDsgcjxjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspXG4gICAge1xuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICB0ZXh0ID0gJyc7XG5cbiAgICAgIGlmICghcm93LmlzRW1wdHkoKSlcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgYz0wOyBjPHJvdy5jaGFycy5sZW5ndGg7IGMrKylcbiAgICAgICAge1xuICAgICAgICAgIGlmIChyb3cuY2hhcnNbY10udWNoYXIubWF0Y2goL1xccy8pICYmIGluZGVudGluZylcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0LnRyaW0oKSk7XG5cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNilcbiAgICAgICAge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVlRUQ3VlLmxpbmUgZ2V0J3MgZmxha2V5IHdoZW4gdXNpbmcgY29udHJvbHMsIHNvIGxldCdzIG5vdyBpbmNsdWRlIGxpbmUgMTMmMTRcbiAgICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykpXG4gICAgICAgIHtcbiAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGN1ZS5saW5lID0gKHIgPiA3ID8gciAtIDIgOiByICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICBjdWUucG9zaXRpb24gPSAxMDAgKiAoaW5kZW50IC8gMzIpICsgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSA/IDUwIDogMCk7XG4gICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1ZXM7XG4iLCIvKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuXG4gLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IoaGFsZkxpZmUpIHtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IDA7XG4gIH1cblxuICBzYW1wbGUod2VpZ2h0LHZhbHVlKSB7XG4gICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH1cblxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVXTUE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5cbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8vbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuXG5mdW5jdGlvbiBmb3JtYXRNc2codHlwZSwgbXNnKSB7XG4gIG1zZyA9ICdbJyArICB0eXBlICsgJ10gPiAnICsgbXNnO1xuICByZXR1cm4gbXNnO1xufVxuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XG4gIGNvbnN0IGZ1bmMgPSB3aW5kb3cuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgaWYoYXJnc1swXSkge1xuICAgICAgICBhcmdzWzBdID0gZm9ybWF0TXNnKHR5cGUsIGFyZ3NbMF0pO1xuICAgICAgfVxuICAgICAgZnVuYy5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBlbmFibGVMb2dzID0gZnVuY3Rpb24oZGVidWdDb25maWcpIHtcbiAgaWYgKGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsXG4gICAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgICAgLy8ndHJhY2UnLFxuICAgICAgJ2RlYnVnJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3dhcm4nLFxuICAgICAgJ2Vycm9yJ1xuICAgICk7XG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIHRyeSB7XG4gICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuIiwiaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIUFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSkge1xuICBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcyk7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSB0aGF0Lmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihlbmQgLSBzdGFydCk7XG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRBcnJheVtpXSA9IHRoYXRbaSArIHN0YXJ0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbiIsIi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbmNsYXNzIFRpbWVSYW5nZXMge1xuICBzdGF0aWMgdG9TdHJpbmcocikge1xuICAgIHZhciBsb2cgPSAnJywgbGVuID0gci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKSArICcsJyArIHIuZW5kKGkpICsgJ10nO1xuICAgIH1cbiAgICByZXR1cm4gbG9nO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVSYW5nZXM7XG4iLCJ2YXIgVVJMSGVscGVyID0ge1xuICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBVUkwgZnJvbSBhIHJlbGF0aXZlIG9uZSB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZVVSTFxuICAvLyBpZiByZWxhdGl2ZVVSTCBpcyBhbiBhYnNvbHV0ZSBVUkwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpcy5cbiAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24oYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuICAgIGlmICgvXlthLXpdKzovaS50ZXN0KHJlbGF0aXZlVVJMKSkge1xuICAgICAgLy8gY29tcGxldGUgdXJsLCBub3QgcmVsYXRpdmVcbiAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICB9XG5cbiAgICB2YXIgcmVsYXRpdmVVUkxRdWVyeSA9IG51bGw7XG4gICAgdmFyIHJlbGF0aXZlVVJMSGFzaCA9IG51bGw7XG5cbiAgICB2YXIgcmVsYXRpdmVVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhyZWxhdGl2ZVVSTCk7XG4gICAgaWYgKHJlbGF0aXZlVVJMSGFzaFNwbGl0KSB7XG4gICAgICByZWxhdGl2ZVVSTEhhc2ggPSByZWxhdGl2ZVVSTEhhc2hTcGxpdFsyXTtcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkxIYXNoU3BsaXRbMV07XG4gICAgfVxuICAgIHZhciByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXQgPSAvXihbXlxcP10qKSguKikkLy5leGVjKHJlbGF0aXZlVVJMKTtcbiAgICBpZiAocmVsYXRpdmVVUkxRdWVyeVNwbGl0KSB7XG4gICAgICByZWxhdGl2ZVVSTFF1ZXJ5ID0gcmVsYXRpdmVVUkxRdWVyeVNwbGl0WzJdO1xuICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXRbMV07XG4gICAgfVxuXG4gICAgdmFyIGJhc2VVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhiYXNlVVJMKTtcbiAgICBpZiAoYmFzZVVSTEhhc2hTcGxpdCkge1xuICAgICAgYmFzZVVSTCA9IGJhc2VVUkxIYXNoU3BsaXRbMV07XG4gICAgfVxuICAgIHZhciBiYXNlVVJMUXVlcnlTcGxpdCA9IC9eKFteXFw/XSopKC4qKSQvLmV4ZWMoYmFzZVVSTCk7XG4gICAgaWYgKGJhc2VVUkxRdWVyeVNwbGl0KSB7XG4gICAgICBiYXNlVVJMID0gYmFzZVVSTFF1ZXJ5U3BsaXRbMV07XG4gICAgfVxuXG4gICAgdmFyIGJhc2VVUkxEb21haW5TcGxpdCA9IC9eKChbYS16XSs6KT9cXC9cXC9bYS16MC05XFwuXFwtX35dKyg6WzAtOV0rKT8pPyhcXC8uKikkL2kuZXhlYyhiYXNlVVJMKTtcbiAgICBpZiAoIWJhc2VVUkxEb21haW5TcGxpdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIGUuZy4gJ2h0dHA6JywgJ2h0dHBzOicsICcnXG4gICAgdmFyIGJhc2VVUkxQcm90b2NvbCA9IGJhc2VVUkxEb21haW5TcGxpdFsyXSB8fCAnJztcbiAgICAvLyBlLmcuICdodHRwOi8vZXhhbXBsZS5jb20nLCAnLy9leGFtcGxlLmNvbScsICcnXG4gICAgdmFyIGJhc2VVUkxQcm90b2NvbERvbWFpbiA9IGJhc2VVUkxEb21haW5TcGxpdFsxXSB8fCAnJztcbiAgICAvLyBlLmcuICcvYS9iL2MvcGxheWxpc3QubTN1OCdcbiAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlVVJMRG9tYWluU3BsaXRbNF07XG5cbiAgICB2YXIgYnVpbHRVUkwgPSBudWxsO1xuICAgIGlmICgvXlxcL1xcLy8udGVzdChyZWxhdGl2ZVVSTCkpIHtcbiAgICAgIC8vIHJlbGF0aXZlIHVybCBzdGFydHMgd3RoICcvLycgc28gY29weSBwcm90b2NvbCAod2hpY2ggbWF5IGJlICcnIGlmIGJhc2VVcmwgZGlkbid0IHByb3ZpZGUgb25lKVxuICAgICAgYnVpbHRVUkwgPSBiYXNlVVJMUHJvdG9jb2wrJy8vJytVUkxIZWxwZXIuYnVpbGRBYnNvbHV0ZVBhdGgoJycsIHJlbGF0aXZlVVJMLnN1YnN0cmluZygyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFwvLy50ZXN0KHJlbGF0aXZlVVJMKSkge1xuICAgICAgLy8gcmVsYXRpdmUgdXJsIHN0YXJ0cyB3aXRoICcvJyBzbyBzdGFydCBmcm9tIHJvb3Qgb2YgZG9tYWluXG4gICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbERvbWFpbisnLycrVVJMSGVscGVyLmJ1aWxkQWJzb2x1dGVQYXRoKCcnLCByZWxhdGl2ZVVSTC5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJ1aWx0VVJMID0gVVJMSGVscGVyLmJ1aWxkQWJzb2x1dGVQYXRoKGJhc2VVUkxQcm90b2NvbERvbWFpbitiYXNlVVJMUGF0aCwgcmVsYXRpdmVVUkwpO1xuICAgIH1cblxuICAgIC8vIHB1dCB0aGUgcXVlcnkgYW5kIGhhc2ggcGFydHMgYmFja1xuICAgIGlmIChyZWxhdGl2ZVVSTFF1ZXJ5KSB7XG4gICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTFF1ZXJ5O1xuICAgIH1cbiAgICBpZiAocmVsYXRpdmVVUkxIYXNoKSB7XG4gICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTEhhc2g7XG4gICAgfVxuICAgIHJldHVybiBidWlsdFVSTDtcbiAgfSxcblxuICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBwYXRoIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlUGF0aFxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2RvY3VtZW50L2Nvb2tpZSNVc2luZ19yZWxhdGl2ZV9VUkxzX2luX3RoZV9wYXRoX3BhcmFtZXRlclxuICAvLyB0aGlzIGRvZXMgbm90IGhhbmRsZSB0aGUgY2FzZSB3aGVyZSByZWxhdGl2ZVBhdGggaXMgXCIvXCIgb3IgXCIvL1wiLiBUaGVzZSBjYXNlcyBzaG91bGQgYmUgaGFuZGxlZCBvdXRzaWRlIHRoaXMuXG4gIGJ1aWxkQWJzb2x1dGVQYXRoOiBmdW5jdGlvbihiYXNlUGF0aCwgcmVsYXRpdmVQYXRoKSB7XG4gICAgdmFyIHNSZWxQYXRoID0gcmVsYXRpdmVQYXRoO1xuICAgIHZhciBuVXBMbiwgc0RpciA9ICcnLCBzUGF0aCA9IGJhc2VQYXRoLnJlcGxhY2UoL1teXFwvXSokLywgc1JlbFBhdGgucmVwbGFjZSgvKFxcL3xeKSg/OlxcLj9cXC8rKSsvZywgJyQxJykpO1xuICAgIGZvciAodmFyIG5FbmQsIG5TdGFydCA9IDA7IG5FbmQgPSBzUGF0aC5pbmRleE9mKCcvLi4vJywgblN0YXJ0KSwgbkVuZCA+IC0xOyBuU3RhcnQgPSBuRW5kICsgblVwTG4pIHtcbiAgICAgIG5VcExuID0gL15cXC8oPzpcXC5cXC5cXC8pKi8uZXhlYyhzUGF0aC5zbGljZShuRW5kKSlbMF0ubGVuZ3RoO1xuICAgICAgc0RpciA9IChzRGlyICsgc1BhdGguc3Vic3RyaW5nKG5TdGFydCwgbkVuZCkpLnJlcGxhY2UobmV3IFJlZ0V4cCgnKD86XFxcXFxcLytbXlxcXFxcXC9dKil7MCwnICsgKChuVXBMbiAtIDEpIC8gMykgKyAnfSQnKSwgJy8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNEaXIgKyBzUGF0aC5zdWJzdHIoblN0YXJ0KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVUkxIZWxwZXI7XG4iLCIvKipcbiAqIFhIUiBiYXNlZCBsb2dnZXJcbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBYaHJMb2FkZXIge1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLnhoclNldHVwKSB7XG4gICAgICB0aGlzLnhoclNldHVwID0gY29uZmlnLnhoclNldHVwO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyICYmIGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gbnVsbDtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG51bGw7XG4gIH1cblxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnN0YXRzID0ge3RyZXF1ZXN0OiBwZXJmb3JtYW5jZS5ub3coKSwgcmV0cnk6IDB9O1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5O1xuICAgIHRoaXMubG9hZEludGVybmFsKCk7XG4gIH1cblxuICBsb2FkSW50ZXJuYWwoKSB7XG4gICAgdmFyIHhociwgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuXG4gICAgeGhyLm9ubG9hZGVuZCA9IHRoaXMubG9hZGVuZC5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG5cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kLTEpKTtcbiAgICB9XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xuICAgIGxldCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMudGZpcnN0ID0gMDtcbiAgICBzdGF0cy5sb2FkZWQgPSAwO1xuICAgIGlmICh0aGlzLnhoclNldHVwKSB7XG4gICAgICB0aGlzLnhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgIH1cbiAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgbG9hZGVuZChldmVudCkge1xuICAgIHZhciB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBzdGF0dXMgPSB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMsXG4gICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW4gYW55IGNhc2UgY2xlYXIgdGhlIGN1cnJlbnQgeGhycyB0aW1lb3V0XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcblxuICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApICB7XG4gICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCxwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICBsZXQgZGF0YSxsZW47XG4gICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICBsZXQgcmVzcG9uc2UgPSB7IHVybCA6IHhoci5yZXNwb25zZVVSTCwgZGF0YSA6IGRhdGEgfTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgaWYgKHN0YXRzLnJldHJ5ID49IGNvbmZpZy5tYXhSZXRyeSB8fCAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH1gICk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlIDogc3RhdHVzLCB0ZXh0IDogeGhyLnN0YXR1c1RleHR9LCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXRyeVxuICAgICAgICBsb2dnZXIud2FybihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH0sIHJldHJ5aW5nIGluICR7dGhpcy5yZXRyeURlbGF5fS4uLmApO1xuICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICB0aGlzLnJldHJ5RGVsYXkgPSBNYXRoLm1pbigyICogdGhpcy5yZXRyeURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XG4gICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCApO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBpZiAoc3RhdHMudGZpcnN0ID09PSAwKSB7XG4gICAgICBzdGF0cy50Zmlyc3QgPSBNYXRoLm1heChwZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMudHJlcXVlc3QpO1xuICAgIH1cbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICAgIGxldCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgLy8gbGFzdCBhcmdzIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xuIl19
