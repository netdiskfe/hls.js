(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _ewmaBandwidthEstimator = require('./ewma-bandwidth-estimator');

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._autoLevelCapping = -1;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.onCheck = _this.abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.timer = setInterval(this.onCheck, 100);
        }
        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this.bwEstimator) {
          var hls = this.hls,
              level = data.frag.level,
              isLive = hls.levels[level].details.live,
              config = hls.config,
              ewmaFast = void 0,
              ewmaSlow = void 0;

          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this.bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
        this.fragCurrent = frag;
      }
    }
  }, {
    key: 'abandonRulesCheck',
    value: function abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls,
          v = hls.media,
          frag = this.fragCurrent,
          loader = frag.loader;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRulesCheck');
        this.clearTimer();
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(v.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levels[frag.level].bitrate / 8)),
              pos = v.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel >= 0; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              fragLevelNextLoadedDelay = frag.duration * levels[nextLoadLevel].bitrate / (8 * 0.8 * loadRate);
              _logger.logger.log('fragLoadedDelay/bufferStarvationDelay/fragLevelNextLoadedDelay[' + nextLoadLevel + '] :' + fragLoadedDelay.toFixed(1) + '/' + bufferStarvationDelay.toFixed(1) + '/' + fragLevelNextLoadedDelay.toFixed(1));
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              // ensure nextLoadLevel is not negative
              nextLoadLevel = Math.max(0, nextLoadLevel);
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this.bwEstimator.sample(requestDelay, stats.loaded);
              // abort fragment loading ...
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel);
              //abort fragment loading
              frag.loader.abort();
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        var stats = data.stats;
        // only update stats on first frag loading
        // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
        // and leading to wrong bw estimation
        if (stats.aborted === undefined && frag.loadCounter === 1) {
          this.bwEstimator.sample(performance.now() - stats.trequest, stats.loaded);
        }

        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      this._autoLevelCapping = newLevel;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this.hls,
          config = hls.config,
          levels = hls.levels,
          v = hls.media,
          i = void 0,
          maxAutoLevel = void 0;
      if (this._autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = this._autoLevelCapping;
      }

      // in case next auto level has been forced, return it straight-away (but capped)
      if (this._nextAutoLevel !== -1) {
        return Math.min(this._nextAutoLevel, maxAutoLevel);
      }
      var playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() / playbackRate : config.abrEwmaDefaultEstimate / playbackRate,
          adjustedbw = void 0;
      // follow algorithm captured from stagefright :
      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
      // Pick the highest bandwidth stream below or equal to estimated bandwidth.
      for (i = 0; i <= maxAutoLevel; i++) {
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= this.lastLoadedFragLevel) {
          adjustedbw = config.abrBandWidthFactor * avgbw;
        } else {
          adjustedbw = config.abrBandWidthUpFactor * avgbw;
        }
        if (adjustedbw < levels[i].bitrate) {
          return Math.max(0, i - 1);
        }
      }
      return i - 1;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

},{"../errors":27,"../event-handler":28,"../events":29,"../helper/buffer-helper":31,"../utils/logger":46,"./ewma-bandwidth-estimator":8}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var AudioStreamController = function (_EventHandler) {
  _inherits(AudioStreamController, _EventHandler);

  function AudioStreamController(hls) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(AudioStreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var media = this.media,
            lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.fragLoadError = 0;
        if (media && lastCurrentTime) {
          _logger.logger.log('configure startPosition @' + lastCurrentTime);
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos,
          track,
          trackDetails,
          hls = this.hls,
          config = hls.config;
      //logger.log('audioStream:' + this.state);
      switch (this.state) {
        case State.ERROR:
        //don't do anything in error state to avoid breaking further ...
        case State.PAUSED:
          //don't do anything in paused state either ...
          break;
        case State.STARTING:
          this.state = State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case State.IDLE:
          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }
          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,
              maxBufLen = config.maxMaxBufferLength;

          // if buffer length is less than maxBufLen try to load a new fragment
          if (bufferLen < maxBufLen && this.trackId < this.tracks.length) {
            trackDetails = this.tracks[this.trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = State.WAITING_TRACK;
              break;
            }

            // we just got done loading the final fragment, check if we need to finalize media stream
            if (!trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
              // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
              // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
              // between different renditions. using half frag duration should help cope with these cases.
              if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
                // Finalize the media stream
                this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                this.state = State.ENDED;
                break;
              }
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // if bufferEnd before start of playlist, load first fragment
            if (bufferEnd < start) {
              frag = fragments[0];
            } else {
              (function () {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }
                  foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
                    // offset should be within fragment boundary - config.maxFragLookUpTolerance
                    // this is to cope with situations like
                    // bufferEnd = 9.991
                    // frag[Ø] : [0,10]
                    // frag[1] : [10,20]
                    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                    //              frag start               frag start+duration
                    //                  |-----------------------------|
                    //              <--->                         <--->
                    //  ...--------><-----------------------------><---------....
                    // previous frag         matching fragment         next frag
                    //  return -1             return 0                 return 1
                    //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                    if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
                      return 1;
                    } else if (candidate.start - maxFragLookUpTolerance > bufferEnd) {
                      return -1;
                    }
                    return 0;
                  });
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              })();
            }
            if (frag) {
              //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId);
                this.state = State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // ensure that we are not reloading the same fragments in loop ...
                if (this.fragLoadIdx !== undefined) {
                  this.fragLoadIdx++;
                } else {
                  this.fragLoadIdx = 0;
                }
                if (frag.loadCounter) {
                  frag.loadCounter++;
                  var maxThreshold = config.fragLoadingLoopThreshold;
                  // if this frag has already been loaded 3 times, and if it has been reloaded recently
                  if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                    return;
                  }
                } else {
                  frag.loadCounter = 1;
                }
                frag.loadIdx = this.fragLoadIdx;
                this.fragCurrent = frag;
                this.startFragRequested = true;
                hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                this.state = State.FRAG_LOADING;
              }
            }
          }
          break;
        case State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var tracks = this.tracks;
      if (tracks) {
        // reset fragment load counter
        tracks.forEach(function (track) {
          if (track.details) {
            track.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (this.media) {
        this.lastCurrentTime = this.media.currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitch',
    value: function onAudioTrackSwitch(data) {
      this.trackId = data.id;
      this.state = State.IDLE;

      this.fragCurrent = null;
      this.state = State.PAUSED;
      // destroy useless demuxer when switching audio to main
      if (data.type === 'main') {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
      }
      // flush audio source buffer
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var details = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = details.totalduration;

      _logger.logger.log('track ' + trackId + ' loaded [' + details.startSN + ',' + details.endSN + '],duration:' + duration);
      details.PTSKnown = false;
      track.details = details;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = details.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === State.WAITING_TRACK) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'audio' && data.frag.level === fragCurrent.level && data.frag.sn === fragCurrent.sn) {
        this.state = State.PARSING;
        // transmux the MPEG-TS data to ISO-BMFF segments
        this.stats = data.stats;
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            start = fragCurrent.start,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec;
        this.pendingAppending = 0;
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'audio');
        }
        _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
        this.demuxer.push(data.payload, audioCodec, null, start, fragCurrent.cc, trackId, sn, duration, fragCurrent.decryptdata);
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = 'mp4a.40.2';
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.pendingAppending++;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' });
          }
          //trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var track = this.tracks[this.trackId],
            frag = this.fragCurrent;

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        _levelHelper2.default.updateFragPTSDTS(track.details, frag.sn, data.startPTS, data.endPTS);

        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer) {
            _this2.pendingAppending++;
            _this2.hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'audio', content: 'data' });
          }
        });
        this.nextLoadPosition = data.endPTS;
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        switch (this.state) {
          case State.PARSING:
          case State.PARSED:
            this.pendingAppending--;
            this._checkAppendedParsed();
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && this.pendingAppending === 0) {
        var frag = this.fragCurrent,
            stats = this.stats;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            if (loadError <= this.config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to 64s
              var delay = Math.min(Math.pow(2, loadError - 1) * this.config.fragLoadingRetryDelay, 64000);
              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
      this.tick();
    }
  }]);

  return AudioStreamController;
}(_eventHandler2.default);

exports.default = AudioStreamController;

},{"../demux/demuxer":20,"../errors":27,"../event-handler":28,"../events":29,"../helper/buffer-helper":31,"../helper/level-helper":32,"../utils/binary-search":42,"../utils/logger":46,"../utils/timeRanges":48}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    return _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));
  }

  _createClass(AudioTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset audio tracks on manifest loading
      this.tracks = [];
      this.trackId = -1;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.audioTracks || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
      // loop through available audio tracks and autoselect default if needed
      var id = 0;
      tracks.forEach(function (track) {
        if (track.default) {
          _this2.audioTrack = id;
          defaultFound = true;
          return;
        }
        id++;
      });
      if (defaultFound === false && tracks.length) {
        _logger.logger.log('no default audio track defined, use first audio track as default');
        this.audioTrack = 0;
      }
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id < this.tracks.length) {
        _logger.logger.log('audioTrack ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'setAudioTrackInternal',
    value: function setAudioTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            type = audioTrack.type;
        this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, { id: newId, type: type });
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (type !== 'main' && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: audioTrack.url, id: newId });
        }
      }
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

},{"../event-handler":28,"../events":29,"../utils/logger":46}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var audioExpected = data.audio,
          videoExpected = data.video,
          sourceBufferNb = 0;
      if (audioExpected || videoExpected) {
        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
      }
      this.sourceBufferNb = sourceBufferNb;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        //Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = URL.createObjectURL(ms);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          this.media.removeAttribute('src');
          this.media.load();
        }

        this.mediaSource = null;
        this.media = null;
        this.pendingTracks = {};
        this.sourceBuffer = {};
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      // if any buffer codecs pending, check if we have enough to create sourceBuffers
      var pendingTracks = this.pendingTracks,
          pendingTracksNb = Object.keys(pendingTracks).length;
      // if any pending tracks and (if nb of pending tracks matching expected nb or if unknoown expected nb)
      if (pendingTracksNb && (this.sourceBufferNb === pendingTracksNb || this.sourceBufferNb === 0)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }
      this.appending = false;
      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: this.parent });

      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:' + event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      if (Object.keys(this.sourceBuffer).length === 0) {
        for (var trackName in tracks) {
          this.pendingTracks[trackName] = tracks[trackName];
        }
        var mediaSource = this.mediaSource;
        if (mediaSource && mediaSource.readyState === 'open') {
          // try to create sourcebuffers if mediasource opened
          this.checkPendingTracks();
        }
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;

      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer with mimeType:' + mimeType);
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            track.buffer = sb;
          } catch (err) {
            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
          }
        }
      }
      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }
        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:' + data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false, frag: this.fragCurrent });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        if (!sb[type].ended) {
          return;
        }
        if (sb[type].updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
      //Notify the media element that it now has all of the media data
      mediaSource.endOfStream();
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediatly
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(event) {
      var details = event.details;
      if (details.fragments.length === 0) {
        return;
      }
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this.updateMediaElementDuration();
    }

    // https://github.com/dailymotion/hls.js/issues/355

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      if (this._levelDuration === null) {
        return;
      }
      var media = this.media,
          mediaSource = this.mediaSource,
          sourceBuffer = this.sourceBuffer;
      if (!media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
        return;
      }
      for (var type in sourceBuffer) {
        if (sourceBuffer[type].updating) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }
      if (this._msDuration === null) {
        // initialise to the value that the media source is reporting
        this._msDuration = mediaSource.duration;
      }
      // this._levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update mediasource duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level, as they
      if (this._levelDuration > this._msDuration) {
        _logger.logger.log('Updating mediasource duration to ' + this._levelDuration);
        mediaSource.duration = this._levelDuration;
        this._msDuration = this._levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        for (var type in sourceBuffer) {
          appended += sourceBuffer[type].buffered.length;
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          sourceBuffer = this.sourceBuffer,
          segments = this.segments;
      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          //logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type;
            if (sourceBuffer[type]) {
              // reset sourceBuffer ended flag before appending segment
              sourceBuffer[type].ended = false;
              //logger.log(`appending ${segment.content} ${segment.type} SB, size:${segment.data.length}, ${segment.parent}`);
              this.parent = segment.parent;
              sourceBuffer[type].appendBuffer(segment.data);
              this.appendError = 0;
              this.appended++;
              this.appending = true;
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }
              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              event.frag = this.fragCurrent;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
                return;
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              hls.trigger(_events2.default.ERROR, event);
              return;
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb,
          i,
          bufStart,
          bufEnd,
          flushStart,
          flushEnd,
          sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }
            sb = sourceBuffer[type];
            if (!sb.updating) {
              for (i = 0; i < sb.buffered.length; i++) {
                bufStart = sb.buffered.start(i);
                bufEnd = sb.buffered.end(i);
                // workaround firefox not able to properly flush multiple buffered range.
                if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                  flushStart = startOffset;
                  flushEnd = endOffset;
                } else {
                  flushStart = Math.max(bufStart, startOffset);
                  flushEnd = Math.min(bufEnd, endOffset);
                }
                /* sometimes sourcebuffer.remove() does not flush
                   the exact expected time range.
                   to avoid rounding issues/infinite loop,
                   only flush buffer range of length greater than 500ms.
                */
                if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                  this.flushBufferCounter++;
                  _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                  sb.remove(flushStart, flushEnd);
                  return false;
                }
              }
            } else {
              //logger.log('abort ' + type + ' append in progress');
              // this will abort any appending in progress
              //sb.abort();
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = this.restrictedLevels = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          this.timer = clearInterval(this.timer);
        }
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      if (!this.restrictedLevels) {
        this.restrictedLevels = [];
      }
      if (!this.isLevelRestricted(data.droppedLevel)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (this.hls.config.capLevelToPlayerSize) {
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.levels = data.levels;
        this.hls.firstLevel = this.getMaxLevel(data.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
      }
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          this.hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (this.hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            this.hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = this.hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var result = 0,
          i = void 0,
          level = void 0,
          mWidth = this.mediaWidth,
          mHeight = this.mediaHeight,
          lWidth = 0,
          lHeight = 0;

      for (i = 0; i <= capLevelIndex; i++) {
        level = this.levels[i];
        if (this.isLevelRestricted(i)) {
          break;
        }
        result = i;
        lWidth = level.width;
        lHeight = level.height;
        if (mWidth <= lWidth || mHeight <= lHeight) {
          break;
        }
      }
      return result;
    }
  }, {
    key: 'isLevelRestricted',
    value: function isLevelRestricted(level) {
      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      if (this.media) {
        width = this.media.width || this.media.clientWidth || this.media.offsetWidth;
        width *= this.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      if (this.media) {
        height = this.media.height || this.media.clientHeight || this.media.offsetHeight;
        height *= this.contentScaleFactor;
      }
      return height;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

},{"../event-handler":28,"../events":29}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = require('../utils/ewma');

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      //console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (!this.fast_ || !this.slow_ || this.fast_.getTotalWeight() < this.minWeight_) {
        return this.defaultEstimate_;
      }
      //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
      //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
      // Take the minimum of these two estimates.  This should have the effect of
      // adapting down quickly, but up more slowly.
      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

},{"../utils/ewma":45}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      if (this.hls.config.capLevelOnFPSDrop) {
        this.video = data.media instanceof HTMLVideoElement ? data.media : null;
        if (typeof this.video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), this.hls.config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod;
          this.hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > this.hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = this.hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (this.hls.autoLevelCapping === -1 || this.hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                this.hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: this.hls.currentLevel });
                this.hls.autoLevelCapping = currentLevel;
                this.hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      if (this.video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = this.video.getVideoPlaybackQuality();
          this.checkFPS(this.video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(this.video, this.video.webkitDecodedFrameCount, this.video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

},{"../event-handler":28,"../events":29,"../utils/logger":46}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

    _this.ontick = _this.tick.bind(_this);
    _this._manualLevel = _this._autoLevelCapping = -1;
    return _this;
  }

  _createClass(LevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this._manualLevel = -1;
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.canload = true;
      // speed up live playlist refresh if timer exists
      if (this.timer) {
        this.tick();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels0 = [],
          levels = [],
          bitrateStart,
          i,
          bitrateSet = {},
          videoCodecFound = false,
          audioCodecFound = false,
          hls = this.hls;

      // regroup redundant level together
      data.levels.forEach(function (level) {
        if (level.videoCodec) {
          videoCodecFound = true;
        }
        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
          audioCodecFound = true;
        }
        var redundantLevelId = bitrateSet[level.bitrate];
        if (redundantLevelId === undefined) {
          bitrateSet[level.bitrate] = levels0.length;
          level.url = [level.url];
          level.urlId = 0;
          levels0.push(level);
        } else {
          levels0[redundantLevelId].url.push(level.url);
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels0.forEach(function (level) {
          if (level.videoCodec) {
            levels.push(level);
          }
        });
      } else {
        levels = levels0;
      }

      // only keep level with supported audio/video codecs
      levels = levels.filter(function (level) {
        var checkSupportedAudio = function checkSupportedAudio(codec) {
          return MediaSource.isTypeSupported('audio/mp4;codecs=' + codec);
        };
        var checkSupportedVideo = function checkSupportedVideo(codec) {
          return MediaSource.isTypeSupported('video/mp4;codecs=' + codec);
        };
        var audioCodec = level.audioCodec,
            videoCodec = level.videoCodec;

        return (!audioCodec || checkSupportedAudio(audioCodec)) && (!videoCodec || checkSupportedVideo(videoCodec));
      });

      if (levels.length) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }
        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: this._levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound });
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
      }
      return;
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this._level = newLevel;
        _logger.logger.log('switching to level ' + newLevel);
        this.hls.trigger(_events2.default.LEVEL_SWITCH, { level: newLevel });
        var level = levels[newLevel],
            levelDetails = level.details;
        // check if we need to load playlist for this level. don't reload live playlist more than once per second
        if (!levelDetails || levelDetails.live === true && performance.now() - levelDetails.tload > 1000) {
          // level not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for level ' + newLevel);
          var urlId = level.urlId;
          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        return;
      }

      var details = data.details,
          hls = this.hls,
          levelId = void 0,
          level = void 0,
          levelError = false;
      // try to recover not fatal errors
      switch (details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelId = data.frag.level;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelId = data.context.level;
          levelError = true;
          break;
        default:
          break;
      }
      /* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       * don't raise FRAG_LOAD_ERROR and FRAG_LOAD_TIMEOUT as fatal, as it is handled by mediaController
       */
      if (levelId !== undefined) {
        level = this._levels[levelId];
        if (level.urlId < level.url.length - 1) {
          level.urlId++;
          level.details = undefined;
          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
        } else {
          // we could try to recover if in auto mode and current level not lowest level (0)
          var recoverable = this._manualLevel === -1 && levelId;
          if (recoverable) {
            _logger.logger.warn('level controller,' + details + ': emergency switch-down for next fragment');
            hls.abrController.nextAutoLevel = 0;
          } else if (level && level.details && level.details.live) {
            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
            if (levelError) {
              // reset this._level so that another call to set level() will retrigger a frag load
              this._level = undefined;
            }
            // FRAG_LOAD_ERROR and FRAG_LOAD_TIMEOUT are handled by mediaController
          } else if (details !== _errors.ErrorDetails.FRAG_LOAD_ERROR && details !== _errors.ErrorDetails.FRAG_LOAD_TIMEOUT) {
            _logger.logger.error('cannot recover ' + details + ' error');
            this._level = undefined;
            // stopping live reloading timer if any
            if (this.timer) {
              clearTimeout(this.timer);
              this.timer = null;
            }
            // redispatch same error but with fatal set to true
            data.fatal = true;
            hls.trigger(_events2.default.ERROR, data);
          }
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      // only process level loaded events matching with expected level
      if (data.level === this._level) {
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
              curLevel = this._levels[data.level],
              curDetails = curLevel.details;
          if (curDetails && newDetails.endSN === curDetails.endSN) {
            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
            // changed then it MUST wait for a period of one-half the target
            // duration before retrying.
            reloadInterval /= 2;
            _logger.logger.log('same live playlist, reload twice faster');
          }
          // decrement reloadInterval with level loading delay
          reloadInterval -= performance.now() - data.stats.trequest;
          // in any case, don't reload more than every second
          reloadInterval = Math.max(1000, Math.round(reloadInterval));
          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
          this.timer = setTimeout(this.ontick, reloadInterval);
        } else {
          this.timer = null;
        }
      }
    }
  }, {
    key: 'tick',
    value: function tick() {
      var levelId = this._level;
      if (levelId !== undefined && this.canload) {
        var level = this._levels[levelId],
            urlId = level.urlId;
        this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels && levels.length > newLevel) {
        if (this._level !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this._manualLevel;
    },
    set: function set(newLevel) {
      this._manualLevel = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      if (this._startLevel === undefined) {
        return this._firstLevel;
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this._manualLevel !== -1) {
        return this._manualLevel;
      } else {
        return this.hls.abrController.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this._manualLevel === -1) {
        this.hls.abrController.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var StreamController = function (_EventHandler) {
  _inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(StreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var media = this.media,
            lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.demuxer = new _demuxer2.default(this.hls, 'main');
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.level = -1;
        this.fragLoadError = 0;
        if (media && lastCurrentTime > 0) {
          _logger.logger.log('configure startPosition @' + lastCurrentTime);
          if (!this.lastPaused) {
            _logger.logger.log('resuming video');
            media.play();
          }
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        _logger.logger.warn('cannot start loading as manifest not parsed yet');
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case State.STARTING:
          var hls = this.hls;
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.fragBitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.state = State.WAITING_LEVEL;
          this.loadedmetadata = false;
          break;
        case State.IDLE:
          // when this returns false there was an error and we shall return immediatly
          // from current tick
          if (!this._doTickIdle()) {
            return;
          }
          break;
        case State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.ERROR:
        case State.PAUSED:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if video not attached AND
      // start fragment already requested OR start frag prefetch disable
      // exit loop
      // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
        return true;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }
      // determine next load level
      var level = hls.nextLoadLevel;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      var maxBufLen = void 0;
      if (this.levels[level].hasOwnProperty('bitrate')) {
        maxBufLen = Math.max(8 * config.maxBufferSize / this.levels[level].bitrate, config.maxBufferLength);
        maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return true;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      hls.nextLoadLevel = level;
      this.level = level;

      var levelDetails = this.levels[level].details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = State.WAITING_LEVEL;
        return true;
      }

      // we just got done loading the final fragment, check if we need to finalize media stream
      var fragPrevious = this.fragPrevious;
      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
        // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
        // between different renditions. using half frag duration should help cope with these cases.
        if (!media.seeking || media.duration - bufferInfo.end <= fragPrevious.duration / 2) {
          // Finalize the media stream
          var data = {};
          if (this.audioTrackType === 'AUDIO') {
            data.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_EOS, data);
          this.state = State.ENDED;
          return true;
        }
      }

      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      return this._fetchPayloadOrEos({ pos: pos, bufferInfo: bufferInfo, levelDetails: levelDetails });
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(_ref) {
      var pos = _ref.pos;
      var bufferInfo = _ref.bufferInfo;
      var levelDetails = _ref.levelDetails;

      var fragPrevious = this.fragPrevious,
          level = this.level;

      // find fragment index, contiguous with end of buffer position
      var fragments = levelDetails.fragments,
          fragLen = fragments.length,
          start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      // in case of live playlist we need to ensure that requested position is not located before playlist start
      if (levelDetails.live) {
        frag = this._ensureFragmentAtLivePoint({ levelDetails: levelDetails, bufferEnd: bufferEnd, start: start, end: end, fragPrevious: fragPrevious, fragments: fragments, fragLen: fragLen });
        // if it explicitely returns null don't load any fragment and exit function now
        if (frag === null) {
          return false;
        }
      } else {
        // VoD playlist: if bufferEnd before start of playlist, load first fragment
        if (bufferEnd < start) {
          frag = fragments[0];
        }
      }
      if (!frag) {
        frag = this._findFragment({ start: start, fragPrevious: fragPrevious, fragLen: fragLen, fragments: fragments, bufferEnd: bufferEnd, end: end, levelDetails: levelDetails });
      }
      if (frag) {
        return this._loadFragmentOrKey({ frag: frag, level: level, levelDetails: levelDetails, pos: pos, bufferEnd: bufferEnd });
      }
      return true;
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(_ref2) {
      var levelDetails = _ref2.levelDetails;
      var bufferEnd = _ref2.bufferEnd;
      var start = _ref2.start;
      var end = _ref2.end;
      var fragPrevious = _ref2.fragPrevious;
      var fragments = _ref2.fragments;
      var fragLen = _ref2.fragLen;

      var config = this.hls.config;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        var media = this.media;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      if (levelDetails.PTSKnown && bufferEnd > end) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          var targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            frag = fragments[targetSN - levelDetails.startSN];
            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }
      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(_ref3) {
      var start = _ref3.start;
      var fragPrevious = _ref3.fragPrevious;
      var fragLen = _ref3.fragLen;
      var fragments = _ref3.fragments;
      var bufferEnd = _ref3.bufferEnd;
      var end = _ref3.end;
      var levelDetails = _ref3.levelDetails;

      var config = this.hls.config;

      var frag = void 0,
          foundFrag = void 0,
          maxFragLookUpTolerance = config.maxFragLookUpTolerance;

      if (bufferEnd < end) {
        if (bufferEnd > end - maxFragLookUpTolerance) {
          maxFragLookUpTolerance = 0;
        }
        foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
          // offset should be within fragment boundary - config.maxFragLookUpTolerance
          // this is to cope with situations like
          // bufferEnd = 9.991
          // frag[Ø] : [0,10]
          // frag[1] : [10,20]
          // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
          //              frag start               frag start+duration
          //                  |-----------------------------|
          //              <--->                         <--->
          //  ...--------><-----------------------------><---------....
          // previous frag         matching fragment         next frag
          //  return -1             return 0                 return 1
          //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
          if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
            return 1;
          } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
          else if (candidate.start - maxFragLookUpTolerance > bufferEnd && candidate.start) {
              return -1;
            }
          return 0;
        });
      } else {
        // reach end of playlist
        foundFrag = fragments[fragLen - 1];
      }
      if (foundFrag) {
        frag = foundFrag;
        start = foundFrag.start;
        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
          if (frag.sn < levelDetails.endSN) {
            var deltaPTS = fragPrevious.deltaPTS,
                curSNIdx = frag.sn - levelDetails.startSN;
            // if there is a significant delta between audio and video, larger than max allowed hole,
            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
            // let's try to load previous fragment again to get last keyframe
            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
              frag = fragments[curSNIdx - 1];
              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
              fragPrevious.loadCounter--;
            } else {
              frag = fragments[curSNIdx + 1];
              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
            }
          } else {
            frag = null;
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadFragmentOrKey',
    value: function _loadFragmentOrKey(_ref4) {
      var frag = _ref4.frag;
      var level = _ref4.level;
      var levelDetails = _ref4.levelDetails;
      var pos = _ref4.pos;
      var bufferEnd = _ref4.bufferEnd;

      var hls = this.hls,
          config = hls.config;

      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
      if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
        this.state = State.KEY_LOADING;
        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
      } else {
        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
        // ensure that we are not reloading the same fragments in loop ...
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx++;
        } else {
          this.fragLoadIdx = 0;
        }
        if (frag.loadCounter) {
          frag.loadCounter++;
          var maxThreshold = config.fragLoadingLoopThreshold;
          // if this frag has already been loaded 3 times, and if it has been reloaded recently
          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
            return false;
          }
        } else {
          frag.loadCounter = 1;
        }
        frag.loadIdx = this.fragLoadIdx;
        frag.autoLevel = hls.autoLevelEnabled;
        this.fragCurrent = frag;
        this.startFragRequested = true;
        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        this.state = State.FRAG_LOADING;
        return true;
      }
    }
  }, {
    key: 'getBufferRange',
    value: function getBufferRange(position) {
      var i,
          range,
          bufferRange = this.bufferRange;
      if (bufferRange) {
        for (i = bufferRange.length - 1; i >= 0; i--) {
          range = bufferRange[i];
          if (position >= range.start && position <= range.end) {
            return range;
          }
        }
      }
      return null;
    }
  }, {
    key: 'followingBufferRange',
    value: function followingBufferRange(range) {
      if (range) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferRange(range.end + 0.5);
      }
      return null;
    }
  }, {
    key: 'isBuffered',
    value: function isBuffered(position) {
      var media = this.media;
      if (media) {
        var buffered = media.buffered;
        for (var i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var rangeCurrent,
          currentTime,
          video = this.media;
      if (video && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > video.playbackRate * this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }
        if (this.isBuffered(currentTime)) {
          rangeCurrent = this.getBufferRange(currentTime);
        } else if (this.isBuffered(currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          rangeCurrent = this.getBufferRange(currentTime + 0.1);
        }
        if (rangeCurrent) {
          var fragPlaying = rangeCurrent.frag;
          if (fragPlaying !== this.fragPlaying) {
            this.fragPlaying = fragPlaying;
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }
      this.fragCurrent = null;
      this.state = State.PAUSED;
      // flush everything
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY });
    }

    /*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (this.isBuffered(media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }
  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      /* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            currentRange = void 0,
            nextRange = void 0;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        currentRange = this.getBufferRange(media.currentTime);
        if (currentRange && currentRange.start > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.state = State.PAUSED;
          this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: currentRange.start - 1 });
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        //logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextRange = this.getBufferRange(media.currentTime + fetchdelay);
        if (nextRange) {
          // we can flush buffer range following this one without stalling playback
          nextRange = this.followingBufferRange(nextRange);
          if (nextRange) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            // flush position is the start position of this new buffer
            this.state = State.PAUSED;
            this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: nextRange.start, endOffset: Number.POSITIVE_INFINITY });
          }
        }
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var levels = this.levels;
      if (levels) {
        // reset fragment load counter
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      _logger.logger.log('media seeking to ' + currentTime);
      if (this.state === State.FRAG_LOADING) {
        var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, this.config.maxBufferHole),
            fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = this.config.maxFragLookUpTolerance,
              fragStartOffset = fragCurrent.start - tolerance,
              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      _logger.logger.log('media seeked to ' + this.media.currentTime);
      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      _logger.logger.log('media ended');
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.bufferRange = [];
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }
          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startLevelLoaded = false;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details,
          newLevelId = data.level,
          curLevel = this.levels[newLevelId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
      this.levelLastLoaded = newLevelId;

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'main' && data.frag.level === fragCurrent.level && data.frag.sn === fragCurrent.sn) {
        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of level ' + fragCurrent.level);
        if (this.fragBitrateTest === true) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = State.IDLE;
          this.fragBitrateTest = false;
          this.startFragRequested = false;
          data.stats.tparsed = data.stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: data.stats, frag: fragCurrent, id: 'main' });
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.stats = data.stats;
          var currentLevel = this.levels[this.level],
              details = currentLevel.details,
              duration = details.totalduration,
              start = fragCurrent.startDTS !== undefined ? fragCurrent.startDTS : fragCurrent.start,
              level = fragCurrent.level,
              sn = fragCurrent.sn,
              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec === undefined) {
              audioCodec = this.lastAudioCodec;
            }
            if (audioCodec) {
              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                audioCodec = 'mp4a.40.2';
              } else {
                audioCodec = 'mp4a.40.5';
              }
            }
          }
          this.pendingAppending = 0;
          _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
          var demuxer = this.demuxer;
          if (!demuxer) {
            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
          }
          demuxer.push(data.payload, audioCodec, currentLevel.videoCodec, start, fragCurrent.cc, level, sn, duration, fragCurrent.decryptdata);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            trackName,
            track;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.audioTrackType === 'AUDIO') {
          delete tracks.audio;
        }
        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1) {
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }

        // if remuxer specify that a unique track needs to generated,
        // let's merge all tracks together
        if (data.unique) {
          var mergedTrack = {
            codec: '',
            levelCodec: ''
          };
          for (trackName in data.tracks) {
            track = tracks[trackName];
            mergedTrack.container = track.container;
            if (mergedTrack.codec) {
              mergedTrack.codec += ',';
              mergedTrack.levelCodec += ',';
            }
            if (track.codec) {
              mergedTrack.codec += track.codec;
            }
            if (track.levelCodec) {
              mergedTrack.levelCodec += track.levelCodec;
            }
          }
          tracks = { audiovideo: mergedTrack };
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.pendingAppending++;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && (data.type !== 'audio' || this.audioTrackType !== 'AUDIO') && // filter out main audio if audio track is loaded through audio stream controller
      this.state === State.PARSING) {
        var level = this.levels[this.level],
            frag = this.fragCurrent;

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift });

        // has remuxer dropped video frames located before first keyframe ?
        if (data.type === 'video') {
          frag.dropped = data.dropped;
        }

        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer) {
            _this2.pendingAppending++;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });

        this.nextLoadPosition = data.endPTS;
        this.bufferRange.push({ type: data.type, start: data.startPTS, end: data.endPTS, frag: frag });

        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitch',
    value: function onAudioTrackSwitch(data) {
      var audioTrackType = data.type;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      if (audioTrackType === 'main') {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        }
      } else {
        // if we switch on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (this.videoBuffer && this.mediaBuffer !== this.videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = this.videoBuffer;
        }
      }
      this.audioTrackType = audioTrackType;
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        switch (this.state) {
          case State.PARSING:
          case State.PARSED:
            this.pendingAppending--;
            this._checkAppendedParsed();
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && this.pendingAppending === 0) {
        var frag = this.fragCurrent,
            stats = this.stats;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            if (loadError <= this.config.fragLoadingMaxRetry ||
            // keep retrying / don't raise fatal network error if current position is buffered
            this.media && this.isBuffered(this.media.currentTime)) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to 64s
              var delay = Math.min(Math.pow(2, loadError - 1) * this.config.fragLoadingRetryDelay, 64000);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('mediaController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // only reduce max buf len if in appending state
          if (this.state === State.PARSING || this.state === State.PARSED) {
            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
            this.config.maxMaxBufferLength /= 2;
            _logger.logger.warn('reduce max buffer length to ' + this.config.maxMaxBufferLength + 's and switch to IDLE state');
            // increase fragment load Index to avoid frag loop loading error after buffer flush
            this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
            this.state = State.IDLE;
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;
      var vendor = navigator.vendor,
          userAgent = navigator.userAgent;
      var isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
      if (media && media.readyState) {
        var currentTime = media.currentTime,
            buffered = media.buffered;
        // adjust currentTime to start position on loaded metadata
        if (!this.loadedmetadata && buffered.length) {
          this.loadedmetadata = true;
          // only adjust currentTime if different from startPosition or if startPosition not buffered
          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
          var startPosition = this.startPosition,
              startPositionBuffered = this.isBuffered(startPosition);
          // if currentTime not matching with expected startPosition or startPosition not buffered
          if (currentTime !== startPosition || !startPositionBuffered) {
            _logger.logger.log('target start position:' + startPosition);
            // if startPosition not buffered, let's seek to buffered.start(0)
            if (!startPositionBuffered) {
              startPosition = buffered.start(0);
              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
            }
            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
            // readyState <= 2 can not successfully seek in safari
            if (!isSafari || media.readyState > 2) {
              media.currentTime = startPosition;
            }
          }
        } else if (this.immediateSwitch) {
          this.immediateLevelSwitchEnd();
        } else {
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
              expectedPlaying = !(media.paused || // not playing when media is paused
          media.ended || // not playing when media is ended
          media.buffered.length === 0),
              // not playing if nothing buffered
          jumpThreshold = 0.4,
              // tolerance needed as some browsers stalls playback before reaching buffered range end
          playheadMoving = currentTime > media.playbackRate * this.lastCurrentTime;

          if (this.stalled && playheadMoving) {
            this.stalled = false;
            _logger.logger.log('playback not stuck anymore @' + currentTime);
          }
          // check buffer upfront
          // if less than jumpThreshold second is buffered, let's check in more details
          if (expectedPlaying && bufferInfo.len <= jumpThreshold) {
            if (playheadMoving) {
              // playhead moving
              jumpThreshold = 0;
              this.seekHoleNudgeDuration = 0;
            } else {
              // playhead not moving AND media expected to play
              if (!this.stalled) {
                this.seekHoleNudgeDuration = 0;
                _logger.logger.log('playback seems stuck @' + currentTime);
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false });
                this.stalled = true;
              } else {
                this.seekHoleNudgeDuration += this.config.seekHoleNudgeDuration;
              }
            }
            // if we are below threshold, try to jump to start of next buffer range if close
            if (bufferInfo.len <= jumpThreshold) {
              // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
              var nextBufferStart = bufferInfo.nextStart,
                  delta = nextBufferStart - currentTime;
              if (nextBufferStart && delta < this.config.maxSeekHole && delta > 0) {
                // next buffer is close ! adjust currentTime to nextBufferStart
                // this will ensure effective video decoding
                _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + this.seekHoleNudgeDuration);
                var hole = nextBufferStart + this.seekHoleNudgeDuration - media.currentTime;
                // frequently seeking may cause frequently flicker in safari
                if (!isSafari || this.seekHoleNudgeDuration && this.seekHoleNudgeDuration % (10 * this.config.seekHoleNudgeDuration) < this.config.seekHoleNudgeDuration) {
                  media.currentTime = nextBufferStart + this.seekHoleNudgeDuration;
                }
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: hole });
              }
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, rebuild buffer Range array
        loop through existing buffer range and check if
        corresponding range is still buffered. only push to new array already buffered range
      */
      var newRange = [],
          range,
          i;
      for (i = 0; i < this.bufferRange.length; i++) {
        range = this.bufferRange[i];
        if (this.isBuffered((range.start + range.end) / 2)) {
          newRange.push(range);
        }
      }
      this.bufferRange = newRange;

      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('engine state transition from ' + previousState + ' to ' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      if (this.media) {
        var range = this.getBufferRange(this.media.currentTime);
        if (range) {
          return range.frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferRange',
    get: function get() {
      if (this.media) {
        // first get end range of current fragment
        return this.followingBufferRange(this.getBufferRange(this.media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var range = this.nextBufferRange;
      if (range) {
        return range.frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_eventHandler2.default);

exports.default = StreamController;

},{"../demux/demuxer":20,"../errors":27,"../event-handler":28,"../events":29,"../helper/buffer-helper":31,"../helper/level-helper":32,"../utils/binary-search":42,"../utils/logger":46,"../utils/timeRanges":48}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = require('../utils/cea-608-parser');

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCH));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;

    if (_this.config.enableCEA708Captions) {
      var self = _this;

      var channel1 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack1) {
            self.textTrack1 = self.createTextTrack('captions', 'Unknown CC1', 'en');
            //            self.textTrack1.mode = 'showing';
          }

          self.Cues.newCue(self.textTrack1, startTime, endTime, screen);
        }
      };

      var channel2 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack2) {
            self.textTrack2 = self.createTextTrack('captions', 'Unknown CC2', 'es');
          }

          self.Cues.newCue(self.textTrack2, startTime, endTime, screen);
        }
      };

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'clearCurrentCues',
    value: function clearCurrentCues(track) {
      if (track && track.cues) {
        while (track.cues.length > 0) {
          track.removeCue(track.cues[0]);
        }
      }
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      if (this.media) {
        return this.media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {}
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastPts = Number.NEGATIVE_INFINITY;
    }
  }, {
    key: 'onLevelSwitch',
    value: function onLevelSwitch() {
      if (this.hls.currentLevel.closedCaptions === 'NONE') {
        this.enabled = false;
      } else {
        this.enabled = true;
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      if (data.frag.type === 'main') {
        var pts = data.frag.start; //Number.POSITIVE_INFINITY;
        // if this is a frag for a previously loaded timerange, remove all captions
        // TODO: consider just removing captions for the timerange
        if (pts <= this.lastPts) {
          this.clearCurrentCues(this.textTrack1);
          this.clearCurrentCues(this.textTrack2);
        }
        this.lastPts = pts;
      }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) === 0 ? false : true;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) // || ccType === 1
            {
              actualCCBytes.push(ccbyte1);
              actualCCBytes.push(ccbyte2);
            }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

},{"../event-handler":28,"../events":29,"../utils/cea-608-parser":43}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 *
 * This file contains an adaptation of the AES decryption algorithm
 * from the Standford Javascript Cryptography Library. That work is
 * covered by the following copyright and permissions notice:
 *
 * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the authors.
 */
var AES = function () {

  /**
   * Schedule out an AES key for both encryption and decryption. This
   * is a low-level class. Use a cipher mode to do bulk encryption.
   *
   * @constructor
   * @param key {Array} The key as an array of 4, 6 or 8 words.
   */
  function AES(key) {
    _classCallCheck(this, AES);

    /**
     * The expanded S-box and inverse S-box tables. These will be computed
     * on the client so that we don't have to send them down the wire.
     *
     * There are two tables, _tables[0] is for encryption and
     * _tables[1] is for decryption.
     *
     * The first 4 sub-tables are the expanded S-box with MixColumns. The
     * last (_tables[01][4]) is the S-box itself.
     *
     * @private
     */
    this._tables = [[[], [], [], [], []], [[], [], [], [], []]];

    this._precompute();

    var i,
        j,
        tmp,
        encKey,
        decKey,
        sbox = this._tables[0][4],
        decTable = this._tables[1],
        keyLen = key.length,
        rcon = 1;

    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
      throw new Error('Invalid aes key size=' + keyLen);
    }

    encKey = key.slice(0);
    decKey = [];
    this._key = [encKey, decKey];

    // schedule encryption keys
    for (i = keyLen; i < 4 * keyLen + 28; i++) {
      tmp = encKey[i - 1];

      // apply sbox
      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];

        // shift rows and add rcon
        if (i % keyLen === 0) {
          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
          rcon = rcon << 1 ^ (rcon >> 7) * 283;
        }
      }

      encKey[i] = encKey[i - keyLen] ^ tmp;
    }

    // schedule decryption keys
    for (j = 0; i; j++, i--) {
      tmp = encKey[j & 3 ? i : i - 4];
      if (i <= 4 || j < 4) {
        decKey[j] = tmp;
      } else {
        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
      }
    }
  }

  /**
   * Expand the S-box tables.
   *
   * @private
   */


  _createClass(AES, [{
    key: '_precompute',
    value: function _precompute() {
      var encTable = this._tables[0],
          decTable = this._tables[1],
          sbox = encTable[4],
          sboxInv = decTable[4],
          i,
          x,
          xInv,
          d = [],
          th = [],
          x2,
          x4,
          x8,
          s,
          tEnc,
          tDec;

      // Compute double and third tables
      for (i = 0; i < 256; i++) {
        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
      }

      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
        // Compute sbox
        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
        s = s >> 8 ^ s & 255 ^ 99;
        sbox[x] = s;
        sboxInv[s] = x;

        // Compute MixColumns
        x8 = d[x4 = d[x2 = d[x]]];
        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        tEnc = d[s] * 0x101 ^ s * 0x1010100;

        for (i = 0; i < 4; i++) {
          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
        }
      }

      // Compactify. Considerable speedup on Firefox.
      for (i = 0; i < 5; i++) {
        encTable[i] = encTable[i].slice(0);
        decTable[i] = decTable[i].slice(0);
      }
    }

    /**
     * Decrypt 16 bytes, specified as four 32-bit words.
     * @param encrypted0 {number} the first word to decrypt
     * @param encrypted1 {number} the second word to decrypt
     * @param encrypted2 {number} the third word to decrypt
     * @param encrypted3 {number} the fourth word to decrypt
     * @param out {Int32Array} the array to write the decrypted words
     * into
     * @param offset {number} the offset into the output array to start
     * writing results
     * @return {Array} The plaintext.
     */

  }, {
    key: 'decrypt',
    value: function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
      var key = this._key[1],

      // state variables a,b,c,d are loaded with pre-whitened data
      a = encrypted0 ^ key[0],
          b = encrypted3 ^ key[1],
          c = encrypted2 ^ key[2],
          d = encrypted1 ^ key[3],
          a2,
          b2,
          c2,
          nInnerRounds = key.length / 4 - 2,
          // key.length === 2 ?
      i,
          kIndex = 4,
          table = this._tables[1],


      // load up the tables
      table0 = table[0],
          table1 = table[1],
          table2 = table[2],
          table3 = table[3],
          sbox = table[4];

      // Inner rounds. Cribbed from OpenSSL.
      for (i = 0; i < nInnerRounds; i++) {
        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
        kIndex += 4;
        a = a2;b = b2;c = c2;
      }

      // Last round.
      for (i = 0; i < 4; i++) {
        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
        a2 = a;a = b;b = c;c = d;d = a2;
      }
    }
  }]);

  return AES;
}();

exports.default = AES;

},{}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This file contains an adaptation of the AES decryption algorithm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * from the Standford Javascript Cryptography Library. That work is
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * covered by the following copyright and permissions notice:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * modification, are permitted provided that the following conditions are
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 1. Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 2. Redistributions in binary form must reproduce the above
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    copyright notice, this list of conditions and the following
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    disclaimer in the documentation and/or other materials provided
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The views and conclusions contained in the software and documentation
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * are those of the authors and should not be interpreted as representing
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * official policies, either expressed or implied, of the authors.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _aes = require('./aes');

var _aes2 = _interopRequireDefault(_aes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AES128Decrypter = function () {
  function AES128Decrypter(key, initVector) {
    _classCallCheck(this, AES128Decrypter);

    this.key = key;
    this.iv = initVector;
  }

  /**
   * Convert network-order (big-endian) bytes into their little-endian
   * representation.
   */


  _createClass(AES128Decrypter, [{
    key: 'ntoh',
    value: function ntoh(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }

    /**
     * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.
     * @param encrypted {Uint8Array} the encrypted bytes
     * @param key {Uint32Array} the bytes of the decryption key
     * @param initVector {Uint32Array} the initialization vector (IV) to
     * use for the first round of CBC.
     * @return {Uint8Array} the decrypted bytes
     *
     * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard
     * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29
     * @see https://tools.ietf.org/html/rfc2315
     */

  }, {
    key: 'doDecrypt',
    value: function doDecrypt(encrypted, key, initVector) {
      var
      // word-level access to the encrypted bytes
      encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2),
          decipher = new _aes2.default(Array.prototype.slice.call(key)),


      // byte and word-level access for the decrypted output
      decrypted = new Uint8Array(encrypted.byteLength),
          decrypted32 = new Int32Array(decrypted.buffer),


      // temporary variables for working with the IV, encrypted, and
      // decrypted data
      init0,
          init1,
          init2,
          init3,
          encrypted0,
          encrypted1,
          encrypted2,
          encrypted3,


      // iteration variable
      wordIx;

      // pull out the words of the IV to ensure we don't modify the
      // passed-in reference and easier access
      init0 = ~~initVector[0];
      init1 = ~~initVector[1];
      init2 = ~~initVector[2];
      init3 = ~~initVector[3];

      // decrypt four word sequences, applying cipher-block chaining (CBC)
      // to each decrypted block
      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
        // convert big-endian (network order) words into little-endian
        // (javascript order)
        encrypted0 = ~~this.ntoh(encrypted32[wordIx]);
        encrypted1 = ~~this.ntoh(encrypted32[wordIx + 1]);
        encrypted2 = ~~this.ntoh(encrypted32[wordIx + 2]);
        encrypted3 = ~~this.ntoh(encrypted32[wordIx + 3]);

        // decrypt the block
        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);

        // XOR with the IV, and restore network byte-order to obtain the
        // plaintext
        decrypted32[wordIx] = this.ntoh(decrypted32[wordIx] ^ init0);
        decrypted32[wordIx + 1] = this.ntoh(decrypted32[wordIx + 1] ^ init1);
        decrypted32[wordIx + 2] = this.ntoh(decrypted32[wordIx + 2] ^ init2);
        decrypted32[wordIx + 3] = this.ntoh(decrypted32[wordIx + 3] ^ init3);

        // setup the IV for the next round
        init0 = encrypted0;
        init1 = encrypted1;
        init2 = encrypted2;
        init3 = encrypted3;
      }

      return decrypted;
    }
  }, {
    key: 'localDecrypt',
    value: function localDecrypt(encrypted, key, initVector, decrypted) {
      var bytes = this.doDecrypt(encrypted, key, initVector);
      decrypted.set(bytes, encrypted.byteOffset);
    }
  }, {
    key: 'decrypt',
    value: function decrypt(encrypted) {
      var step = 4 * 8000,

      //encrypted32 = new Int32Array(encrypted.buffer),
      encrypted32 = new Int32Array(encrypted),
          decrypted = new Uint8Array(encrypted.byteLength),
          i = 0;

      // split up the encryption job and do the individual chunks asynchronously
      var key = this.key;
      var initVector = this.iv;
      this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);

      for (i = step; i < encrypted32.length; i += step) {
        initVector = new Uint32Array([this.ntoh(encrypted32[i - 4]), this.ntoh(encrypted32[i - 3]), this.ntoh(encrypted32[i - 2]), this.ntoh(encrypted32[i - 1])]);
        this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);
      }

      return decrypted;
    }
  }]);

  return AES128Decrypter;
}();

exports.default = AES128Decrypter;

},{"./aes":13}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AES128 decryption.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _aes128Decrypter = require('./aes128-decrypter');

var _aes128Decrypter2 = _interopRequireDefault(_aes128Decrypter);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Decrypter = function () {
  function Decrypter(hls) {
    _classCallCheck(this, Decrypter);

    this.hls = hls;
    try {
      var browserCrypto = window ? window.crypto : crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
      this.disableWebCrypto = !this.subtle;
    } catch (e) {
      this.disableWebCrypto = true;
    }
  }

  _createClass(Decrypter, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      if (this.disableWebCrypto && this.hls.config.enableSoftwareAES) {
        this.decryptBySoftware(data, key, iv, callback);
      } else {
        this.decryptByWebCrypto(data, key, iv, callback);
      }
    }
  }, {
    key: 'decryptByWebCrypto',
    value: function decryptByWebCrypto(data, key, iv, callback) {
      var _this = this;

      _logger.logger.log('decrypting by WebCrypto API');

      this.subtle.importKey('raw', key, { name: 'AES-CBC', length: 128 }, false, ['decrypt']).then(function (importedKey) {
        _this.subtle.decrypt({ name: 'AES-CBC', iv: iv.buffer }, importedKey, data).then(callback).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }).catch(function (err) {
        _this.onWebCryptoError(err, data, key, iv, callback);
      });
    }
  }, {
    key: 'decryptBySoftware',
    value: function decryptBySoftware(data, key8, iv8, callback) {
      _logger.logger.log('decrypting by JavaScript Implementation');

      var view = new DataView(key8.buffer);
      var key = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);

      view = new DataView(iv8.buffer);
      var iv = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);

      var decrypter = new _aes128Decrypter2.default(key, iv);
      callback(decrypter.decrypt(data).buffer);
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.hls.config.enableSoftwareAES) {
        _logger.logger.log('disabling to use WebCrypto API');
        this.disableWebCrypto = true;
        this.decryptBySoftware(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.hls.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;

},{"../errors":27,"../utils/logger":46,"./aes128-decrypter":14}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _logger = require('../utils/logger');

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, id, remuxerClass, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.remuxer = new this.remuxerClass(observer, id, config);
    this.insertDiscontinuity();
  }

  _createClass(AACDemuxer, [{
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
    }
  }, {
    key: 'push',


    // feed incoming data to the front of the parsing pipeline
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var track,
          id3 = new _id2.default(data),
          pts = 90 * id3.timeStamp,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;

      var contiguous = false;
      if (cc !== this.lastCC) {
        _logger.logger.log(this.id + ' discontinuity detected');
        this.lastCC = cc;
        this.insertDiscontinuity();
        this.remuxer.switchLevel();
        this.remuxer.insertDiscontinuity();
      } else if (level !== this.lastLevel) {
        _logger.logger.log('audio track switch detected');
        this.lastLevel = level;
        this.remuxer.switchLevel();
        this.insertDiscontinuity();
      } else if (sn === this.lastSN + 1) {
        contiguous = true;
      }
      track = this._aacTrack;
      this.lastSN = sn;
      this.lastLevel = level;

      // look for ADTS header (0xFFFx)
      for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }

      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;
      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      this.remuxer.remux(level, sn, this._aacTrack, { samples: [] }, { samples: [{ pts: pts, dts: pts, unit: id3.payload }] }, { samples: [] }, timeOffset, contiguous);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and ADTS sync worc
      var id3 = new _id2.default(data),
          offset,
          len;
      if (id3.hasTimeStamp) {
        // look for ADTS header (0xFFFx)
        for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
          if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
            //logger.log('ADTS sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;

},{"../demux/id3":25,"../utils/logger":46,"./adts":17}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  ADTS parser helper
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

var _errors = require('../errors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ADTS = function () {
  function ADTS() {
    _classCallCheck(this, ADTS);
  }

  _createClass(ADTS, null, [{
    key: 'getAudioConfig',
    value: function getAudioConfig(observer, data, offset, audioCodec) {
      var adtsObjectType,
          // :int
      adtsSampleingIndex,
          // :int
      adtsExtensionSampleingIndex,
          // :int
      adtsChanelConfig,
          // :int
      config,
          userAgent = navigator.userAgent.toLowerCase(),
          adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
      // byte 2
      adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
      adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
      if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
        observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
        return;
      }
      adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
      // byte 3
      adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
      _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
      // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
      if (userAgent.indexOf('firefox') !== -1) {
        if (adtsSampleingIndex >= 6) {
          adtsObjectType = 5;
          config = new Array(4);
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          adtsObjectType = 2;
          config = new Array(2);
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
        // Android : always use AAC
      } else if (userAgent.indexOf('android') !== -1) {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      } else {
        /*  for other browsers (chrome ...)
            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
        */
        adtsObjectType = 5;
        config = new Array(4);
        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
            adtsObjectType = 2;
            config = new Array(2);
          }
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
      }
      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
          ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
        Audio Profile / Audio Object Type
        0: Null
        1: AAC Main
        2: AAC LC (Low Complexity)
        3: AAC SSR (Scalable Sample Rate)
        4: AAC LTP (Long Term Prediction)
        5: SBR (Spectral Band Replication)
        6: AAC Scalable
       sampling freq
        0: 96000 Hz
        1: 88200 Hz
        2: 64000 Hz
        3: 48000 Hz
        4: 44100 Hz
        5: 32000 Hz
        6: 24000 Hz
        7: 22050 Hz
        8: 16000 Hz
        9: 12000 Hz
        10: 11025 Hz
        11: 8000 Hz
        12: 7350 Hz
        13: Reserved
        14: Reserved
        15: frequency is written explictly
        Channel Configurations
        These are the channel configurations:
        0: Defined in AOT Specifc Config
        1: 1 channel: front-center
        2: 2 channels: front-left, front-right
      */
      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
      config[0] = adtsObjectType << 3;
      // samplingFrequencyIndex
      config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
      config[1] |= (adtsSampleingIndex & 0x01) << 7;
      // channelConfiguration
      config[1] |= adtsChanelConfig << 3;
      if (adtsObjectType === 5) {
        // adtsExtensionSampleingIndex
        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
        config[2] |= 2 << 2;
        config[3] = 0;
      }
      return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType };
    }
  }]);

  return ADTS;
}();

exports.default = ADTS;

},{"../errors":27,"../utils/logger":46}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('../errors');

var _aacdemuxer = require('../demux/aacdemuxer');

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _tsdemuxer = require('../demux/tsdemuxer');

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _flvdemuxer = require('../demux/flvdemuxer');

var _flvdemuxer2 = _interopRequireDefault(_flvdemuxer);

var _mp4Remuxer = require('../remux/mp4-remuxer');

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = require('../remux/passthrough-remuxer');

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DemuxerInline = function () {
  function DemuxerInline(hls, id, typeSupported) {
    var config = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

    _classCallCheck(this, DemuxerInline);

    this.hls = hls;
    this.id = id;
    this.config = this.hls.config || config;
    this.typeSupported = typeSupported;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var demuxer = this.demuxer;
      if (!demuxer) {
        var hls = this.hls,
            id = this.id;
        // probe for content type
        if (_flvdemuxer2.default.probe(data)) {
          demuxer = new _flvdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
        } else if (_tsdemuxer2.default.probe(data)) {
          if (this.typeSupported.mp2t === true) {
            demuxer = new _tsdemuxer2.default(hls, id, _passthroughRemuxer2.default, this.config);
          } else {
            demuxer = new _tsdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
          }
        } else if (_aacdemuxer2.default.probe(data)) {
          demuxer = new _aacdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
        } else {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      demuxer.push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;

},{"../demux/aacdemuxer":16,"../demux/flvdemuxer":24,"../demux/tsdemuxer":26,"../errors":27,"../events":29,"../remux/mp4-remuxer":39,"../remux/passthrough-remuxer":40}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };
  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        self.demuxer = new _demuxerInline2.default(observer, data.id, data.typeSupported, JSON.parse(data.config));
        break;
      case 'demux':
        self.demuxer.push(new Uint8Array(data.data), data.audioCodec, data.videoCodec, data.timeOffset, data.cc, data.level, data.sn, data.duration);
        break;
      default:
        break;
    }
  });

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  // forward events to main thread
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var data1 = data.data1.buffer,
        data2 = data.data2.buffer;
    // remove data1 and data2 reference from data to avoid copying them ...
    delete data.data1;
    delete data.data2;
    self.postMessage({ event: ev, data: data, data1: data1, data2: data2 }, [data1, data2]);
  });
}; /* demuxer web worker.
    *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
    *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
    */

exports.default = DemuxerWorker;

},{"../demux/demuxer-inline":18,"../events":29,"events":1}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = require('../demux/demuxer-worker');

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = require('../utils/logger');

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mp2t: hls.config.enableMP2TPassThrough && MediaSource.isTypeSupported('video/mp2t')
    };
    if (hls.config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      try {
        var work = require('webworkify');
        var w = this.w = work(_demuxerWorker2.default);
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, id: id, config: JSON.stringify(hls.config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
      }
    } else {
      this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
    }
    this.demuxInitialized = true;
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var decrypter = this.decrypter;
      if (decrypter) {
        decrypter.destroy();
        this.decrypter = null;
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var w = this.w;
      if (w) {
        // post fragment payload as transferable objects (no copy)
        w.postMessage({ cmd: 'demux', data: data, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, cc: cc, level: level, sn: sn, duration: duration }, [data]);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(new Uint8Array(data), audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
        }
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, decryptdata) {
      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        if (this.decrypter == null) {
          this.decrypter = new _decrypter2.default(this.hls);
        }

        var localthis = this;
        this.decrypter.decrypt(data, decryptdata.key, decryptdata.iv, function (decryptedData) {
          localthis.pushDecrypted(decryptedData, audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
        });
      } else {
        this.pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration);
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      //console.log('onWorkerMessage:' + data.event);
      switch (data.event) {
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events2.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          data.data.data2 = new Uint8Array(data.data2);
        /* falls through */
        default:
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;

},{"../crypt/decrypter":15,"../demux/demuxer-inline":18,"../demux/demuxer-worker":19,"../errors":27,"../events":29,"../utils/logger":46,"webworkify":2}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = this.data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var position = this.data.byteLength - this.bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, this.bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(this.data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return 1 === this.readBits(1);
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j,
          deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          sarScale = 1,
          profileIdc,
          profileCompat,
          levelIdc,
          numRefFramesInPicOrderCntCycle,
          picWidthInMbsMinus1,
          picHeightInMapUnitsMinus1,
          frameMbsOnlyFlag,
          scalingListCount,
          i;
      this.readUByte();
      profileIdc = this.readUByte(); // profile_idc
      profileCompat = this.readBits(5); // constraint_set[0-4]_flag, u(5)
      this.skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = this.readUByte(); //level_idc u(8)
      this.skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = this.readUEG();
        if (chromaFormatIdc === 3) {
          this.skipBits(1); // separate_colour_plane_flag
        }
        this.skipUEG(); // bit_depth_luma_minus8
        this.skipUEG(); // bit_depth_chroma_minus8
        this.skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (this.readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (this.readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                this.skipScalingList(16);
              } else {
                this.skipScalingList(64);
              }
            }
          }
        }
      }
      this.skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = this.readUEG();
      if (picOrderCntType === 0) {
        this.readUEG(); //log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        this.skipBits(1); // delta_pic_order_always_zero_flag
        this.skipEG(); // offset_for_non_ref_pic
        this.skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = this.readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          this.skipEG(); // offset_for_ref_frame[ i ]
        }
      }
      this.skipUEG(); // max_num_ref_frames
      this.skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = this.readUEG();
      picHeightInMapUnitsMinus1 = this.readUEG();
      frameMbsOnlyFlag = this.readBits(1);
      if (frameMbsOnlyFlag === 0) {
        this.skipBits(1); // mb_adaptive_frame_field_flag
      }
      this.skipBits(1); // direct_8x8_inference_flag
      if (this.readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = this.readUEG();
        frameCropRightOffset = this.readUEG();
        frameCropTopOffset = this.readUEG();
        frameCropBottomOffset = this.readUEG();
      }
      if (this.readBoolean()) {
        // vui_parameters_present_flag
        if (this.readBoolean()) {
          // aspect_ratio_info_present_flag
          var sarRatio = void 0;
          var aspectRatioIdc = this.readUByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];break;
            case 2:
              sarRatio = [12, 11];break;
            case 3:
              sarRatio = [10, 11];break;
            case 4:
              sarRatio = [16, 11];break;
            case 5:
              sarRatio = [40, 33];break;
            case 6:
              sarRatio = [24, 11];break;
            case 7:
              sarRatio = [20, 11];break;
            case 8:
              sarRatio = [32, 11];break;
            case 9:
              sarRatio = [80, 33];break;
            case 10:
              sarRatio = [18, 11];break;
            case 11:
              sarRatio = [15, 11];break;
            case 12:
              sarRatio = [64, 33];break;
            case 13:
              sarRatio = [160, 99];break;
            case 14:
              sarRatio = [4, 3];break;
            case 15:
              sarRatio = [3, 2];break;
            case 16:
              sarRatio = [2, 1];break;
            case 255:
              {
                sarRatio = [this.readUByte() << 8 | this.readUByte(), this.readUByte() << 8 | this.readUByte()];
                break;
              }
          }
          if (sarRatio) {
            sarScale = sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        width: Math.ceil(((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;

},{"../utils/logger":46}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @file:   flv-parser.js
 * @author: tanshaohui
 * @email:  tanshaohui@baidu.com
 * @date:   2016-09-07 15:06:41
 * @last modified by:   tanshaohui
 * @last modified time: 2016-09-07 16:03:45
 */

var FLVParser = function () {
    function FLVParser(data) {
        _classCallCheck(this, FLVParser);

        this.hasAudioTags = true;
        this.hasVideoTags = true;
        this.bodyOffset = 0;
        if (data) {
            this.readFileHeader(data);
        }
    }

    _createClass(FLVParser, [{
        key: 'readFileHeader',
        value: function readFileHeader(data) {
            if (data.length < FLVParser.MIN_FILE_HEADER_BYTE_COUNT) {
                throw new Error('data too short');
            }

            if (data[0] !== 0x46) {
                throw new Error('FLVHeader Signature[0] not "F"');
            }

            if (data[1] !== 0x4C) {
                throw new Error('FLVHeader Signature[1] not "L"');
            }

            if (data[2] !== 0x56) {
                throw new Error('FLVHeader Signature[2] not "V"');
            }

            if (data[3] !== 0x01) {
                throw new Error('FLVHeader Version not 0x01');
            }

            var flags = data[4];
            this.hasAudioTags = flags & 0x04 ? true : false;
            this.hasVideoTags = flags & 0x01 ? true : false;

            this.bodyOffset = new DataView(data.slice(5).buffer).getUint32(0);
            if (this.bodyOffset < FLVParser.MIN_FILE_HEADER_BYTE_COUNT) {
                throw new Error('FLVHeader bodyOffset smaller than minimum');
            }
        }
    }]);

    return FLVParser;
}();

FLVParser.MIN_FILE_HEADER_BYTE_COUNT = 9;
FLVParser.FILE_HEADER = 'fileHeader';
FLVParser.PREV_TAG = 'prevTag';
FLVParser.HEADER = 'header';
FLVParser.DATA = 'data';

exports.default = FLVParser;

},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @file:   flv-tag.js
 * @author: tanshaohui
 * @email:  tanshaohui@baidu.com
 * @date:   2016-09-07 12:56:09
 * @last modified by:   tanshaohui
 * @last modified time: 2016-09-08 20:18:53
 */

var FLVTag = function () {
    function FLVTag(data) {
        _classCallCheck(this, FLVTag);

        this.type = FLVTag.TAG_TYPE_SCRIPTDATAOBJECT;
        this.tagDataSize = 0;
        if (data) {
            this.readHeader(data);
        }
    }

    _createClass(FLVTag, [{
        key: 'readPrevTagSize',
        value: function readPrevTagSize(data) {
            return new DataView(data.buffer).getUint32(0);
        }
    }, {
        key: 'readHeader',
        value: function readHeader(data) {
            var type = data[0];
            if (type === FLVTag.TAG_TYPE_AUDIO || type === FLVTag.TAG_TYPE_VIDEO || type === FLVTag.TAG_TYPE_SCRIPTDATAOBJECT) {
                this.type = type;
            } else {
                throw new Error('invalid FLVTagType');
            }

            this.tagDataSize = data[1] << 16 | data[2] << 8 | data[3];

            this.timestamp = data[7] << 24 | data[4] << 16 | data[5] << 8 | data[6];
        }
    }, {
        key: 'readData',
        value: function readData(data) {
            switch (this.type) {
                case FLVTag.TAG_TYPE_AUDIO:
                    return this.readAudioData(data);
                case FLVTag.TAG_TYPE_VIDEO:
                    return this.readVideoData(data);
                case FLVTag.TAG_TYPE_SCRIPTDATAOBJECT:
                    break;
                default:
                    throw new Error('invalid FLVTagType');
            }
        }
    }, {
        key: 'readAudioData',
        value: function readAudioData(data) {
            var tag = {
                type: 'audio',
                id: FLVTag.TAG_TYPE_AUDIO,
                timestamp: this.timestamp
            };
            var audioHeader = data[0];
            var soundFormat = audioHeader >> 4 & 0x0f;
            var soundRate = 0;
            switch (audioHeader >> 2 & 0x03) {
                case 0:
                    soundRate = 5512.5;
                    break;
                case 1:
                    soundRate = 11025;
                    break;
                case 2:
                    soundRate = 22050;
                    break;
                case 3:
                    soundRate = 44100;
                    break;
                default:
                    throw new Error('invalid soundRate');
            }
            // AAC
            if (soundFormat === 10) {
                tag.codec = 'aac';
                var packetType = data[1];
                tag.pkt_type = packetType;
                tag.data = data.slice(2);
                return tag;
            }
        }
    }, {
        key: 'readVideoData',
        value: function readVideoData(data) {
            var tag = {
                type: 'video',
                id: FLVTag.TAG_TYPE_VIDEO,
                timestamp: this.timestamp
            };
            var videoHeader = data[0];
            var codecID = videoHeader & 0x0f;
            var frameType = videoHeader >> 4 & 0x0f;
            tag.key = frameType === 1 ? true : false;
            // AVC 
            if (codecID === 7) {
                tag.codec = 'avc';
                var packetType = data[1];
                tag.pkt_type = packetType;
                if (packetType === 1) {
                    var compositionTime = data[2] << 16;
                    compositionTime |= data[3] << 8;
                    compositionTime |= data[4];
                    if (compositionTime & 0x00800000) {
                        compositionTime |= 0xff000000;
                    }
                    tag.cts = compositionTime;
                }
                tag.data = data.slice(5);
                return tag;
            }
        }
    }]);

    return FLVTag;
}();

FLVTag.PREV_TAG_BYTE_COUNT = 4;
FLVTag.TAG_TYPE_AUDIO = 0x08;
FLVTag.TAG_TYPE_VIDEO = 0x09;
FLVTag.TAG_TYPE_SCRIPTDATAOBJECT = 0x12;
FLVTag.TAG_HEADER_BYTE_COUNT = 11;

exports.default = FLVTag;

},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file:   flvdemuxer.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author: tanshaohui
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @email:  tanshaohui@baidu.com
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @date:   2016-09-07 10:23:57
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @last modified by:   tanshaohui
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @last modified time: 2016-09-08 22:43:17
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _flvParser = require('../demux/flv-parser');

var _flvParser2 = _interopRequireDefault(_flvParser);

var _flvTag = require('../demux/flv-tag');

var _flvTag2 = _interopRequireDefault(_flvTag);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FLVDemuxer = function () {
    function FLVDemuxer(observer, id, remuxerClass, config) {
        _classCallCheck(this, FLVDemuxer);

        this.observer = observer;
        this.id = id;
        this.remuxerClass = remuxerClass;
        this.config = config;
        this.lastCC = 0;
        this.flvParser = new _flvParser2.default();
        this.remuxer = new this.remuxerClass(observer, id, config);
        this._flvParserState = _flvParser2.default.FILE_HEADER;
    }

    _createClass(FLVDemuxer, [{
        key: 'switchLevel',
        value: function switchLevel() {
            this._avcTrack = { container: 'video/x-flv', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, nbNalu: 0, dropped: 0 };
            this._aacTrack = { container: 'video/x-flv', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
            this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };
            this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };
            this.aacLastPTS = null;
            this.aacDelta = 0;
            this.avcLastPTS = null;
            this.avcDelta = 0;
            this.remuxer.switchLevel();
        }
    }, {
        key: 'insertDiscontinuity',
        value: function insertDiscontinuity() {
            this.switchLevel();
            this.remuxer.insertDiscontinuity();
        }

        // feed incoming data to the front of the parsing pipeline

    }, {
        key: 'push',
        value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
            var start,
                len = data.length;
            var cTag = null;

            this.audioCodec = audioCodec;
            this.videoCodec = videoCodec;
            this.timeOffset = timeOffset;
            this.contiguous = false;
            this.aacDelta = 0;
            this.avcDelta = 0;
            this._duration = duration;
            this._flvParserState = _flvParser2.default.FILE_HEADER;

            if (cc !== this.lastCC) {
                _logger.logger.log('discontinuity detected');
                this.insertDiscontinuity();
                this.lastCC = cc;
            }
            if (level !== this.lastLevel) {
                _logger.logger.log('level switch detected');
                this.switchLevel();
                this.lastLevel = level;
            } else if (sn === this.lastSN + 1) {
                this.contiguous = true;
            }
            this.lastSN = sn;

            for (start = 0; start < len;) {
                switch (this._flvParserState) {
                    case _flvParser2.default.FILE_HEADER:
                        this.flvParser.readFileHeader(data.slice(start, start + _flvParser2.default.MIN_FILE_HEADER_BYTE_COUNT));
                        this._flvParserState = _flvParser2.default.PREV_TAG;
                        start += this.flvParser.bodyOffset;
                        break;
                    case _flvParser2.default.PREV_TAG:
                        cTag = new _flvTag2.default();
                        this._flvParserState = _flvParser2.default.HEADER;
                        start += _flvTag2.default.PREV_TAG_BYTE_COUNT;
                        break;
                    case _flvParser2.default.HEADER:
                        cTag.readHeader(data.slice(start, start + _flvTag2.default.TAG_HEADER_BYTE_COUNT));
                        this._flvParserState = _flvParser2.default.DATA;
                        start += _flvTag2.default.TAG_HEADER_BYTE_COUNT;
                        break;
                    case _flvParser2.default.DATA:
                        var tag = cTag.readData(data.slice(start, start + cTag.tagDataSize));
                        if (tag && tag.codec) {
                            if (tag.codec === 'aac') {
                                if (tag.pkt_type === 1 && this._aacTrack.audiosamplerate) {
                                    this.parseAACTag(tag);
                                } else if (tag.pkt_type === 0 && !this._aacTrack.audiosamplerate) {
                                    this.parseAudioConfig(this.observer, tag.data, 0, audioCodec);
                                    this._aacTrack.id = tag.id;
                                }
                            } else if (tag.codec === 'avc') {
                                if (tag.pkt_type === 1 && this._avcTrack.lengthSizeMinusOne) {
                                    this.parseAVCTag(tag);
                                } else if (tag.pkt_type === 0 && !this._avcTrack.lengthSizeMinusOne) {
                                    this.parseVideoConfig(this.observer, tag.data, 0, audioCodec);
                                    this._avcTrack.id = tag.id;
                                }
                            }
                        }
                        this._flvParserState = _flvParser2.default.PREV_TAG;
                        start += cTag.tagDataSize;
                        break;
                    default:
                        throw new Error('invalid FLVParserState');
                }
            }

            if (!this.avcFrameDuration) {
                var samples = this._avcTrack.samples;
                if (samples.length) {
                    var firstPTS = samples[0].pts;
                    var lastPTS = samples[samples.length - 1].pts;
                    this.avcFrameDuration = Math.round((lastPTS - firstPTS) / (samples.length - 1));
                }
            }

            this.remux(level, sn, null);
        }
    }, {
        key: 'remux',
        value: function remux(level, sn, data) {
            this.remuxer.remux(level, sn, this._aacTrack, this._avcTrack, this._id3Track, this._txtTrack, this.timeOffset, this.contiguous, data);
        }
    }, {
        key: 'destroy',
        value: function destroy() {}
    }, {
        key: 'parseAACTag',
        value: function parseAACTag(tag) {
            var track = this._aacTrack;
            var samples = track.samples;
            var pts = Math.round((this.timeOffset * 1000 + tag.timestamp) * 90) - this.aacDelta;
            var aacLastPTS = this.aacLastPTS;
            var frameDuration = 1024 * 90000 / track.audiosamplerate;
            if (aacLastPTS && !this.aacDelta) {
                var nextPts = aacLastPTS + frameDuration;
                var aacDelta = pts - nextPts;
                if (aacDelta > frameDuration) {
                    this.aacDelta = aacDelta;
                    pts = nextPts;
                }
            }
            samples.push({
                dts: pts,
                pts: pts,
                unit: tag.data
            });
            track.len += tag.data.byteLength;
            this.aacLastPTS = pts;
        }
    }, {
        key: 'parseAVCTag',
        value: function parseAVCTag(tag) {
            var _this = this;

            var track = this._avcTrack;
            var samples = track.samples,
                units = this.parseAVCNALUnit(tag.data),
                units2 = [],
                debug = false,
                key = false,
                length = 0,
                expGolombDecoder,
                avcSample,
                push,
                i;
            // no NALu found
            if (units.length === 0 && samples.length > 0) {
                // append tag.data to previous NAL unit
                var lastavcSample = samples[samples.length - 1];
                var lastUnit = lastavcSample.units.units[lastavcSample.units.units.length - 1];
                var tmp = new Uint8Array(lastUnit.data.byteLength + tag.data.byteLength);
                tmp.set(lastUnit.data, 0);
                tmp.set(tag.data, lastUnit.data.byteLength);
                lastUnit.data = tmp;
                lastavcSample.units.length += tag.data.byteLength;
                track.len += tag.data.byteLength;
            }
            // free tag.data to save up some memory
            tag.data = null;
            var debugString = '';
            var avcLastPTS = this.avcLastPTS;
            var frameDuration = this.avcFrameDuration;
            var dts = Math.round((this.timeOffset * 1000 + tag.timestamp) * 90) - this.avcDelta;
            var pts = dts + tag.cts * 90;

            if (avcLastPTS && frameDuration && !this.avcDelta) {
                var nextPts = avcLastPTS + frameDuration;
                var avcDelta = pts - nextPts;
                if (avcDelta > frameDuration) {
                    this.avcDelta = avcDelta;
                    pts = nextPts;
                    dts = pts - tag.cts * 90;
                }
            }

            var pushAccesUnit = function () {
                if (units2.length) {
                    // only push AVC sample if starting with a keyframe is not mandatory OR
                    //    if keyframe already found in this fragment OR
                    //       keyframe found in last fragment (track.sps) AND
                    //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
                    if (!this.config.forceKeyFrameOnDiscontinuity || key === true || track.sps && (samples.length || this.contiguous)) {
                        avcSample = { units: { units: units2, length: length }, pts: pts, dts: dts, key: key };
                        samples.push(avcSample);
                        track.len += length;
                        track.nbNalu += units2.length;
                    } else {
                        // dropped samples, track it
                        track.dropped++;
                    }
                    units2 = [];
                    length = 0;
                }
            }.bind(this);

            units.forEach(function (unit) {
                switch (unit.type) {
                    //NDR
                    case 1:
                        push = true;
                        if (debug) {
                            debugString += 'NDR ';
                        }
                        break;
                    //IDR
                    case 5:
                        push = true;
                        if (debug) {
                            debugString += 'IDR ';
                        }
                        key = true;
                        break;
                    //SEI
                    case 6:
                        push = true;
                        if (debug) {
                            debugString += 'SEI ';
                        }
                        expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

                        // skip frameType
                        expGolombDecoder.readUByte();

                        var payloadType = 0;
                        var payloadSize = 0;
                        var endOfCaptions = false;
                        var b = 0;

                        while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
                            payloadType = 0;
                            do {
                                b = expGolombDecoder.readUByte();
                                payloadType += b;
                            } while (b === 0xFF);

                            // Parse payload size.
                            payloadSize = 0;
                            do {
                                b = expGolombDecoder.readUByte();
                                payloadSize += b;
                            } while (b === 0xFF);

                            // TODO: there can be more than one payload in an SEI packet...
                            // TODO: need to read type and size in a while loop to get them all
                            if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                                endOfCaptions = true;

                                var countryCode = expGolombDecoder.readUByte();

                                if (countryCode === 181) {
                                    var providerCode = expGolombDecoder.readUShort();

                                    if (providerCode === 49) {
                                        var userStructure = expGolombDecoder.readUInt();

                                        if (userStructure === 0x47413934) {
                                            var userDataType = expGolombDecoder.readUByte();

                                            // Raw CEA-608 bytes wrapped in CEA-708 packet
                                            if (userDataType === 3) {
                                                var firstByte = expGolombDecoder.readUByte();
                                                var secondByte = expGolombDecoder.readUByte();

                                                var totalCCs = 31 & firstByte;
                                                var byteArray = [firstByte, secondByte];

                                                for (i = 0; i < totalCCs; i++) {
                                                    // 3 bytes per CC
                                                    byteArray.push(expGolombDecoder.readUByte());
                                                    byteArray.push(expGolombDecoder.readUByte());
                                                    byteArray.push(expGolombDecoder.readUByte());
                                                }

                                                _this.insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pts, bytes: byteArray });
                                            }
                                        }
                                    }
                                }
                            } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                                for (i = 0; i < payloadSize; i++) {
                                    expGolombDecoder.readUByte();
                                }
                            }
                        }
                        break;
                    //SPS
                    case 7:
                        push = true;
                        if (debug) {
                            debugString += 'SPS ';
                        }
                        if (!track.sps) {
                            expGolombDecoder = new _expGolomb2.default(unit.data);
                            var config = expGolombDecoder.readSPS();
                            track.width = config.width;
                            track.height = config.height;
                            track.sps = [unit.data];
                            track.duration = _this._duration;
                            var codecarray = unit.data.subarray(1, 4);
                            var codecstring = 'avc1.';
                            for (i = 0; i < 3; i++) {
                                var h = codecarray[i].toString(16);
                                if (h.length < 2) {
                                    h = '0' + h;
                                }
                                codecstring += h;
                            }
                            track.codec = codecstring;
                        }
                        break;
                    //PPS
                    case 8:
                        push = true;
                        if (debug) {
                            debugString += 'PPS ';
                        }
                        if (!track.pps) {
                            track.pps = [unit.data];
                        }
                        break;
                    case 9:
                        push = false;
                        if (debug) {
                            debugString += 'AUD ';
                        }
                        pushAccesUnit();
                        break;
                    default:
                        push = false;
                        debugString += 'unknown NAL ' + unit.type + ' ';
                        break;
                }
                if (push) {
                    units2.push(unit);
                    length += unit.data.byteLength;
                }
            });
            if (debug || debugString.length) {
                _logger.logger.log(debugString);
            }
            pushAccesUnit();
            this.avcLastPTS = pts;
        }
    }, {
        key: 'insertSampleInOrder',
        value: function insertSampleInOrder(arr, data) {
            var len = arr.length;
            if (len > 0) {
                if (data.pts >= arr[len - 1].pts) {
                    arr.push(data);
                } else {
                    for (var pos = len - 1; pos >= 0; pos--) {
                        if (data.pts < arr[pos].pts) {
                            arr.splice(pos, 0, data);
                            break;
                        }
                    }
                }
            } else {
                arr.push(data);
            }
        }
    }, {
        key: 'parseAVCNALUnit',
        value: function parseAVCNALUnit(array) {
            var track = this._avcTrack;
            var lengthSizeMinusOne = track.lengthSizeMinusOne;
            var units = [];
            var i = 0;
            var len = array.length;
            while (i < len) {
                var unitLen = 0;
                for (var j = 0; j < lengthSizeMinusOne; j++) {
                    unitLen |= array[i + j] << 8 * (lengthSizeMinusOne - 1 - j);
                }
                i += lengthSizeMinusOne;
                var unitType = array[i] & 0x1f;
                units.push({
                    type: unitType,
                    data: array.slice(i, i + unitLen)
                });
                i += unitLen;
            }
            return units;
        }
    }, {
        key: 'parseAudioConfig',
        value: function parseAudioConfig(observer, data, offset, audioCodec) {
            var track = this._aacTrack;
            var adtsObjectType,
                // :int
            adtsSampleingIndex,
                // :int
            adtsExtensionSampleingIndex,
                // :int
            adtsChanelConfig,
                // :int
            config,
                userAgent = navigator.userAgent.toLowerCase(),
                adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];

            adtsObjectType = (data[0] & 0xF8) >> 3;
            adtsSampleingIndex = (data[0] & 0x7) << 1 | data[1] >> 7;
            if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
                observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
                return;
            }
            adtsChanelConfig = data[1] >> 3 & 0x0F;
            _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
            // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
            if (userAgent.indexOf('firefox') !== -1) {
                if (adtsSampleingIndex >= 6) {
                    adtsObjectType = 5;
                    config = new Array(4);
                    // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
                    // there is a factor 2 between frame sample rate and output sample rate
                    // multiply frequency by 2 (see table below, equivalent to substract 3)
                    adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
                } else {
                    adtsObjectType = 2;
                    config = new Array(2);
                    adtsExtensionSampleingIndex = adtsSampleingIndex;
                }
                // Android : always use AAC
            } else if (userAgent.indexOf('android') !== -1) {
                adtsObjectType = 2;
                config = new Array(2);
                adtsExtensionSampleingIndex = adtsSampleingIndex;
            } else {
                /*  for other browsers (chrome ...)
                    always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
                */
                adtsObjectType = 5;
                config = new Array(4);
                // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
                if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
                    // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
                    // there is a factor 2 between frame sample rate and output sample rate
                    // multiply frequency by 2 (see table below, equivalent to substract 3)
                    adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
                } else {
                    // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
                    // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
                    if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
                        adtsObjectType = 2;
                        config = new Array(2);
                    }
                    adtsExtensionSampleingIndex = adtsSampleingIndex;
                }
            }
            // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
            config[0] = adtsObjectType << 3;
            // samplingFrequencyIndex
            config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
            config[1] |= (adtsSampleingIndex & 0x01) << 7;
            // channelConfiguration
            config[1] |= adtsChanelConfig << 3;
            if (adtsObjectType === 5) {
                // adtsExtensionSampleingIndex
                config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
                config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
                // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
                //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
                config[2] |= 2 << 2;
                config[3] = 0;
            }
            if (!track.audiosamplerate) {
                track.config = config;
                track.audiosamplerate = adtsSampleingRates[adtsSampleingIndex];
                track.channelCount = adtsChanelConfig;
                track.codec = 'mp4a.40.' + adtsObjectType;
                track.duration = this._duration;
            }
            return {
                config: config,
                samplerate: adtsSampleingRates[adtsSampleingIndex],
                channelCount: adtsChanelConfig,
                codec: 'mp4a.40.' + adtsObjectType
            };
        }
    }, {
        key: 'parseVideoConfig',
        value: function parseVideoConfig(observer, data, offset, videoCodec) {
            var track = this._avcTrack;
            var configurationVersion = data[0];
            var AVCProfileIndication = data[1];
            var profile_compatibility = data[2];
            var AVCLevelIndication = data[3];
            var lengthSizeMinusOne = 1 + (data[4] & 3);
            var numOfSequenceParameterSets = data[5] & 0x1F;
            var sidx = 6;
            var sequenceParameterSetLength = new DataView(data.slice(sidx, sidx + 2).buffer).getUint16(0);
            sidx += 2;
            var sequenceParameterSetNALUnits = data.slice(sidx, sidx + sequenceParameterSetLength);
            sidx += sequenceParameterSetLength;
            var numOfPictureParameterSets = data[sidx++];
            var pictureParameterSetLength = new DataView(data.slice(sidx, sidx + 2).buffer).getUint16(0);
            sidx += 2;
            var pictureParameterSetNALUnits = data.slice(sidx, sidx + pictureParameterSetLength);
            if (!track.lengthSizeMinusOne) {
                track.lengthSizeMinusOne = lengthSizeMinusOne;
                var expGolombDecoder = new _expGolomb2.default(sequenceParameterSetNALUnits);
                var config = expGolombDecoder.readSPS();
                track.width = config.width;
                track.height = config.height;
                track.sps = [sequenceParameterSetNALUnits];
                track.duration = this._duration;
                var codecarray = sequenceParameterSetNALUnits.subarray(1, 4);
                var codecstring = 'avc1.';
                for (var i = 0; i < 3; i++) {
                    var h = codecarray[i].toString(16);
                    if (h.length < 2) {
                        h = '0' + h;
                    }
                    codecstring += h;
                }
                track.codec = codecstring;
                track.pps = [pictureParameterSetNALUnits];
            }
            return {
                lengthSizeMinusOne: lengthSizeMinusOne,
                sequenceParameterSetNALUnits: sequenceParameterSetNALUnits,
                pictureParameterSetNALUnits: pictureParameterSetNALUnits
            };
        }
    }], [{
        key: 'probe',
        value: function probe(data) {
            // flv starting with 0x46 0x4C 0x56, 0x01
            if (data.length > _flvParser2.default.MIN_FILE_HEADER_BYTE_COUNT && data[0] === 0x46 && data[1] === 0x4C && data[2] === 0x56 && data[3] === 0x01) {
                return true;
            } else {
                return false;
            }
        }
    }]);

    return FLVDemuxer;
}();

exports.default = FLVDemuxer;

},{"../demux/flv-parser":22,"../demux/flv-tag":23,"../errors":27,"../events":29,"../utils/logger":46,"./exp-golomb":21}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import Hex from '../utils/hex';

var ID3 = function () {
  function ID3(data) {
    _classCallCheck(this, ID3);

    this._hasTimeStamp = false;
    var offset = 0,
        byte1,
        byte2,
        byte3,
        byte4,
        tagSize,
        endPos,
        header,
        len;
    do {
      header = this.readUTF(data, offset, 3);
      offset += 3;
      // first check for ID3 header
      if (header === 'ID3') {
        // skip 24 bits
        offset += 3;
        // retrieve tag(s) length
        byte1 = data[offset++] & 0x7f;
        byte2 = data[offset++] & 0x7f;
        byte3 = data[offset++] & 0x7f;
        byte4 = data[offset++] & 0x7f;
        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
        endPos = offset + tagSize;
        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);

        // read ID3 tags
        this._parseID3Frames(data, offset, endPos);
        offset = endPos;
      } else if (header === '3DI') {
        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
        offset += 7;
        _logger.logger.log('3DI footer found, end: ' + offset);
      } else {
        offset -= 3;
        len = offset;
        if (len) {
          //logger.log(`ID3 len: ${len}`);
          if (!this.hasTimeStamp) {
            _logger.logger.warn('ID3 tag found, but no timestamp');
          }
          this._length = len;
          this._payload = data.subarray(0, len);
        }
        return;
      }
    } while (true);
  }

  _createClass(ID3, [{
    key: 'readUTF',
    value: function readUTF(data, start, len) {

      var result = '',
          offset = start,
          end = start + len;
      do {
        result += String.fromCharCode(data[offset++]);
      } while (offset < end);
      return result;
    }
  }, {
    key: '_parseID3Frames',
    value: function _parseID3Frames(data, offset, endPos) {
      var tagId, tagLen, tagStart, tagFlags, timestamp;
      while (offset + 8 <= endPos) {
        tagId = this.readUTF(data, offset, 4);
        offset += 4;

        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];

        tagFlags = data[offset++] << 8 + data[offset++];

        tagStart = offset;
        //logger.log("ID3 tag id:" + tagId);
        switch (tagId) {
          case 'PRIV':
            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
            // owner should be "com.apple.streaming.transportStreamTimestamp"
            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
              offset += 44;
              // smelling even better ! we found the right descriptor
              // skip null character (string end) + 3 first bytes
              offset += 4;

              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
              var pts33Bit = data[offset++] & 0x1;
              this._hasTimeStamp = true;

              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;

              if (pts33Bit) {
                timestamp += 47721858.84; // 2^32 / 90
              }
              timestamp = Math.round(timestamp);
              _logger.logger.trace('ID3 timestamp found: ' + timestamp);
              this._timeStamp = timestamp;
            }
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: 'hasTimeStamp',
    get: function get() {
      return this._hasTimeStamp;
    }
  }, {
    key: 'timeStamp',
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._length;
    }
  }, {
    key: 'payload',
    get: function get() {
      return this._payload;
    }
  }]);

  return ID3;
}();

exports.default = ID3;

},{"../utils/logger":46}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TSDemuxer = function () {
  function TSDemuxer(observer, id, remuxerClass, config) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.lastCC = 0;
    this.remuxer = new this.remuxerClass(observer, id, config);
  }

  _createClass(TSDemuxer, [{
    key: 'switchLevel',
    value: function switchLevel() {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, nbNalu: 0, dropped: 0 };
      this._aacTrack = { container: 'video/mp2t', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcNaluState = 0;
      this.remuxer.switchLevel();
    }
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this.switchLevel();
      this.remuxer.insertDiscontinuity();
    }

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration) {
      var avcData,
          aacData,
          id3Data,
          start,
          len = data.length,
          stt,
          pid,
          atf,
          offset,
          codecsOnly = this.remuxer.passthrough,
          unknownPIDs = false;

      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.timeOffset = timeOffset;
      this._duration = duration;
      this.contiguous = false;
      if (cc !== this.lastCC) {
        _logger.logger.log('discontinuity detected');
        this.insertDiscontinuity();
        this.lastCC = cc;
      }
      if (level !== this.lastLevel) {
        _logger.logger.log('level switch detected');
        this.switchLevel();
        this.lastLevel = level;
      } else if (sn === this.lastSN + 1) {
        this.contiguous = true;
      }
      this.lastSN = sn;

      var pmtParsed = this.pmtParsed,
          avcId = this._avcTrack.id,
          aacId = this._aacTrack.id,
          id3Id = this._id3Track.id,
          pmtId = this._pmtId;

      var parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      // don't parse last TS packet if incomplete
      len -= len % 188;
      // loop through TS packets
      for (start = 0; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData) {
                  parseAVCPES(parsePES(avcData));
                  if (codecsOnly) {
                    // if we have video codec info AND
                    // if audio PID is undefined OR if we have audio codec info,
                    // we have all codec info !
                    if (this._avcTrack.codec && (aacId === -1 || this._aacTrack.codec)) {
                      this.remux(level, sn, data);
                      return;
                    }
                  }
                }
                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case aacId:
              if (stt) {
                if (aacData) {
                  parseAACPES(parsePES(aacData));
                  if (codecsOnly) {
                    // here we now that we have audio codec info
                    // if video PID is undefined OR if we have video codec info,
                    // we have all codec infos !
                    if (this._aacTrack.codec && (avcId === -1 || this._avcTrack.codec)) {
                      this.remux(level, sn, data);
                      return;
                    }
                  }
                }
                aacData = { data: [], size: 0 };
              }
              if (aacData) {
                aacData.data.push(data.subarray(offset, start + 188));
                aacData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data) {
                  parseID3PES(parsePES(id3Data));
                }
                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }
              var parsedPIDs = parsePMT(data, offset);
              avcId = this._avcTrack.id = parsedPIDs.avc;
              aacId = this._aacTrack.id = parsedPIDs.aac;
              id3Id = this._id3Track.id = parsedPIDs.id3;
              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = -188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // parse last PES packet
      if (avcData) {
        parseAVCPES(parsePES(avcData));
      }
      if (aacData) {
        parseAACPES(parsePES(aacData));
      }
      if (id3Data) {
        parseID3PES(parsePES(id3Data));
      }
      this.remux(level, sn, null);
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, data) {
      this.remuxer.remux(level, sn, this._aacTrack, this._avcTrack, this._id3Track, this._txtTrack, this.timeOffset, this.contiguous, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.switchLevel();
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      //logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset) {
      var sectionLength,
          tableEnd,
          programInfoLength,
          pid,
          result = { aac: -1, avc: -1, id3: -1 };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            //logger.log('AAC PID:'  + pid);
            if (result.aac === -1) {
              result.aac = pid;
            }
            break;
          // Packetized metadata (ID3)
          case 0x15:
            //logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }
            break;
          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            //logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }
            break;
          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;
          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag,
          pesFlags,
          pesPrefix,
          pesLen,
          pesHdrLen,
          pesData,
          pesPts,
          pesDts,
          payloadStartOffset,
          data = stream.data;
      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      //retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        //reassemble PES packet
        pesData = new Uint8Array(stream.size);
        while (data.length) {
          frag = data.shift();
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes) {
      var _this = this;

      var track = this._avcTrack,
          samples = track.samples,
          units = this._parseAVCNALu(pes.data),
          units2 = [],
          debug = false,
          key = false,
          length = 0,
          expGolombDecoder,
          avcSample,
          push,
          i;
      // no NALu found
      if (units.length === 0 && samples.length > 0) {
        // append pes.data to previous NAL unit
        var lastavcSample = samples[samples.length - 1];
        var lastUnit = lastavcSample.units.units[lastavcSample.units.units.length - 1];
        var tmp = new Uint8Array(lastUnit.data.byteLength + pes.data.byteLength);
        tmp.set(lastUnit.data, 0);
        tmp.set(pes.data, lastUnit.data.byteLength);
        lastUnit.data = tmp;
        lastavcSample.units.length += pes.data.byteLength;
        track.len += pes.data.byteLength;
      }
      //free pes.data to save up some memory
      pes.data = null;
      var debugString = '';

      var pushAccesUnit = function () {
        if (units2.length) {
          // only push AVC sample if starting with a keyframe is not mandatory OR
          //    if keyframe already found in this fragment OR
          //       keyframe found in last fragment (track.sps) AND
          //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
          if (!this.config.forceKeyFrameOnDiscontinuity || key === true || track.sps && (samples.length || this.contiguous)) {
            avcSample = { units: { units: units2, length: length }, pts: pes.pts, dts: pes.dts, key: key };
            samples.push(avcSample);
            track.len += length;
            track.nbNalu += units2.length;
          } else {
            // dropped samples, track it
            track.dropped++;
          }
          units2 = [];
          length = 0;
        }
      }.bind(this);

      units.forEach(function (unit) {
        switch (unit.type) {
          //NDR
          case 1:
            push = true;
            if (debug) {
              debugString += 'NDR ';
            }
            break;
          //IDR
          case 5:
            push = true;
            if (debug) {
              debugString += 'IDR ';
            }
            key = true;
            break;
          //SEI
          case 6:
            push = true;
            if (debug) {
              debugString += 'SEI ';
            }
            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          //SPS
          case 7:
            push = true;
            if (debug) {
              debugString += 'SPS ';
            }
            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          //PPS
          case 8:
            push = true;
            if (debug) {
              debugString += 'PPS ';
            }
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          case 9:
            push = false;
            if (debug) {
              debugString += 'AUD ';
            }
            pushAccesUnit();
            break;
          default:
            push = false;
            debugString += 'unknown NAL ' + unit.type + ' ';
            break;
        }
        if (push) {
          units2.push(unit);
          length += unit.data.byteLength;
        }
      });
      if (debug || debugString.length) {
        _logger.logger.log(debugString);
      }
      pushAccesUnit();
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value,
          overflow,
          state = this.avcNaluState;
      var units = [],
          unit,
          unitType,
          lastUnitStart,
          lastUnitType;
      //logger.log('PES:' + Hex.hexDump(array));
      while (i < len) {
        value = array[i++];
        // finding 3 or 4-byte start codes (00 00 01 OR 00 00 00 01)
        switch (state) {
          case 0:
            if (value === 0) {
              state = 1;
            }
            break;
          case 1:
            if (value === 0) {
              state = 2;
            } else {
              state = 0;
            }
            break;
          case 2:
          case 3:
            if (value === 0) {
              state = 3;
            } else if (value === 1 && i < len) {
              unitType = array[i] & 0x1f;
              //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
              if (lastUnitStart) {
                unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
                units.push(unit);
              } else {
                // lastUnitStart is undefined => this is the first start code found in this PES packet
                // first check if start code delimiter is overlapping between 2 PES packets,
                // ie it started in last packet (lastState not zero)
                // and ended at the beginning of this PES packet (i <= 4 - lastState)
                var lastState = this.avcNaluState;
                if (lastState && i <= 4 - lastState) {
                  // start delimiter overlapping between PES packets
                  // strip start delimiter bytes from the end of last NAL unit
                  var track = this._avcTrack,
                      samples = track.samples;
                  if (samples.length) {
                    var lastavcSample = samples[samples.length - 1],
                        lastUnits = lastavcSample.units.units,
                        lastUnit = lastUnits[lastUnits.length - 1];
                    // check if lastUnit had a state different from zero
                    if (lastUnit.state) {
                      // strip last bytes
                      lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                      lastavcSample.units.length -= lastState;
                      track.len -= lastState;
                    }
                  }
                }
                // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
                overflow = i - state - 1;
                if (overflow > 0) {
                  var _track = this._avcTrack,
                      _samples = _track.samples;
                  //logger.log('first NALU found with overflow:' + overflow);
                  if (_samples.length) {
                    var _lastavcSample = _samples[_samples.length - 1],
                        _lastUnits = _lastavcSample.units.units,
                        _lastUnit = _lastUnits[_lastUnits.length - 1],
                        tmp = new Uint8Array(_lastUnit.data.byteLength + overflow);
                    tmp.set(_lastUnit.data, 0);
                    tmp.set(array.subarray(0, overflow), _lastUnit.data.byteLength);
                    _lastUnit.data = tmp;
                    _lastavcSample.units.length += overflow;
                    _track.len += overflow;
                  }
                }
              }
              lastUnitStart = i;
              lastUnitType = unitType;
              state = 0;
            } else {
              state = 0;
            }
            break;
          default:
            break;
        }
      }
      if (lastUnitStart) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
        this.avcNaluState = state;
      }
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength,
          newData;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._aacTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          duration = this._duration,
          audioCodec = this.audioCodec,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason, fatal;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }
      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        //logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }
      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;

},{"../errors":27,"../events":29,"../utils/logger":46,"./adts":17,"./exp-golomb":21}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = exports.ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: parsing error description
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: parsing error description
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('./utils/logger');

var _errors = require('./errors');

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.unregisterListeners();
    }
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (event === 'hlsEventGeneric') {
            throw new Error('Forbidden event name: ' + event);
          }
          this.hls.on(event, this.onEvent);
        }.bind(this));
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }.bind(this));
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }
        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;

},{"./errors":27,"./events":29,"./utils/logger":46}],29:[function(require,module,exports){
'use strict';

module.exports = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be resetted
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created data: { tracks : tracks}
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING }
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data {startOffset, endOffset}
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media has been flushed
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: {  id : audio track id}
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired when a fragment loading starts - data: { frag : fragment object}
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, moov : moov MP4 box, codecs : codecs found while parsing fragment}
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id; level : levelId, sn : sequence number, }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object}
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: {previousState, nextState}
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: "getSilentFrame",
    value: function getSilentFrame(channelCount) {
      if (channelCount === 1) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
      } else if (channelCount === 2) {
        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
      } else if (channelCount === 3) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
      } else if (channelCount === 4) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
      } else if (channelCount === 5) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
      } else if (channelCount === 6) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Buffer Helper class, providing methods dealing buffer length retrieval
*/

var BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      if (media) {
        var vbuffered = media.buffered,
            buffered = [],
            i;
        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
        }
        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      } else {
        return { len: 0, start: 0, end: 0, nextStart: undefined };
      }
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen,
          bufferStart,
          bufferEnd,
          bufferStartNext,
          i;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

exports.default = BufferHelper;

},{}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Level Helper class, providing methods dealing with playlist sliding and drift
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelHelper = function () {
  function LevelHelper() {
    _classCallCheck(this, LevelHelper);
  }

  _createClass(LevelHelper, null, [{
    key: 'mergeDetails',
    value: function mergeDetails(oldDetails, newDetails) {
      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
          end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
          delta = newDetails.startSN - oldDetails.startSN,
          oldfragments = oldDetails.fragments,
          newfragments = newDetails.fragments,
          ccOffset = 0,
          PTSFrag;

      // check if old/new playlists have fragments in common
      if (end < start) {
        newDetails.PTSKnown = false;
        return;
      }
      // loop through overlapping SN and update startPTS , cc, and duration if any found
      for (var i = start; i <= end; i++) {
        var oldFrag = oldfragments[delta + i],
            newFrag = newfragments[i];
        if (newFrag && oldFrag) {
          ccOffset = oldFrag.cc - newFrag.cc;
          if (!isNaN(oldFrag.startPTS)) {
            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
            newFrag.endPTS = oldFrag.endPTS;
            newFrag.duration = oldFrag.duration;
            PTSFrag = newFrag;
          }
        }
      }

      if (ccOffset) {
        _logger.logger.log('discontinuity sliding from playlist, take drift into account');
        for (i = 0; i < newfragments.length; i++) {
          newfragments[i].cc += ccOffset;
        }
      }

      // if at least one fragment contains PTS info, recompute PTS information for all fragments
      if (PTSFrag) {
        LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
      } else {
        // ensure that delta is within oldfragments range
        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
        // in that case we also need to adjust start offset of all fragments
        if (delta >= 0 && delta < oldfragments.length) {
          // adjust start by sliding offset
          var sliding = oldfragments[delta].start;
          for (i = 0; i < newfragments.length; i++) {
            newfragments[i].start += sliding;
          }
        }
      }
      // if we are here, it means we have fragments overlapping between
      // old and new level. reliable PTS info is thus relying on old level
      newDetails.PTSKnown = oldDetails.PTSKnown;
      return;
    }
  }, {
    key: 'updateFragPTSDTS',
    value: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {
      var fragIdx, fragments, frag, i;
      // exit if sn out of range
      if (sn < details.startSN || sn > details.endSN) {
        return 0;
      }
      fragIdx = sn - details.startSN;
      fragments = details.fragments;
      frag = fragments[fragIdx];
      if (!isNaN(frag.startPTS)) {
        // delta PTS between audio and video
        var deltaPTS = Math.abs(frag.startPTS - startPTS);
        if (isNaN(frag.deltaPTS)) {
          frag.deltaPTS = deltaPTS;
        } else {
          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
        }
        startPTS = Math.min(startPTS, frag.startPTS);
        endPTS = Math.max(endPTS, frag.endPTS);
        startDTS = Math.min(startDTS, frag.startDTS);
        endDTS = Math.max(endDTS, frag.endDTS);
      }

      var drift = startPTS - frag.start;

      frag.start = frag.startPTS = startPTS;
      frag.endPTS = endPTS;
      frag.startDTS = startDTS;
      frag.endDTS = endDTS;
      frag.duration = endPTS - startPTS;
      // adjust fragment PTS/duration from seqnum-1 to frag 0
      for (i = fragIdx; i > 0; i--) {
        LevelHelper.updatePTS(fragments, i, i - 1);
      }

      // adjust fragment PTS/duration from seqnum to last frag
      for (i = fragIdx; i < fragments.length - 1; i++) {
        LevelHelper.updatePTS(fragments, i, i + 1);
      }
      details.PTSKnown = true;
      //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

      return drift;
    }
  }, {
    key: 'updatePTS',
    value: function updatePTS(fragments, fromIdx, toIdx) {
      var fragFrom = fragments[fromIdx],
          fragTo = fragments[toIdx],
          fragToPTS = fragTo.startPTS;
      // if we know startPTS[toIdx]
      if (!isNaN(fragToPTS)) {
        // update fragment duration.
        // it helps to fix drifts between playlist reported duration and fragment real duration
        if (toIdx > fromIdx) {
          fragFrom.duration = fragToPTS - fragFrom.start;
          if (fragFrom.duration < 0) {
            _logger.logger.error('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
          }
        } else {
          fragTo.duration = fragFrom.start - fragToPTS;
          if (fragTo.duration < 0) {
            _logger.logger.error('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
          }
        }
      } else {
        // we dont know startPTS[toIdx]
        if (toIdx > fromIdx) {
          fragTo.start = fragFrom.start + fragFrom.duration;
        } else {
          fragTo.start = fragFrom.start - fragTo.duration;
        }
      }
    }
  }]);

  return LevelHelper;
}();

exports.default = LevelHelper;

},{"../utils/logger":46}],33:[function(require,module,exports){
/**
 * HLS interface
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
//import FetchLoader from './utils/fetch-loader';


var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('./errors');

var _playlistLoader = require('./loader/playlist-loader');

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = require('./loader/fragment-loader');

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _abrController = require('./controller/abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = require('./controller/buffer-controller');

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = require('./controller/cap-level-controller');

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _audioStreamController = require('./controller/audio-stream-controller');

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _streamController = require('./controller/stream-controller');

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = require('./controller/level-controller');

var _levelController2 = _interopRequireDefault(_levelController);

var _timelineController = require('./controller/timeline-controller');

var _timelineController2 = _interopRequireDefault(_timelineController);

var _fpsController = require('./controller/fps-controller');

var _fpsController2 = _interopRequireDefault(_fpsController);

var _audioTrackController = require('./controller/audio-track-controller');

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _logger = require('./utils/logger');

var _xhrLoader = require('./utils/xhr-loader');

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

var _keyLoader = require('./loader/key-loader');

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _cues = require('./utils/cues');

var _cues2 = _interopRequireDefault(_cues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = function () {
  _createClass(Hls, null, [{
    key: 'isSupported',
    value: function isSupported() {
      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    }
  }, {
    key: 'version',
    get: function get() {
      // replaced with browserify-versionify transform
      return '__VERSION__';
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        Hls.defaultConfig = {
          autoStartLoad: true,
          startPosition: -1,
          debug: false,
          capLevelOnFPSDrop: false,
          capLevelToPlayerSize: false,
          maxBufferLength: 30,
          maxBufferSize: 60 * 1000 * 1000,
          maxBufferHole: 0.5,
          maxSeekHole: 2,
          seekHoleNudgeDuration: 0.01,
          stalledInBufferedNudgeThreshold: 10,
          maxFragLookUpTolerance: 0.2,
          liveSyncDurationCount: 3,
          liveMaxLatencyDurationCount: Infinity,
          liveSyncDuration: undefined,
          liveMaxLatencyDuration: undefined,
          maxMaxBufferLength: 600,
          enableWorker: true,
          enableSoftwareAES: true,
          manifestLoadingTimeOut: 10000,
          manifestLoadingMaxRetry: 1,
          manifestLoadingRetryDelay: 1000,
          manifestLoadingMaxRetryTimeout: 64000,
          levelLoadingTimeOut: 10000,
          levelLoadingMaxRetry: 4,
          levelLoadingRetryDelay: 1000,
          levelLoadingMaxRetryTimeout: 64000,
          fragLoadingTimeOut: 20000,
          fragLoadingMaxRetry: 6,
          fragLoadingRetryDelay: 1000,
          fragLoadingMaxRetryTimeout: 64000,
          fragLoadingLoopThreshold: 3,
          startFragPrefetch: false,
          fpsDroppedMonitoringPeriod: 5000,
          fpsDroppedMonitoringThreshold: 0.2,
          appendErrorMaxRetry: 3,
          loader: _xhrLoader2.default,
          //loader: FetchLoader,
          fLoader: undefined,
          pLoader: undefined,
          abrController: _abrController2.default,
          bufferController: _bufferController2.default,
          capLevelController: _capLevelController2.default,
          fpsController: _fpsController2.default,
          streamController: _streamController2.default,
          audioStreamController: _audioStreamController2.default,
          timelineController: _timelineController2.default,
          cueHandler: _cues2.default,
          enableCEA708Captions: true,
          enableMP2TPassThrough: false,
          stretchShortVideoTrack: false,
          forceKeyFrameOnDiscontinuity: true,
          abrEwmaFastLive: 5,
          abrEwmaSlowLive: 9,
          abrEwmaFastVoD: 4,
          abrEwmaSlowVoD: 15,
          abrEwmaDefaultEstimate: 5e5, // 500 kbps
          abrBandWidthFactor: 0.8,
          abrBandWidthUpFactor: 0.7
        };
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    this.config = config;
    // observer setup
    var observer = this.observer = new _events4.default();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);
    this.playlistLoader = new _playlistLoader2.default(this);
    this.fragmentLoader = new _fragmentLoader2.default(this);
    this.levelController = new _levelController2.default(this);
    this.abrController = new config.abrController(this);
    this.bufferController = new config.bufferController(this);
    this.capLevelController = new config.capLevelController(this);
    this.fpsController = new config.fpsController(this);
    this.streamController = new config.streamController(this);
    this.audioStreamController = new config.audioStreamController(this);
    this.timelineController = new config.timelineController(this);
    this.audioTrackController = new _audioTrackController2.default(this);
    this.keyLoader = new _keyLoader2.default(this);
  }

  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.playlistLoader.destroy();
      this.fragmentLoader.destroy();
      this.levelController.destroy();
      this.abrController.destroy();
      this.bufferController.destroy();
      this.capLevelController.destroy();
      this.fpsController.destroy();
      this.streamController.destroy();
      this.audioStreamController.destroy();
      this.timelineController.destroy();
      this.audioTrackController.destroy();
      this.keyLoader.destroy();
      this.url = null;
      this.observer.removeAllListeners();
    }
  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }
  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }
  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

      _logger.logger.log('startLoad');
      this.levelController.startLoad();
      this.streamController.startLoad(startPosition);
      this.audioStreamController.startLoad(startPosition);
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.levelController.stopLoad();
      this.streamController.stopLoad();
      this.audioStreamController.stopLoad();
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }
  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /** Return all quality levels **/

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return this.levelController.firstLevel;
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      this.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this.abrController.autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this.abrController.autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      return this.audioTrackController.audioTracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.audioTrackController.audioTrack;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      this.audioTrackController.audioTrack = audioTrackId;
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }
  }]);

  return Hls;
}();

exports.default = Hls;

},{"./controller/abr-controller":3,"./controller/audio-stream-controller":4,"./controller/audio-track-controller":5,"./controller/buffer-controller":6,"./controller/cap-level-controller":7,"./controller/fps-controller":9,"./controller/level-controller":10,"./controller/stream-controller":11,"./controller/timeline-controller":12,"./errors":27,"./events":29,"./loader/fragment-loader":35,"./loader/key-loader":36,"./loader/playlist-loader":37,"./utils/cues":44,"./utils/logger":46,"./utils/xhr-loader":50,"events":1}],34:[function(require,module,exports){
'use strict';

// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports = require('./hls.js').default;

},{"./hls.js":33}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          config = this.hls.config;

      frag.loaded = 0;
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type:' + type);
        loader.abort();
      }
      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;
      if (!isNaN(start) && !isNaN(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous fragment loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/logger":46}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _url = require('../utils/url');

var _url2 = _interopRequireDefault(_url);

var _attrList = require('../utils/attr-list');

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: 'manifest' });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: 'level', level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: 'audioTrack', id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var config = this.hls.config,
          retry,
          timeout,
          retryDelay,
          maxRetryDelay;
      if (context.type === 'manifest') {
        retry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeOut;
      } else {
        retry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeOut;
      }
      var loader = this.loaders[context.type];
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          _logger.logger.warn('playlist request ongoing');
          return;
        } else {
          _logger.logger.warn('abort previous loader for type:' + context.type);
          loader.abort();
        }
      }
      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
      context.url = url;
      context.responseType = '';

      var loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return _url2.default.buildAbsoluteURL(baseUrl, url);
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;

      // https://regex101.com is your friend
      var re = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
      while ((result = re.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = this.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        var codecs = attrs.CODECS;
        if (codecs) {
          codecs = codecs.split(',');
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            if (codec.indexOf('avc1') !== -1) {
              level.videoCodec = this.avc1toavcoti(codec);
            } else {
              level.audioCodec = codec;
            }
          }
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var result = void 0,
          medias = [];

      // https://regex101.com is your friend
      var re = /#EXT-X-MEDIA:(.*)/g;
      while ((result = re.exec(string)) != null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = this.resolve(attrs.URI, baseurl);
          }
          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }
          medias.push(media);
        }
      }
      return medias;
    }
    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */

  }, {
    key: 'createInitializationVector',
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = this.cloneObj(levelkey);
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'avc1toavcoti',
    value: function avc1toavcoti(codec) {
      var result,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'cloneObj',
    value: function cloneObj(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type) {
      var currentSN = 0,
          fragdecryptdata,
          totalduration = 0,
          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
          levelkey = { method: null, key: null, iv: null, uri: null },
          cc = 0,
          programDateTime = null,
          frag = null,
          result,
          regexp,
          duration = null,
          title = null,
          byteRangeEndOffset = null,
          byteRangeStartOffset = null,
          tagList = [];

      regexp = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE):(\d+))|(?:#EXT-X-(TARGETDURATION):(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT(INF):(\d+(?:\.\d+)?)(?:,(.*))?)|(?:(?!#)()(\S.+))|(?:#EXT-X-(BYTERANGE):(\d+(?:@\d+(?:\.\d+)?)?)|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(PROGRAM-DATE-TIME):(.+))|(?:#EXT-X-(VERSION):(\d+))|(?:(#)(.*):(.*))|(?:(#)(.*)))(?:.*)\r?\n?/g;
      while ((result = regexp.exec(string)) !== null) {
        result.shift();
        result = result.filter(function (n) {
          return n !== undefined;
        });
        switch (result[0]) {
          case 'PLAYLIST-TYPE':
            level.type = result[1].toUpperCase();
            break;
          case 'MEDIA-SEQUENCE':
            currentSN = level.startSN = parseInt(result[1]);
            break;
          case 'TARGETDURATION':
            level.targetduration = parseFloat(result[1]);
            break;
          case 'VERSION':
            level.version = parseInt(result[1]);
            break;
          case 'EXTM3U':
            break;
          case 'ENDLIST':
            level.live = false;
            break;
          case 'DIS':
            cc++;
            tagList.push(result);
            break;
          case 'BYTERANGE':
            var params = result[1].split('@');
            if (params.length === 1) {
              byteRangeStartOffset = byteRangeEndOffset;
            } else {
              byteRangeStartOffset = parseInt(params[1]);
            }
            byteRangeEndOffset = parseInt(params[0]) + byteRangeStartOffset;
            break;
          case 'INF':
            duration = parseFloat(result[1]);
            title = result[2] ? result[2] : null;
            tagList.push(result);
            break;
          case '':
            // url
            if (!isNaN(duration)) {
              var sn = currentSN++;
              fragdecryptdata = this.fragmentDecryptdataFromLevelkey(levelkey, sn);
              var url = result[1] ? this.resolve(result[1], baseurl) : null;
              frag = { url: url,
                type: type,
                duration: duration,
                title: title,
                start: totalduration,
                sn: sn,
                level: id,
                cc: cc,
                decryptdata: fragdecryptdata,
                programDateTime: programDateTime,
                tagList: tagList };
              // only include byte range options if used/needed
              if (byteRangeStartOffset !== null) {
                frag.byteRangeStartOffset = byteRangeStartOffset;
                frag.byteRangeEndOffset = byteRangeEndOffset;
              }
              level.fragments.push(frag);
              totalduration += duration;
              duration = null;
              title = null;
              byteRangeStartOffset = null;
              programDateTime = null;
              tagList = [];
            }
            break;
          case 'KEY':
            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
            var decryptparams = result[1];
            var keyAttrs = new _attrList2.default(decryptparams);
            var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                decrypturi = keyAttrs.URI,
                decryptiv = keyAttrs.hexadecimalInteger('IV');
            if (decryptmethod) {
              levelkey = { method: null, key: null, iv: null, uri: null };
              if (decrypturi && decryptmethod === 'AES-128') {
                levelkey.method = decryptmethod;
                // URI to get the key
                levelkey.uri = this.resolve(decrypturi, baseurl);
                levelkey.key = null;
                // Initialization Vector (IV)
                levelkey.iv = decryptiv;
              }
            }
            break;
          case 'START':
            var startParams = result[1];
            var startAttrs = new _attrList2.default(startParams);
            var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
            if (startTimeOffset) {
              level.startTimeOffset = startTimeOffset;
            }
            break;
          case 'PROGRAM-DATE-TIME':
            programDateTime = new Date(Date.parse(result[1]));
            tagList.push(result);
            break;
          case '#':
            result.shift();
            tagList.push(result);
            break;
          default:
            _logger.logger.warn('line parsed but not handled: ' + result);
            break;
        }
      }
      //logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.url) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      return level;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var string = response.data,
          url = response.url,
          type = context.type,
          id = context.id,
          level = context.level,
          hls = this.hls;

      this.loaders[type] = undefined;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      stats.tload = performance.now();
      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
      if (string.indexOf('#EXTM3U') === 0) {
        if (string.indexOf('#EXTINF:') > 0) {
          var isLevel = type !== 'audioTrack',
              levelDetails = this.parseLevelPlaylist(string, url, level || id || 0, isLevel ? 'main' : 'audio');
          levelDetails.tload = stats.tload;
          if (type === 'manifest') {
            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], url: url, stats: stats });
          }
          stats.tparsed = performance.now();
          if (isLevel) {
            hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
          } else {
            hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
          }
        } else {
          var levels = this.parseMasterPlaylist(string, url);
          // multi level playlist, parse level info
          if (levels.length) {
            var audiotracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
            if (audiotracks.length) {
              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
              var embeddedAudioFound = false;
              audiotracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                  embeddedAudioFound = true;
                }
              });
              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audiotracks.unshift({ type: 'main', name: 'main' });
              }
            }
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audiotracks, url: url, stats: stats });
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });
          }
        }
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;

},{"../errors":27,"../event-handler":28,"../events":29,"../utils/attr-list":41,"../utils/logger":46,"../utils/url":49}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';
var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        mvex: [],
        mvhd: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var bytes = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // creation_time
      0x00, 0x00, 0x00, 0x02, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24 & 0xFF, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i,
          data,
          len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);
        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);
        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height;
      //console.log('avcc:' + Hex.hexDump(avcc));
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate
      );
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, //es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, //codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var audiosamplerate = track.audiosamplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height;
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, // creation_time
      0x00, 0x00, 0x00, 0x00, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id;
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      baseMediaDecodeTime >> 24, baseMediaDecodeTime >> 16 & 0XFF, baseMediaDecodeTime >> 8 & 0XFF, baseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      16 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i,
          sample,
          duration,
          size,
          flags,
          cts;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      var movie = MP4.moov(tracks),
          result;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aac = require('../helper/aac');

var _aac2 = _interopRequireDefault(_aac);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _mp4Generator = require('../remux/mp4-generator');

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = require('../errors');

require('../utils/polyfill');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP4Remuxer = function () {
  function MP4Remuxer(observer, id, config) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.id = id;
    this.config = config;
    this.ISGenerated = false;
    this.PES2MP4SCALEFACTOR = 4;
    this.PES_TIMESCALE = 90000;
    this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._initPTS = this._initDTS = undefined;
    }
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous) {
      this.level = level;
      this.sn = sn;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAacPts, which is
        // calculated in remuxAudio.
        //logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (audioTrack.samples.length) {
          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous);
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }
            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
          }
        } else {
          var videoData = void 0;
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
          }
          if (videoData && audioTrack.codec) {
            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
          }
        }
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }
      //notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED, { id: this.id, level: this.level, sn: this.sn });
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          pesTimeScale = this.PES_TIMESCALE,
          tracks = {},
          data = { id: this.id, level: this.level, sn: this.sn, tracks: tracks, unique: false },
          computePTSDTS = this._initPTS === undefined,
          initPTS,
          initDTS;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        audioTrack.timescale = audioTrack.audiosamplerate;
        // MP4 duration (track duration in seconds multiplied by timescale) is coded on 32 bits
        // we know that each AAC sample contains 1024 frames....
        // in order to avoid overflowing the 32 bit counter for large duration, we use smaller timescale (timescale/gcd)
        // we just need to ensure that AAC sample duration will still be an integer (will be 1024/gcd)
        if (audioTrack.timescale * audioTrack.duration > Math.pow(2, 32)) {
          (function () {
            var greatestCommonDivisor = function greatestCommonDivisor(a, b) {
              if (!b) {
                return a;
              }
              return greatestCommonDivisor(b, a % b);
            };
            audioTrack.timescale = audioTrack.audiosamplerate / greatestCommonDivisor(audioTrack.audiosamplerate, 1024);
          })();
        }
        _logger.logger.log('audio mp4 timescale :' + audioTrack.timescale);
        tracks.audio = {
          container: 'audio/mp4',
          codec: audioTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS + DTS ...
          initPTS = initDTS = audioSamples[0].pts - pesTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        videoTrack.timescale = this.MP4_TIMESCALE;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - pesTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - pesTimeScale * timeOffset);
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      var offset = 8,
          pesTimeScale = this.PES_TIMESCALE,
          pes2mp4ScaleFactor = this.PES2MP4SCALEFACTOR,
          mp4SampleDuration,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          nextDTS,
          lastPTS,
          lastDTS,
          inputSamples = track.samples,
          outputSamples = [];

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      var nextAvcDts = void 0;
      if (contiguous) {
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        nextAvcDts = this.nextAvcDts;
      } else {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * pesTimeScale;
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(this._PTSNormalize(sample.dts - this._initDTS, nextAvcDts), 0);
      firstPTS = Math.max(this._PTSNormalize(sample.pts - this._initDTS, nextAvcDts), 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }
          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS + this._initDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS + this._initDTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + firstPTS + '/' + firstDTS + ',delta:' + delta);
        }
      }
      nextDTS = firstDTS;

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(this._PTSNormalize(sample.dts - this._initDTS, nextAvcDts), 0);
      lastPTS = Math.max(this._PTSNormalize(sample.pts - this._initDTS, nextAvcDts), 0);
      lastPTS = Math.max(lastPTS, lastDTS);

      var vendor = navigator.vendor,
          userAgent = navigator.userAgent,
          isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (pes2mp4ScaleFactor * (inputSamples.length - 1)));
      }

      // normalize all PTS/DTS now ...
      for (var i = 0; i < inputSamples.length; i++) {
        var _sample = inputSamples[i];
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + i * pes2mp4ScaleFactor * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(this._PTSNormalize(_sample.dts - this._initDTS, nextAvcDts), firstDTS);
          // ensure dts is a multiple of scale factor to avoid rounding issues
          _sample.dts = Math.round(_sample.dts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
        }
        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
        // and we ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(this._PTSNormalize(_sample.pts - this._initDTS, nextAvcDts), _sample.dts);
        // ensure pts is a multiple of scale factor to avoid rounding issues
        _sample.pts = Math.round(_sample.pts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      mdat = new Uint8Array(track.len + 4 * track.nbNalu + 8);
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdat.byteLength);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i = 0; _i < inputSamples.length; _i++) {
        var avcSample = inputSamples[_i],
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        while (avcSample.units.units.length) {
          var unit = avcSample.units.units.shift();
          view.setUint32(offset, unit.data.byteLength);
          offset += 4;
          mdat.set(unit.data, offset);
          offset += unit.data.byteLength;
          mp4SampleLength += 4 + unit.data.byteLength;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i < inputSamples.length - 1) {
            mp4SampleDuration = inputSamples[_i + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i > 0 ? _i - 1 : _i].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  maxSeekHole = config.maxSeekHole,
                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * pesTimeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * pesTimeScale : this.nextAacPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }
                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          mp4SampleDuration /= pes2mp4ScaleFactor;
          compositionTimeOffset = Math.round((avcSample.pts - avcSample.dts) / pes2mp4ScaleFactor);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / (pes2mp4ScaleFactor * mp4SampleDuration)));
        }

        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${this._initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration * pes2mp4ScaleFactor;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
      track.samples = [];

      var data = {
        id: this.id,
        level: this.level,
        sn: this.sn,
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / pesTimeScale,
        endPTS: (lastPTS + pes2mp4ScaleFactor * mp4SampleDuration) / pesTimeScale,
        startDTS: firstDTS / pesTimeScale,
        endDTS: this.nextAvcDts / pesTimeScale,
        type: 'video',
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,
          expectedSampleDuration = track.timescale * 1024 / track.audiosamplerate;
      var view,
          offset = 8,
          aacSample,
          mp4Sample,
          unit,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          lastDTS,
          pts,
          dts,
          ptsnorm,
          dtsnorm,
          samples = [],
          samples0 = [],
          fillFrame,
          newStamp;

      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });
      samples0 = track.samples;

      var nextAacPts = contiguous ? this.nextAacPts : timeOffset * pesTimeScale;

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.
      var pesFrameDuration = expectedSampleDuration * pes2mp4ScaleFactor;
      var nextPtsNorm = nextAacPts;
      for (var i = 0; i < samples0.length;) {
        // First, let's see how far off this frame is from where we expect it to be
        var sample = samples0[i],
            ptsNorm = this._PTSNormalize(sample.pts - this._initDTS, nextAacPts),
            delta = ptsNorm - nextPtsNorm;

        // If we're overlapping by more than half a duration, drop this sample
        if (delta < -0.5 * pesFrameDuration) {
          _logger.logger.log('Dropping frame due to ' + Math.round(Math.abs(delta / 90)) + ' ms overlap.');
          samples0.splice(i, 1);
          track.len -= sample.unit.length;
          // Don't touch nextPtsNorm or i
        }
        // Otherwise, if we're more than half a frame away from where we should be, insert missing frames
        else if (delta > 0.5 * pesFrameDuration) {
            var missing = Math.round(delta / pesFrameDuration);
            _logger.logger.log('Injecting ' + missing + ' frame' + (missing > 1 ? 's' : '') + ' of missing audio due to ' + Math.round(delta / 90) + ' ms gap.');
            for (var j = 0; j < missing; j++) {
              newStamp = sample.pts - (missing - j) * pesFrameDuration;
              newStamp = Math.max(newStamp, this._initDTS);
              fillFrame = _aac2.default.getSilentFrame(track.channelCount);
              if (!fillFrame) {
                _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                fillFrame = sample.unit.slice(0);
              }
              samples0.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
              track.len += fillFrame.length;
              i += 1;
            }

            // Adjust sample to next expected pts
            sample.pts = samples0[i - 1].pts + pesFrameDuration;
            nextPtsNorm = this._PTSNormalize(sample.pts + pesFrameDuration - this._initDTS, nextAacPts);
            i += 1;
          }
          // Otherwise, we're within half a frame duration, so just adjust pts
          else {
              if (Math.abs(delta) > 0.1 * pesFrameDuration) {
                _logger.logger.log('Invalid frame delta ' + Math.round(ptsNorm - nextPtsNorm + pesFrameDuration) + ' at PTS ' + Math.round(ptsNorm / 90) + ' (should be ' + Math.round(pesFrameDuration) + ').');
              }
              nextPtsNorm += pesFrameDuration;
              if (i === 0) {
                sample.pts = this._initDTS + nextAacPts;
              } else {
                sample.pts = samples0[i - 1].pts + pesFrameDuration;
              }
              i += 1;
            }
      }

      while (samples0.length) {
        aacSample = samples0.shift();
        unit = aacSample.unit;
        pts = aacSample.pts - this._initDTS;
        dts = aacSample.dts - this._initDTS;
        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastDTS !== undefined) {
          ptsnorm = this._PTSNormalize(pts, lastDTS);
          dtsnorm = this._PTSNormalize(dts, lastDTS);
          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / pes2mp4ScaleFactor);
        } else {
          ptsnorm = this._PTSNormalize(pts, nextAacPts);
          dtsnorm = this._PTSNormalize(dts, nextAacPts);
          var _delta = Math.round(1000 * (ptsnorm - nextAacPts) / pesTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          if (contiguous) {
            // log delta
            if (_delta) {
              if (_delta > 0) {
                numMissingFrames = Math.round((ptsnorm - nextAacPts) / pesFrameDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aac2.default.getSilentFrame(track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.slice(0);
                  }
                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              ptsnorm = dtsnorm = nextAacPts;
            }
          }
          // remember first PTS of our aacSamples, ensure value is positive
          firstPTS = Math.max(0, ptsnorm);
          firstDTS = Math.max(0, dtsnorm);
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            mdat = new Uint8Array(track.len + 8);
            view = new DataView(mdat.buffer);
            view.setUint32(0, mdat.byteLength);
            mdat.set(_mp4Generator2.default.types.mdat, 4);
          } else {
            // no audio samples
            return;
          }
          for (i = 0; i < numMissingFrames; i++) {
            newStamp = ptsnorm - (numMissingFrames - i) * pesFrameDuration;
            fillFrame = _aac2.default.getSilentFrame(track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.slice(0);
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            samples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        offset += unit.byteLength;
        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${aacSample.pts}/${aacSample.dts}/${this._initDTS}/${ptsnorm}/${dtsnorm}/${(aacSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unit.byteLength,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        samples.push(mp4Sample);
        lastDTS = dtsnorm;
      }
      var lastSampleDuration = 0;
      var nbSamples = samples.length;
      //set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = samples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next aac sample PTS should be equal to last sample PTS + duration
        this.nextAacPts = ptsnorm + pes2mp4ScaleFactor * lastSampleDuration;
        //logger.log('Audio/PTS/PTSend:' + aacSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = samples;
        moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
        track.samples = [];
        var audioData = {
          id: this.id,
          level: this.level,
          sn: this.sn,
          data1: moof,
          data2: mdat,
          startPTS: firstPTS / pesTimeScale,
          endPTS: this.nextAacPts / pesTimeScale,
          startDTS: firstDTS / pesTimeScale,
          endDTS: (dtsnorm + pes2mp4ScaleFactor * lastSampleDuration) / pesTimeScale,
          type: 'audio',
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale ? track.timescale : track.audiosamplerate,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,


      // sync with video's timestamp
      startDTS = videoData.startDTS * pesTimeScale + this._initDTS,
          endDTS = videoData.endDTS * pesTimeScale + this._initDTS,


      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = pes2mp4ScaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aac2.default.getSilentFrame(track.channelCount);

      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame.slice(0), pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track, timeOffset) {
      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
          sample.dts = (sample.dts - this._initDTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track, timeOffset) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset;
      if (reference === undefined) {
        return value;
      }
      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return false;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

},{"../errors":27,"../events":29,"../helper/aac":30,"../remux/mp4-generator":38,"../utils/logger":46,"../utils/polyfill":47}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer, id) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
    this.id = id;
    this.ISGenerated = false;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {}
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, rawData) {
      var observer = this.observer;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        var tracks = {},
            data = { id: this.id, tracks: tracks, unique: true },
            track = videoTrack,
            codec = track.codec;

        if (codec) {
          data.tracks.video = {
            container: track.container,
            codec: codec,
            metadata: {
              width: track.width,
              height: track.height
            }
          };
        }

        track = audioTrack;
        codec = track.codec;
        if (codec) {
          data.tracks.audio = {
            container: track.container,
            codec: codec,
            metadata: {
              channelCount: track.channelCount
            }
          };
        }
        this.ISGenerated = true;
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
      }
      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        id: this.id,
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: 'audiovideo',
        nb: 1,
        dropped: 0
      });
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return true;
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

},{"../events":29}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = /^(\d+)x(\d+)$/.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var re = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
      var match,
          attrs = {};
      while ((match = re.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;

},{}],42:[function(require,module,exports){
"use strict";

var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

module.exports = BinarySearch;

},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 32;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        _classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    _createClass(PenState, [{
        key: 'reset',
        value: function reset() {
            this.foreground = 'white';
            this.underline = false;
            this.italics = false;
            this.background = 'black';
            this.flash = false;
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
            for (var i = 0; i < attribs.length; i++) {
                var style = attribs[i];
                if (styles.hasOwnProperty(style)) {
                    this[style] = styles[style];
                }
            }
        }
    }, {
        key: 'isDefault',
        value: function isDefault() {
            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        }
    }, {
        key: 'copy',
        value: function copy(newPenState) {
            this.foreground = newPenState.foreground;
            this.underline = newPenState.underline;
            this.italics = newPenState.italics;
            this.background = newPenState.background;
            this.flash = newPenState.flash;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
        }
    }]);

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        _classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    _createClass(StyledUnicodeChar, [{
        key: 'reset',
        value: function reset() {
            this.uchar = ' ';
            this.penState.reset();
        }
    }, {
        key: 'setChar',
        value: function setChar(uchar, newPenState) {
            this.uchar = uchar;
            this.penState.copy(newPenState);
        }
    }, {
        key: 'setPenState',
        value: function setPenState(newPenState) {
            this.penState.copy(newPenState);
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.uchar === other.uchar && this.penState.equals(other.penState);
        }
    }, {
        key: 'copy',
        value: function copy(newChar) {
            this.uchar = newChar.uchar;
            this.penState.copy(newChar.penState);
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this.uchar === ' ' && this.penState.isDefault();
        }
    }]);

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        _classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    _createClass(Row, [{
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].equals(other.chars[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_COLS; i++) {
                this.chars[i].copy(other.chars[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }

        /**
         *  Set the cursor to a valid column.
         */

    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            if (this.pos !== absPos) {
                this.pos = absPos;
            }
            if (this.pos < 0) {
                logger.log('ERROR', 'Negative cursor position ' + this.pos);
                this.pos = 0;
            } else if (this.pos > NR_COLS) {
                logger.log('ERROR', 'Too large cursor position ' + this.pos);
                this.pos = NR_COLS;
            }
        }

        /**
         * Move the cursor relative to current position.
         */

    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var newPos = this.pos + relPos;
            if (relPos > 1) {
                for (var i = this.pos + 1; i < newPos + 1; i++) {
                    this.chars[i].setPenState(this.currPenState);
                }
            }
            this.setCursor(newPos);
        }

        /**
         * Backspace, move one step back and clear character.
         */

    }, {
        key: 'backSpace',
        value: function backSpace() {
            this.moveCursor(-1);
            this.chars[this.pos].setChar(' ', this.currPenState);
        }
    }, {
        key: 'insertChar',
        value: function insertChar(byte) {
            if (byte >= 0x90) {
                //Extended char
                this.backSpace();
            }
            var char = getCharForByte(byte);
            if (this.pos >= NR_COLS) {
                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                return;
            }
            this.chars[this.pos].setChar(char, this.currPenState);
            this.moveCursor(1);
        }
    }, {
        key: 'clearFromPos',
        value: function clearFromPos(startPos) {
            var i;
            for (i = startPos; i < NR_COLS; i++) {
                this.chars[i].reset();
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clearFromPos(0);
            this.pos = 0;
            this.currPenState.reset();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            this.clearFromPos(this.pos);
        }
    }, {
        key: 'getTextString',
        value: function getTextString() {
            var chars = [];
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                var char = this.chars[i].uchar;
                if (char !== ' ') {
                    empty = false;
                }
                chars.push(char);
            }
            if (empty) {
                return '';
            } else {
                return chars.join('');
            }
        }
    }, {
        key: 'setPenStyles',
        value: function setPenStyles(styles) {
            this.currPenState.setStyles(styles);
            var currChar = this.chars[this.pos];
            currChar.setPenState(this.currPenState);
        }
    }]);

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        _classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    _createClass(CaptionScreen, [{
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            this.currRow = NR_ROWS - 1;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].equals(other.rows[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].copy(other.rows[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }
    }, {
        key: 'backSpace',
        value: function backSpace() {
            var row = this.rows[this.currRow];
            row.backSpace();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            var row = this.rows[this.currRow];
            row.clearToEndOfRow();
        }

        /**
         * Insert a character (without styling) in the current row.
         */

    }, {
        key: 'insertChar',
        value: function insertChar(char) {
            var row = this.rows[this.currRow];
            row.insertChar(char);
        }
    }, {
        key: 'setPen',
        value: function setPen(styles) {
            var row = this.rows[this.currRow];
            row.setPenStyles(styles);
        }
    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var row = this.rows[this.currRow];
            row.moveCursor(relPos);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            logger.log('INFO', 'setCursor: ' + absPos);
            var row = this.rows[this.currRow];
            row.setCursor(absPos);
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
            var newRow = pacData.row - 1;
            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                newRow = this.nrRollUpRows - 1;
            }
            this.currRow = newRow;
            var row = this.rows[this.currRow];
            if (pacData.indent !== null) {
                var indent = pacData.indent;
                var prevPos = Math.max(indent - 1, 0);
                row.setCursor(pacData.indent);
                pacData.color = row.chars[prevPos].penState.foreground;
            }
            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
            this.setPen(styles);
        }

        /**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */

    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {

            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
            this.backSpace();
            this.setPen(bkgData);
            this.insertChar(0x20); //Space
        }
    }, {
        key: 'setRollUpRows',
        value: function setRollUpRows(nrRows) {
            this.nrRollUpRows = nrRows;
        }
    }, {
        key: 'rollUp',
        value: function rollUp() {
            if (this.nrRollUpRows === null) {
                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                return; //Not properly setup
            }
            logger.log('TEXT', this.getDisplayText());
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var topRow = this.rows.splice(topRowIndex, 1)[0];
            topRow.clear();
            this.rows.splice(this.currRow, 0, topRow);
            logger.log('INFO', 'Rolling up');
            //logger.log('TEXT', this.get_display_text())
        }

        /**
         * Get all non-empty rows with as unicode text.
         */

    }, {
        key: 'getDisplayText',
        value: function getDisplayText(asOneRow) {
            asOneRow = asOneRow || false;
            var displayText = [];
            var text = '';
            var rowNr = -1;
            for (var i = 0; i < NR_ROWS; i++) {
                var rowText = this.rows[i].getTextString();
                if (rowText) {
                    rowNr = i + 1;
                    if (asOneRow) {
                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                    } else {
                        displayText.push(rowText.trim());
                    }
                }
            }
            if (displayText.length > 0) {
                if (asOneRow) {
                    text = '[' + displayText.join(' | ') + ']';
                } else {
                    text = displayText.join('\n');
                }
            }
            return text;
        }
    }, {
        key: 'getTextAndFormat',
        value: function getTextAndFormat() {
            return this.rows;
        }
    }]);

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        _classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    _createClass(Cea608Channel, [{
        key: 'reset',
        value: function reset() {
            this.mode = null;
            this.displayedMemory.reset();
            this.nonDisplayedMemory.reset();
            this.lastOutputScreen.reset();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null;
            this.lastCueEndTime = null;
        }
    }, {
        key: 'getHandler',
        value: function getHandler() {
            return this.outputFilter;
        }
    }, {
        key: 'setHandler',
        value: function setHandler(newHandler) {
            this.outputFilter = newHandler;
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            this.writeScreen.setPAC(pacData);
        }
    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {
            this.writeScreen.setBkgData(bkgData);
        }
    }, {
        key: 'setMode',
        value: function setMode(newMode) {
            if (newMode === this.mode) {
                return;
            }
            this.mode = newMode;
            logger.log('INFO', 'MODE=' + newMode);
            if (this.mode === 'MODE_POP-ON') {
                this.writeScreen = this.nonDisplayedMemory;
            } else {
                this.writeScreen = this.displayedMemory;
                this.writeScreen.reset();
            }
            if (this.mode !== 'MODE_ROLL-UP') {
                this.displayedMemory.nrRollUpRows = null;
                this.nonDisplayedMemory.nrRollUpRows = null;
            }
            this.mode = newMode;
        }
    }, {
        key: 'insertChars',
        value: function insertChars(chars) {
            for (var i = 0; i < chars.length; i++) {
                this.writeScreen.insertChar(chars[i]);
            }
            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccRCL',
        value: function ccRCL() {
            // Resume Caption Loading (switch mode to Pop On)
            logger.log('INFO', 'RCL - Resume Caption Loading');
            this.setMode('MODE_POP-ON');
        }
    }, {
        key: 'ccBS',
        value: function ccBS() {
            // BackSpace
            logger.log('INFO', 'BS - BackSpace');
            if (this.mode === 'MODE_TEXT') {
                return;
            }
            this.writeScreen.backSpace();
            if (this.writeScreen === this.displayedMemory) {
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccAOF',
        value: function ccAOF() {
            // Reserved (formerly Alarm Off)
            return;
        }
    }, {
        key: 'ccAON',
        value: function ccAON() {
            // Reserved (formerly Alarm On)
            return;
        }
    }, {
        key: 'ccDER',
        value: function ccDER() {
            // Delete to End of Row
            logger.log('INFO', 'DER- Delete to End of Row');
            this.writeScreen.clearToEndOfRow();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccRU',
        value: function ccRU(nrRows) {
            //Roll-Up Captions-2,3,or 4 Rows
            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
            this.writeScreen = this.displayedMemory;
            this.setMode('MODE_ROLL-UP');
            this.writeScreen.setRollUpRows(nrRows);
        }
    }, {
        key: 'ccFON',
        value: function ccFON() {
            //Flash On
            logger.log('INFO', 'FON - Flash On');
            this.writeScreen.setPen({ flash: true });
        }
    }, {
        key: 'ccRDC',
        value: function ccRDC() {
            // Resume Direct Captioning (switch mode to PaintOn)
            logger.log('INFO', 'RDC - Resume Direct Captioning');
            this.setMode('MODE_PAINT-ON');
        }
    }, {
        key: 'ccTR',
        value: function ccTR() {
            // Text Restart in text mode (not supported, however)
            logger.log('INFO', 'TR');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccRTD',
        value: function ccRTD() {
            // Resume Text Display in Text mode (not supported, however)
            logger.log('INFO', 'RTD');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccEDM',
        value: function ccEDM() {
            // Erase Displayed Memory
            logger.log('INFO', 'EDM - Erase Displayed Memory');
            this.displayedMemory.reset();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccCR',
        value: function ccCR() {
            // Carriage Return
            logger.log('CR - Carriage Return');
            this.writeScreen.rollUp();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccENM',
        value: function ccENM() {
            //Erase Non-Displayed Memory
            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
            this.nonDisplayedMemory.reset();
        }
    }, {
        key: 'ccEOC',
        value: function ccEOC() {
            //End of Caption (Flip Memories)
            logger.log('INFO', 'EOC - End Of Caption');
            if (this.mode === 'MODE_POP-ON') {
                var tmp = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory;
                this.nonDisplayedMemory = tmp;
                this.writeScreen = this.nonDisplayedMemory;
                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate();
        }
    }, {
        key: 'ccTO',
        value: function ccTO(nrCols) {
            // Tab Offset 1,2, or 3 columns
            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
            this.writeScreen.moveCursor(nrCols);
        }
    }, {
        key: 'ccMIDROW',
        value: function ccMIDROW(secondByte) {
            // Parse MIDROW command
            var styles = { flash: false };
            styles.underline = secondByte % 2 === 1;
            styles.italics = secondByte >= 0x2e;
            if (!styles.italics) {
                var colorIndex = Math.floor(secondByte / 2) - 0x10;
                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                styles.foreground = colors[colorIndex];
            } else {
                styles.foreground = 'white';
            }
            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
            this.writeScreen.setPen(styles);
        }
    }, {
        key: 'outputDataUpdate',
        value: function outputDataUpdate() {
            var t = logger.time;
            if (t === null) {
                return;
            }
            if (this.outputFilter) {
                if (this.outputFilter.updateData) {
                    this.outputFilter.updateData(t, this.displayedMemory);
                }
                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                    // Start of a new cue
                    this.cueStartTime = t;
                } else {
                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                    }
                }
                this.lastOutputScreen.copy(this.displayedMemory);
            }
        }
    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            if (this.outputFilter) {
                if (!this.displayedMemory.isEmpty()) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                    }
                    this.cueStartTime = t;
                }
            }
        }
    }]);

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        _classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    _createClass(Cea608Parser, [{
        key: 'getHandler',
        value: function getHandler(index) {
            return this.channels[index].getHandler();
        }
    }, {
        key: 'setHandler',
        value: function setHandler(index, newHandler) {
            this.channels[index].setHandler(newHandler);
        }

        /**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */

    }, {
        key: 'addData',
        value: function addData(t, byteList) {
            var cmdFound,
                a,
                b,
                charsFound = false;

            this.lastTime = t;
            logger.setTime(t);

            for (var i = 0; i < byteList.length; i += 2) {
                a = byteList[i] & 0x7f;
                b = byteList[i + 1] & 0x7f;
                if (a === 0 && b === 0) {
                    this.dataCounters.padding += 2;
                    continue;
                } else {
                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                }
                cmdFound = this.parseCmd(a, b);
                if (!cmdFound) {
                    cmdFound = this.parseMidrow(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parsePAC(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parseBackgroundAttributes(a, b);
                }
                if (!cmdFound) {
                    charsFound = this.parseChars(a, b);
                    if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                            var channel = this.channels[this.currChNr - 1];
                            channel.insertChars(charsFound);
                        } else {
                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                        }
                    }
                }
                if (cmdFound) {
                    this.dataCounters.cmd += 2;
                } else if (charsFound) {
                    this.dataCounters.char += 2;
                } else {
                    this.dataCounters.other += 2;
                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                }
            }
        }

        /**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */

    }, {
        key: 'parseCmd',
        value: function parseCmd(a, b) {
            var chNr = null;

            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
            if (!(cond1 || cond2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null; // Repeated commands are dropped (once)
                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                return true;
            }

            if (a === 0x14 || a === 0x17) {
                chNr = 1;
            } else {
                chNr = 2; // (a === 0x1C || a=== 0x1f)
            }

            var channel = this.channels[chNr - 1];

            if (a === 0x14 || a === 0x1C) {
                if (b === 0x20) {
                    channel.ccRCL();
                } else if (b === 0x21) {
                    channel.ccBS();
                } else if (b === 0x22) {
                    channel.ccAOF();
                } else if (b === 0x23) {
                    channel.ccAON();
                } else if (b === 0x24) {
                    channel.ccDER();
                } else if (b === 0x25) {
                    channel.ccRU(2);
                } else if (b === 0x26) {
                    channel.ccRU(3);
                } else if (b === 0x27) {
                    channel.ccRU(4);
                } else if (b === 0x28) {
                    channel.ccFON();
                } else if (b === 0x29) {
                    channel.ccRDC();
                } else if (b === 0x2A) {
                    channel.ccTR();
                } else if (b === 0x2B) {
                    channel.ccRTD();
                } else if (b === 0x2C) {
                    channel.ccEDM();
                } else if (b === 0x2D) {
                    channel.ccCR();
                } else if (b === 0x2E) {
                    channel.ccENM();
                } else if (b === 0x2F) {
                    channel.ccEOC();
                }
            } else {
                //a == 0x17 || a == 0x1F
                channel.ccTO(b - 0x20);
            }
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Parse midrow styling command
         * @returns {Boolean}
         */

    }, {
        key: 'parseMidrow',
        value: function parseMidrow(a, b) {
            var chNr = null;

            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                if (a === 0x11) {
                    chNr = 1;
                } else {
                    chNr = 2;
                }
                if (chNr !== this.currChNr) {
                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
                    return false;
                }
                var channel = this.channels[chNr - 1];
                channel.ccMIDROW(b);
                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                return true;
            }
            return false;
        }
        /**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */

    }, {
        key: 'parsePAC',
        value: function parsePAC(a, b) {

            var chNr = null;
            var row = null;

            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
            if (!(case1 || case2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true; // Repeated commands are dropped (once)
            }

            chNr = a <= 0x17 ? 1 : 2;

            if (0x40 <= b && b <= 0x5F) {
                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
            } else {
                // 0x60 <= b <= 0x7F
                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
            }
            var pacData = this.interpretPAC(row, b);
            var channel = this.channels[chNr - 1];
            channel.setPAC(pacData);
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */

    }, {
        key: 'interpretPAC',
        value: function interpretPAC(row, byte) {
            var pacIndex = byte;
            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

            if (byte > 0x5F) {
                pacIndex = byte - 0x60;
            } else {
                pacIndex = byte - 0x40;
            }
            pacData.underline = (pacIndex & 1) === 1;
            if (pacIndex <= 0xd) {
                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
            } else if (pacIndex <= 0xf) {
                pacData.italics = true;
                pacData.color = 'white';
            } else {
                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
            }
            return pacData; // Note that row has zero offset. The spec uses 1.
        }

        /**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */

    }, {
        key: 'parseChars',
        value: function parseChars(a, b) {

            var channelNr = null,
                charCodes = null,
                charCode1 = null;

            if (a >= 0x19) {
                channelNr = 2;
                charCode1 = a - 8;
            } else {
                channelNr = 1;
                charCode1 = a;
            }
            if (0x11 <= charCode1 && charCode1 <= 0x13) {
                // Special character
                var oneCode = b;
                if (charCode1 === 0x11) {
                    oneCode = b + 0x50;
                } else if (charCode1 === 0x12) {
                    oneCode = b + 0x70;
                } else {
                    oneCode = b + 0x90;
                }
                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                charCodes = [oneCode];
            } else if (0x20 <= a && a <= 0x7f) {
                charCodes = b === 0 ? [a] : [a, b];
            }
            if (charCodes) {
                var hexCodes = numArrayToHexArray(charCodes);
                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
            return charCodes;
        }

        /**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */

    }, {
        key: 'parseBackgroundAttributes',
        value: function parseBackgroundAttributes(a, b) {
            var bkgData, index, chNr, channel;

            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
            if (!(case1 || case2)) {
                return false;
            }
            bkgData = {};
            if (a === 0x10 || a === 0x18) {
                index = Math.floor((b - 0x20) / 2);
                bkgData.background = backgroundColors[index];
                if (b % 2 === 1) {
                    bkgData.background = bkgData.background + '_semi';
                }
            } else if (b === 0x2d) {
                bkgData.background = 'transparent';
            } else {
                bkgData.foreground = 'black';
                if (b === 0x2f) {
                    bkgData.underline = true;
                }
            }
            chNr = a < 0x18 ? 1 : 2;
            channel = this.channels[chNr - 1];
            channel.setBkgData(bkgData);
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true;
        }

        /**
         * Reset state of parser and its channels.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].reset();
                }
            }
            this.lastCmdA = null;
            this.lastCmdB = null;
        }

        /**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */

    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].cueSplitAtTime(t);
                }
            }
        }
    }]);

    return Cea608Parser;
}();

exports.default = Cea608Parser;

},{}],44:[function(require,module,exports){
'use strict';

var Cues = {

  newCue: function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;

    for (var r = 0; r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = '';

      if (!row.isEmpty()) {
        for (var c = 0; c < row.chars.length; c++) {
          if (row.chars[c].uchar.match(/\s/) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        cue = new VTTCue(startTime, endTime, text.trim());

        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }

        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
        // also, drop line 1 since it's to close to the top
        if (navigator.userAgent.match(/Firefox\//)) {
          cue.line = r + 1;
        } else {
          cue.line = r > 7 ? r - 2 : r + 1;
        }
        cue.align = 'left';
        cue.position = 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0);
        track.addCue(cue);
      }
    }
  }

};

module.exports = Cues;

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = window.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(window.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

},{}],47:[function(require,module,exports){
'use strict';

if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
  ArrayBuffer.prototype.slice = function (start, end) {
    var that = new Uint8Array(this);
    if (end === undefined) {
      end = that.length;
    }
    var result = new ArrayBuffer(end - start);
    var resultArray = new Uint8Array(result);
    for (var i = 0; i < resultArray.length; i++) {
      resultArray[i] = that[i + start];
    }
    return result;
  };
}

if (typeof Uint8Array !== 'undefined' && !Uint8Array.prototype.concat) {
  Uint8Array.prototype.concat = function () {
    var that = this;
    var totalLength = that.length;

    for (var _len = arguments.length, arrays = Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = arrays[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var arr = _step.value;

        totalLength += arr.byteLength;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var result = new Uint8Array(totalLength);
    var offset = 0;
    result.set(that, offset);
    offset += that.length;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = arrays[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _arr = _step2.value;

        result.set(_arr, offset);
        offset += _arr.byteLength;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return result;
  };
}

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  TimeRanges to string helper
 */

var TimeRanges = function () {
  function TimeRanges() {
    _classCallCheck(this, TimeRanges);
  }

  _createClass(TimeRanges, null, [{
    key: 'toString',
    value: function toString(r) {
      var log = '',
          len = r.length;
      for (var i = 0; i < len; i++) {
        log += '[' + r.start(i) + ',' + r.end(i) + ']';
      }
      return log;
    }
  }]);

  return TimeRanges;
}();

exports.default = TimeRanges;

},{}],49:[function(require,module,exports){
'use strict';

var URLHelper = {
  // build an absolute URL from a relative one using the provided baseURL
  // if relativeURL is an absolute URL it will be returned as is.
  buildAbsoluteURL: function buildAbsoluteURL(baseURL, relativeURL) {
    // remove any remaining space and CRLF
    relativeURL = relativeURL.trim();
    if (/^[a-z]+:/i.test(relativeURL)) {
      // complete url, not relative
      return relativeURL;
    }

    var relativeURLQuery = null;
    var relativeURLHash = null;

    var relativeURLHashSplit = /^([^#]*)(.*)$/.exec(relativeURL);
    if (relativeURLHashSplit) {
      relativeURLHash = relativeURLHashSplit[2];
      relativeURL = relativeURLHashSplit[1];
    }
    var relativeURLQuerySplit = /^([^\?]*)(.*)$/.exec(relativeURL);
    if (relativeURLQuerySplit) {
      relativeURLQuery = relativeURLQuerySplit[2];
      relativeURL = relativeURLQuerySplit[1];
    }

    var baseURLHashSplit = /^([^#]*)(.*)$/.exec(baseURL);
    if (baseURLHashSplit) {
      baseURL = baseURLHashSplit[1];
    }
    var baseURLQuerySplit = /^([^\?]*)(.*)$/.exec(baseURL);
    if (baseURLQuerySplit) {
      baseURL = baseURLQuerySplit[1];
    }

    var baseURLDomainSplit = /^(([a-z]+:)?\/\/[a-z0-9\.\-_~]+(:[0-9]+)?)?(\/.*)$/i.exec(baseURL);
    if (!baseURLDomainSplit) {
      throw new Error('Error trying to parse base URL.');
    }

    // e.g. 'http:', 'https:', ''
    var baseURLProtocol = baseURLDomainSplit[2] || '';
    // e.g. 'http://example.com', '//example.com', ''
    var baseURLProtocolDomain = baseURLDomainSplit[1] || '';
    // e.g. '/a/b/c/playlist.m3u8'
    var baseURLPath = baseURLDomainSplit[4];

    var builtURL = null;
    if (/^\/\//.test(relativeURL)) {
      // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)
      builtURL = baseURLProtocol + '//' + URLHelper.buildAbsolutePath('', relativeURL.substring(2));
    } else if (/^\//.test(relativeURL)) {
      // relative url starts with '/' so start from root of domain
      builtURL = baseURLProtocolDomain + '/' + URLHelper.buildAbsolutePath('', relativeURL.substring(1));
    } else {
      builtURL = URLHelper.buildAbsolutePath(baseURLProtocolDomain + baseURLPath, relativeURL);
    }

    // put the query and hash parts back
    if (relativeURLQuery) {
      builtURL += relativeURLQuery;
    }
    if (relativeURLHash) {
      builtURL += relativeURLHash;
    }
    return builtURL;
  },

  // build an absolute path using the provided basePath
  // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter
  // this does not handle the case where relativePath is "/" or "//". These cases should be handled outside this.
  buildAbsolutePath: function buildAbsolutePath(basePath, relativePath) {
    var sRelPath = relativePath;
    var nUpLn,
        sDir = '',
        sPath = basePath.replace(/[^\/]*$/, sRelPath.replace(/(\/|^)(?:\.?\/+)+/g, '$1'));
    for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {
      nUpLn = /^\/(?:\.\.\/)*/.exec(sPath.slice(nEnd))[0].length;
      sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\/+[^\\\/]*){0,' + (nUpLn - 1) / 3 + '}$'), '/');
    }
    return sDir + sPath.substr(nStart);
  }
};

module.exports = URLHelper;

},{}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr,
          context = this.context;

      if (typeof XDomainRequest !== 'undefined') {
        xhr = this.loader = new XDomainRequest();
      } else {
        xhr = this.loader = new XMLHttpRequest();
      }

      xhr.onloadend = this.loadend.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);

      xhr.open('GET', context.url, true);

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.responseType = context.responseType;
      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      if (this.xhrSetup) {
        this.xhrSetup(xhr, context.url);
      }
      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'loadend',
    value: function loadend(event) {
      var xhr = event.currentTarget,
          status = xhr.status,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // in any case clear the current xhrs timeout
      window.clearTimeout(this.requestTimeout);

      // http status between 200 to 299 are all successful
      if (status >= 200 && status < 300) {
        stats.tload = Math.max(stats.tfirst, performance.now());
        var data = void 0,
            len = void 0;
        if (context.responseType === 'arraybuffer') {
          data = xhr.response;
          len = data.byteLength;
        } else {
          data = xhr.responseText;
          len = data.length;
        }
        stats.loaded = stats.total = len;
        var response = { url: xhr.responseURL, data: data };
        this.callbacks.onSuccess(response, stats, context);
      } else {
        // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
        if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
          _logger.logger.error(status + ' while loading ' + context.url);
          this.callbacks.onError({ code: status, text: xhr.statusText }, context);
        } else {
          // retry
          _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
          // aborts and resets internal state
          this.destroy();
          // schedule retry
          this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
          // set exponential backoff
          this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
          stats.retry++;
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var stats = this.stats;
      if (stats.tfirst === 0) {
        stats.tfirst = Math.max(performance.now(), stats.trequest);
      }
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // last args is to provide on progress data
        onProgress(stats, this.context, null);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;

},{"../utils/logger":46}]},{},[34])(34)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5L2luZGV4LmpzIiwic3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLmpzIiwic3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLmpzIiwic3JjL2NyeXB0L2Flcy5qcyIsInNyYy9jcnlwdC9hZXMxMjgtZGVjcnlwdGVyLmpzIiwic3JjL2NyeXB0L2RlY3J5cHRlci5qcyIsInNyYy9kZW11eC9hYWNkZW11eGVyLmpzIiwic3JjL2RlbXV4L2FkdHMuanMiLCJzcmMvZGVtdXgvZGVtdXhlci1pbmxpbmUuanMiLCJzcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMiLCJzcmMvZGVtdXgvZGVtdXhlci5qcyIsInNyYy9kZW11eC9leHAtZ29sb21iLmpzIiwic3JjL2RlbXV4L2Zsdi1wYXJzZXIuanMiLCJzcmMvZGVtdXgvZmx2LXRhZy5qcyIsInNyYy9kZW11eC9mbHZkZW11eGVyLmpzIiwic3JjL2RlbXV4L2lkMy5qcyIsInNyYy9kZW11eC90c2RlbXV4ZXIuanMiLCJzcmMvZXJyb3JzLmpzIiwic3JjL2V2ZW50LWhhbmRsZXIuanMiLCJzcmMvZXZlbnRzLmpzIiwic3JjL2hlbHBlci9hYWMuanMiLCJzcmMvaGVscGVyL2J1ZmZlci1oZWxwZXIuanMiLCJzcmMvaGVscGVyL2xldmVsLWhlbHBlci5qcyIsInNyYy9obHMuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci5qcyIsInNyYy9sb2FkZXIva2V5LWxvYWRlci5qcyIsInNyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLmpzIiwic3JjL3JlbXV4L21wNC1nZW5lcmF0b3IuanMiLCJzcmMvcmVtdXgvbXA0LXJlbXV4ZXIuanMiLCJzcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qcyIsInNyYy91dGlscy9hdHRyLWxpc3QuanMiLCJzcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC5qcyIsInNyYy91dGlscy9jZWEtNjA4LXBhcnNlci5qcyIsInNyYy91dGlscy9jdWVzLmpzIiwic3JjL3V0aWxzL2V3bWEuanMiLCJzcmMvdXRpbHMvbG9nZ2VyLmpzIiwic3JjL3V0aWxzL3BvbHlmaWxsLmpzIiwic3JjL3V0aWxzL3RpbWVSYW5nZXMuanMiLCJzcmMvdXRpbHMvdXJsLmpzIiwic3JjL3V0aWxzL3hoci1sb2FkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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WUFBTSxNQUFOLEdBQWUsTUFBTSxNQUFyQjtBQUNBLFVBQUksTUFBTSxnQkFBVixFQUE0QjtBQUMxQixjQUFNLEtBQU4sR0FBYyxNQUFNLEtBQXBCO0FBQ0Q7QUFDRCxVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsVUFBaEM7QUFDQSxVQUFJLFVBQUosRUFBZ0I7QUFDZDtBQUNBLG1CQUFXLEtBQVgsRUFBa0IsS0FBSyxPQUF2QixFQUFnQyxJQUFoQztBQUNEO0FBQ0Y7Ozs7OztrQkFHWSxTIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsInZhciBidW5kbGVGbiA9IGFyZ3VtZW50c1szXTtcbnZhciBzb3VyY2VzID0gYXJndW1lbnRzWzRdO1xudmFyIGNhY2hlID0gYXJndW1lbnRzWzVdO1xuXG52YXIgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgdmFyIHdrZXk7XG4gICAgdmFyIGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICB2YXIgZXhwID0gY2FjaGVba2V5XS5leHBvcnRzO1xuICAgICAgICAvLyBVc2luZyBiYWJlbCBhcyBhIHRyYW5zcGlsZXIgdG8gdXNlIGVzbW9kdWxlLCB0aGUgZXhwb3J0IHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBkZWZhdWx0IGV4cG9ydCBhcyBhIHByb3BlcnR5IG9mIGl0LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGFwaSBhbmQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0cyBhcmUgYm90aCBzdXBwb3J0ZWQgd2VcbiAgICAgICAgLy8gY2hlY2sgZm9yIGJvdGhcbiAgICAgICAgaWYgKGV4cCA9PT0gZm4gfHwgZXhwICYmIGV4cC5kZWZhdWx0ID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF3a2V5KSB7XG4gICAgICAgIHdrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIHdjYWNoZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgICAgICB3Y2FjaGVba2V5XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzW3drZXldID0gW1xuICAgICAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJywnbW9kdWxlJywnZXhwb3J0cyddLCAnKCcgKyBmbiArICcpKHNlbGYpJyksXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnXSwgKFxuICAgICAgICAgICAgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZVxuICAgICAgICAgICAgLy8gZXhwb3J0c1xuICAgICAgICAgICAgJ3ZhciBmID0gcmVxdWlyZSgnICsgc3RyaW5naWZ5KHdrZXkpICsgJyk7JyArXG4gICAgICAgICAgICAnKGYuZGVmYXVsdCA/IGYuZGVmYXVsdCA6IGYpKHNlbGYpOydcbiAgICAgICAgKSksXG4gICAgICAgIHNjYWNoZVxuICAgIF07XG5cbiAgICB2YXIgc3JjID0gJygnICsgYnVuZGxlRm4gKyAnKSh7J1xuICAgICAgICArIE9iamVjdC5rZXlzKHNvdXJjZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGtleSkgKyAnOlsnXG4gICAgICAgICAgICAgICAgKyBzb3VyY2VzW2tleV1bMF1cbiAgICAgICAgICAgICAgICArICcsJyArIHN0cmluZ2lmeShzb3VyY2VzW2tleV1bMV0pICsgJ10nXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pLmpvaW4oJywnKVxuICAgICAgICArICd9LHt9LFsnICsgc3RyaW5naWZ5KHNrZXkpICsgJ10pJ1xuICAgIDtcblxuICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYjsgfVxuICAgIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCk7XG4gICAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybDtcbiAgICByZXR1cm4gd29ya2VyO1xufTtcbiIsIi8qXG4gKiBzaW1wbGUgQUJSIENvbnRyb2xsZXJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcbiAqICAtIGltcGxlbWVudCBhbiBhYmFuZG9uIHJ1bGVzIHRyaWdnZXJlZCBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgYW5kIGlmIGNvbXB1dGVkIGJ3IHNob3dzIHRoYXQgd2UgcmlzayBidWZmZXIgc3RhbGxpbmdcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCB7RXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXdtYUJhbmRXaWR0aEVzdGltYXRvciBmcm9tICcuL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvcic7XG5cbmNsYXNzIEFickNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HLFxuICAgICAgICAgICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICAgICAgICAgICBFdmVudC5FUlJPUik7XG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMub25DaGVjayA9IHRoaXMuYWJhbmRvblJ1bGVzQ2hlY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgfVxuICAgICAgLy8gbGF6eSBpbml0IG9mIGJ3IEVzdGltYXRvciwgcmF0aW9uYWxlIGlzIHRoYXQgd2UgdXNlIGRpZmZlcmVudCBwYXJhbXMgZm9yIExpdmUvVm9EXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHN0cmVhbSBtYW5pZmVzdCAvIHBsYXlsaXN0IHR5cGUgdG8gaW5zdGFudGlhdGUgaXQuXG4gICAgICBpZiAoIXRoaXMuYndFc3RpbWF0b3IpIHtcbiAgICAgICAgbGV0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgICAgbGV2ZWwgPSBkYXRhLmZyYWcubGV2ZWwsXG4gICAgICAgICAgICBpc0xpdmUgPSBobHMubGV2ZWxzW2xldmVsXS5kZXRhaWxzLmxpdmUsXG4gICAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICAgICAgZXdtYUZhc3QsIGV3bWFTbG93O1xuXG4gICAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dMaXZlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93Vm9EO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3IgPSBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihobHMsZXdtYVNsb3csZXdtYUZhc3QsY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgfVxuICB9XG5cbiAgYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgLypcbiAgICAgIG1vbml0b3IgZnJhZ21lbnQgcmV0cmlldmFsIHRpbWUuLi5cbiAgICAgIHdlIGNvbXB1dGUgZXhwZWN0ZWQgdGltZSBvZiBhcnJpdmFsIG9mIHRoZSBjb21wbGV0ZSBmcmFnbWVudC5cbiAgICAgIHdlIGNvbXBhcmUgaXQgdG8gZXhwZWN0ZWQgdGltZSBvZiBidWZmZXIgc3RhcnZhdGlvblxuICAgICovXG4gICAgbGV0IGhscyA9IHRoaXMuaGxzLCB2ID0gaGxzLm1lZGlhLGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcblxuICAgIC8vIGlmIGxvYWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgb3IgbG9hZGluZyBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cbiAgICBpZighbG9hZGVyIHx8ICggbG9hZGVyLnN0YXRzICYmIGxvYWRlci5zdGF0cy5hYm9ydGVkKSkge1xuICAgICAgbG9nZ2VyLndhcm4oYGZyYWcgbG9hZGVyIGRlc3Ryb3kgb3IgYWJvcnRlZCwgZGlzYXJtIGFiYW5kb25SdWxlc0NoZWNrYCk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgIC8qIG9ubHkgbW9uaXRvciBmcmFnIHJldHJpZXZhbCB0aW1lIGlmXG4gICAgKHZpZGVvIG5vdCBwYXVzZWQgT1IgZmlyc3QgZnJhZ21lbnQgYmVpbmcgbG9hZGVkKHJlYWR5IHN0YXRlID09PSBIQVZFX05PVEhJTkcgPSAwKSkgQU5EIGF1dG9zd2l0Y2hpbmcgZW5hYmxlZCBBTkQgbm90IGxvd2VzdCBsZXZlbCAoPT4gbWVhbnMgdGhhdCB3ZSBoYXZlIHNldmVyYWwgbGV2ZWxzKSAqL1xuICAgIGlmICh2ICYmICgoIXYucGF1c2VkICYmICh2LnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2LnJlYWR5U3RhdGUpICYmIGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWwpIHtcbiAgICAgIGxldCByZXF1ZXN0RGVsYXkgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLnRyZXF1ZXN0LFxuICAgICAgICAgIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHYucGxheWJhY2tSYXRlKTtcbiAgICAgIC8vIG1vbml0b3IgZnJhZ21lbnQgbG9hZCBwcm9ncmVzcyBhZnRlciBoYWxmIG9mIGV4cGVjdGVkIGZyYWdtZW50IGR1cmF0aW9uLHRvIHN0YWJpbGl6ZSBiaXRyYXRlXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgICAgbG9hZFJhdGUgPSBNYXRoLm1heCgxLCBzdGF0cy5idyA/IHN0YXRzLmJ3IC8gOCA6IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyByZXF1ZXN0RGVsYXkpLCAvLyBieXRlL3M7IGF0IGxlYXN0IDEgYnl0ZS9zIHRvIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm9cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgPyBzdGF0cy50b3RhbCA6IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uICogbGV2ZWxzW2ZyYWcubGV2ZWxdLmJpdHJhdGUgLyA4KSksXG4gICAgICAgICAgICBwb3MgPSB2LmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLFxuICAgICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHYscG9zLGhscy5jb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgLy8gY29uc2lkZXIgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9ubHkgaWYgd2UgaGF2ZSBsZXNzIHRoYW4gMiBmcmFnIGJ1ZmZlcmVkIEFORFxuICAgICAgICAvLyB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIGN1cnJlbnQgZnJhZ21lbnQgaXMgYmlnZ2VyIHRoYW4gYnVmZmVyIHN0YXJ2YXRpb24gZGVsYXlcbiAgICAgICAgLy8gaWUgaWYgd2UgcmlzayBidWZmZXIgc3RhcnZhdGlvbiBpZiBidyBkb2VzIG5vdCBpbmNyZWFzZSBxdWlja2x5XG4gICAgICAgIGlmICgoYnVmZmVyU3RhcnZhdGlvbkRlbGF5IDwgKDIgKiBmcmFnLmR1cmF0aW9uIC8gcGxheWJhY2tSYXRlKSkgJiYgKGZyYWdMb2FkZWREZWxheSA+IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkpIHtcbiAgICAgICAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LCBuZXh0TG9hZExldmVsO1xuICAgICAgICAgIC8vIGxldHMgaXRlcmF0ZSB0aHJvdWdoIGxvd2VyIGxldmVsIGFuZCB0cnkgdG8gZmluZCB0aGUgYmlnZ2VzdCBvbmUgdGhhdCBjb3VsZCBhdm9pZCByZWJ1ZmZlcmluZ1xuICAgICAgICAgIC8vIHdlIHN0YXJ0IGZyb20gY3VycmVudCBsZXZlbCAtIDEgYW5kIHdlIHN0ZXAgZG93biAsIHVudGlsIHdlIGZpbmQgYSBtYXRjaGluZyBsZXZlbFxuICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxIDsgbmV4dExvYWRMZXZlbCA+PTAgOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSAvICg4ICogMC44ICogbG9hZFJhdGUpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZnJhZ0xvYWRlZERlbGF5L2J1ZmZlclN0YXJ2YXRpb25EZWxheS9mcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXlbJHtuZXh0TG9hZExldmVsfV0gOiR7ZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMSl9LyR7YnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMSl9LyR7ZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoMSl9YCk7XG4gICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbG93ZXIgbGV2ZWwgdGhhdCBiZSByZWJ1ZmZlcmluZyBmcmVlIHdpdGggY3VycmVudCBlc3RpbWF0ZWQgYncgIVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgZmluaXNoaW5nIGxvYWRpbmcgY3VycmVudCBvbmUgLi4uXG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIG5leHRMb2FkTGV2ZWwgaXMgbm90IG5lZ2F0aXZlXG4gICAgICAgICAgICBuZXh0TG9hZExldmVsID0gTWF0aC5tYXgoMCxuZXh0TG9hZExldmVsKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIG5leHQgbG9hZCBsZXZlbCBpbiBhdXRvIG1vZGVcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBidyBlc3RpbWF0ZSBmb3IgdGhpcyBmcmFnbWVudCBiZWZvcmUgY2FuY2VsbGluZyBsb2FkICh0aGlzIHdpbGwgaGVscCByZWR1Y2luZyB0aGUgYncpXG4gICAgICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShyZXF1ZXN0RGVsYXksc3RhdHMubG9hZGVkKTtcbiAgICAgICAgICAgIC8vIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgLi4uXG4gICAgICAgICAgICBsb2dnZXIud2FybihgbG9hZGluZyB0b28gc2xvdywgYWJvcnQgZnJhZ21lbnQgbG9hZGluZyBhbmQgc3dpdGNoIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH1gKTtcbiAgICAgICAgICAgIC8vYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7ZnJhZzogZnJhZ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBsZXQgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBsb2FkaW5nXG4gICAgICAvLyBpZiBzYW1lIGZyYWcgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLCBpdCBtaWdodCBiZSBpbiBicm93c2VyIGNhY2hlLCBhbmQgbG9hZGVkIHF1aWNrbHlcbiAgICAgIC8vIGFuZCBsZWFkaW5nIHRvIHdyb25nIGJ3IGVzdGltYXRpb25cbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkID09PSB1bmRlZmluZWQgJiYgZnJhZy5sb2FkQ291bnRlciA9PT0gMSkge1xuICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLnRyZXF1ZXN0LHN0YXRzLmxvYWRlZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihkYXRhKSB7XG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxuICAgIHN3aXRjaChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuIGNsZWFyVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gfVxuXG4gIC8qKiBSZXR1cm4gdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gIH1cblxuICAvKiogc2V0IHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXG4gIHNldCBhdXRvTGV2ZWxDYXBwaW5nKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICB9XG5cbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XG4gICAgbGV0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICB2ID0gaGxzLm1lZGlhLFxuICAgICAgICBpLCBtYXhBdXRvTGV2ZWw7XG4gICAgaWYgKHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QXV0b0xldmVsID0gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG5cbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIHJldHVybiBpdCBzdHJhaWdodC1hd2F5IChidXQgY2FwcGVkKVxuICAgIGlmICh0aGlzLl9uZXh0QXV0b0xldmVsICE9PSAtMSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuX25leHRBdXRvTGV2ZWwsbWF4QXV0b0xldmVsKTtcbiAgICB9XG4gICAgbGV0IHBsYXliYWNrUmF0ZSA9ICgodiAmJiB2LnBsYXliYWNrUmF0ZSAhPT0gMCkgPyBNYXRoLmFicyh2LnBsYXliYWNrUmF0ZSkgOiAxLjApLFxuICAgICAgICBhdmdidyA9IHRoaXMuYndFc3RpbWF0b3IgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkvcGxheWJhY2tSYXRlIDogY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUvcGxheWJhY2tSYXRlLFxuICAgICAgICBhZGp1c3RlZGJ3O1xuICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcbiAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG1heEF1dG9MZXZlbDsgaSsrKSB7XG4gICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxuICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoaSA8PSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwpIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IgKiBhdmdidztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3IgKiBhdmdidztcbiAgICAgIH1cbiAgICAgIGlmIChhZGp1c3RlZGJ3IDwgbGV2ZWxzW2ldLmJpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGkgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGkgLSAxO1xuICB9XG5cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBYnJDb250cm9sbGVyO1xuXG4iLCIvKlxuICogQXVkaW8gU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IExldmVsSGVscGVyIGZyb20gJy4uL2hlbHBlci9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZVJhbmdlcyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRCA6ICdTVE9QUEVEJyxcbiAgU1RBUlRJTkcgOiAnU1RBUlRJTkcnLFxuICBJRExFIDogJ0lETEUnLFxuICBQQVVTRUQgOiAnUEFVU0VEJyxcbiAgS0VZX0xPQURJTkcgOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkcgOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkgOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLIDogJ1dBSVRJTkdfVFJBQ0snLFxuICBQQVJTSU5HIDogJ1BBUlNJTkcnLFxuICBQQVJTRUQgOiAnUEFSU0VEJyxcbiAgRU5ERUQgOiAnRU5ERUQnLFxuICBFUlJPUiA6ICdFUlJPUidcbn07XG5cbmNsYXNzIEF1ZGlvU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVEKTtcblxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy50aWNrcyA9IDA7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG5cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy50cmFja3MpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBpZiAobWVkaWEgJiYgbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYGNvbmZpZ3VyZSBzdGFydFBvc2l0aW9uIEAke2xhc3RDdXJyZW50VGltZX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVEFSVElORztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCgpIHtcbiAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICB0aWNrKCkge1xuICAgIHRoaXMudGlja3MrKztcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB9XG4gIH1cblxuICBkb1RpY2soKSB7XG4gICAgdmFyIHBvcywgdHJhY2ssIHRyYWNrRGV0YWlscywgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgLy9sb2dnZXIubG9nKCdhdWRpb1N0cmVhbTonICsgdGhpcy5zdGF0ZSk7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICAgIGNhc2UgU3RhdGUuUEFVU0VEOlxuICAgICAgICAvL2Rvbid0IGRvIGFueXRoaW5nIGluIHBhdXNlZCBzdGF0ZSBlaXRoZXIgLi4uXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5TVEFSVElORzpcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAgICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgICAgIGlmICghdGhpcy5tZWRpYSAmJlxuICAgICAgICAgICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kXG4gICAgICAgIC8vICBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICAgICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICBwb3MgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEscG9zLGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgICAgICBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgICAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGg7XG5cbiAgICAgICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG4gICAgICAgIGlmIChidWZmZXJMZW4gPCBtYXhCdWZMZW4gJiYgdGhpcy50cmFja0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhY2tEZXRhaWxzID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXS5kZXRhaWxzO1xuICAgICAgICAgIC8vIGlmIHRyYWNrIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgdHJhY2sgcmV0cmlldmFsXG4gICAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RldGFpbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50LCBjaGVjayBpZiB3ZSBuZWVkIHRvIGZpbmFsaXplIG1lZGlhIHN0cmVhbVxuICAgICAgICBpZiAoIXRyYWNrRGV0YWlscy5saXZlICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc24gPT09IHRyYWNrRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBzZWVraW5nIG9yIGlmIHdlIGFyZSBzZWVraW5nIGJ1dCBldmVyeXRoaW5nIChhbG1vc3QpIHRpbCB0aGUgZW5kIGlzIGJ1ZmZlcmVkLCBsZXQncyBzaWduYWwgZW9zXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjb21wYXJlIGV4YWN0bHkgbWVkaWEuZHVyYXRpb24gPT09IGJ1ZmZlckluZm8uZW5kIGFzIHRoZXJlIGNvdWxkIGJlIHNvbWUgc3VidGxlIG1lZGlhIGR1cmF0aW9uIGRpZmZlcmVuY2Ugd2hlbiBzd2l0Y2hpbmdcbiAgICAgICAgICAgIC8vIGJldHdlZW4gZGlmZmVyZW50IHJlbmRpdGlvbnMuIHVzaW5nIGhhbGYgZnJhZyBkdXJhdGlvbiBzaG91bGQgaGVscCBjb3BlIHdpdGggdGhlc2UgY2FzZXMuXG4gICAgICAgICAgICBpZiAoIXRoaXMubWVkaWEuc2Vla2luZyB8fCAodGhpcy5tZWRpYS5kdXJhdGlvbi1idWZmZXJFbmQpIDwgZnJhZ1ByZXZpb3VzLmR1cmF0aW9uLzIpIHtcbiAgICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBtZWRpYSBzdHJlYW1cbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0VPUyx7IHR5cGUgOiAnYXVkaW8nfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgICAgbGV0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgICAgIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgICAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbi0xXS5kdXJhdGlvbixcbiAgICAgICAgICAgICAgZnJhZztcblxuICAgICAgICAgIC8vIGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWc7XG4gICAgICAgICAgICBsZXQgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgICAgICAgICBpZiAoYnVmZmVyRW5kID4gZW5kIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAgICAgICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgICAgICAgICAgICAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgICAgICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAgICAgICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gICAgICAgICAgICAgICAgaWYgKChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID4gYnVmZmVyRW5kKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWcpIHtcbiAgICAgICAgICAgICAgZnJhZyA9IGZvdW5kRnJhZztcbiAgICAgICAgICAgICAgc3RhcnQgPSBmb3VuZEZyYWcuc3RhcnQ7XG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xuICAgICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5zbiA8IHRyYWNrRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnLnNuICsgMSAtIHRyYWNrRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihmcmFnKSB7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJyAgICAgIGxvYWRpbmcgZnJhZyAnICsgaSArJyxwb3MvYnVmRW5kOicgKyBwb3MudG9GaXhlZCgzKSArICcvJyArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgIGlmICgoZnJhZy5kZWNyeXB0ZGF0YS51cmkgIT0gbnVsbCkgJiYgKGZyYWcuZGVjcnlwdGRhdGEua2V5ID09IG51bGwpKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RoaXMudHJhY2tJZH1gKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0aGlzLnRyYWNrSWR9LCBjdXJyZW50VGltZToke3Bvc30sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGFyZSBub3QgcmVsb2FkaW5nIHRoZSBzYW1lIGZyYWdtZW50cyBpbiBsb29wIC4uLlxuICAgICAgICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCsrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIGxldCBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZnJhZyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCAzIHRpbWVzLCBhbmQgaWYgaXQgaGFzIGJlZW4gcmVsb2FkZWQgcmVjZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyYWcubG9hZElkeCA9IHRoaXMuZnJhZ0xvYWRJZHg7XG4gICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfVFJBQ0s6XG4gICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXTtcbiAgICAgICAgLy8gY2hlY2sgaWYgcGxheWxpc3QgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIHZhciBpc1NlZWtpbmcgPSBtZWRpYSAmJiBtZWRpYS5zZWVraW5nO1xuICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICBpZighcmV0cnlEYXRlIHx8IChub3cgPj0gcmV0cnlEYXRlKSB8fCBpc1NlZWtpbmcpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlYCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYodGhpcy50cmFja3MgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWRpbmcgY291bnRlciBvbiBNU0UgZGV0YWNoaW5nIHRvIGF2b2lkIHJlcG9ydGluZyBGUkFHX0xPT1BfTE9BRElOR19FUlJPUiBhZnRlciBlcnJvciByZWNvdmVyeVxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICBpZiAodHJhY2tzKSB7XG4gICAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkIGNvdW50ZXJcbiAgICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgIGlmKHRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgICAgIHRyYWNrLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICAgICAgICBmcmFnbWVudC5sb2FkQ291bnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCAgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICB9XG4gICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cbiAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25NZWRpYUVuZGVkKCkge1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG5cbiAgb25BdWRpb1RyYWNrc1VwZGF0ZWQoZGF0YSkge1xuICAgIGxvZ2dlci5sb2coJ2F1ZGlvIHRyYWNrcyB1cGRhdGVkJyk7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoKGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcbiAgICAvLyBkZXN0cm95IHVzZWxlc3MgZGVtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggYXVkaW8gc291cmNlIGJ1ZmZlclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlIDogJ2F1ZGlvJ30pO1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICB2YXIgZGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgdHJhY2tJZCA9IGRhdGEuaWQsXG4gICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXG4gICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuXG4gICAgbG9nZ2VyLmxvZyhgdHJhY2sgJHt0cmFja0lkfSBsb2FkZWQgWyR7ZGV0YWlscy5zdGFydFNOfSwke2RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuICAgIGRldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB0cmFjay5kZXRhaWxzID0gZGV0YWlscztcblxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IGRldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuZnJhZy50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGRhdGEuZnJhZy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgZGF0YS5mcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXSxcbiAgICAgICAgICAgIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydCA9IGZyYWdDdXJyZW50LnN0YXJ0LFxuICAgICAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjO1xuICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmcgPSAwO1xuICAgICAgICBpZighdGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsJ2F1ZGlvJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZyhgRGVtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICB0aGlzLmRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGF1ZGlvQ29kZWMsIG51bGwsIHN0YXJ0LCBmcmFnQ3VycmVudC5jYywgdHJhY2tJZCwgc24sIGR1cmF0aW9uLCBmcmFnQ3VycmVudC5kZWNyeXB0ZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFjaztcblxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgaWYodHJhY2spIHtcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NPREVDUyx0cmFja3MpO1xuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyB0cmFjazphdWRpbyxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xuICAgICAgICBsZXQgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQXBwZW5kaW5nKys7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogJ2F1ZGlvJywgZGF0YTogaW5pdFNlZ21lbnQsIHBhcmVudCA6ICdhdWRpbycsY29udGVudCA6ICdpbml0U2VnbWVudCd9KTtcbiAgICAgICAgfVxuICAgICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ0RhdGEoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXSxcbiAgICAgICAgICBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkICR7ZGF0YS50eXBlfSxQVFM6WyR7ZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpfSwke2RhdGEuZW5kUFRTLnRvRml4ZWQoMyl9XSxEVFM6WyR7ZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpfS8ke2RhdGEuZW5kRFRTLnRvRml4ZWQoMyl9XSxuYjoke2RhdGEubmJ9YCk7XG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKHRyYWNrLmRldGFpbHMsZnJhZy5zbixkYXRhLnN0YXJ0UFRTLGRhdGEuZW5kUFRTKTtcblxuICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZysrO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywge3R5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQgOiAnYXVkaW8nLGNvbnRlbnQgOiAnZGF0YSd9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLmVuZFBUUztcbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXG4gICAgICAgIGRhdGEuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGRhdGEubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICB9XG4gIH1cblxuXG4gIG9uQnVmZmVyQ3JlYXRlZChkYXRhKSB7XG4gICAgbGV0IGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcbiAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IGF1ZGlvVHJhY2suYnVmZmVyO1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRlZChkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmctLTtcbiAgICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQoKSB7XG4gICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiB0aGlzLnBlbmRpbmdBcHBlbmRpbmcgPT09IDApICB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQgOiAnYXVkaW8nfSk7XG4gICAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIGF1ZGlvIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZighZGF0YS5mYXRhbCkge1xuICAgICAgICAgIHZhciBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XG4gICAgICAgICAgaWYobG9hZEVycm9yKSB7XG4gICAgICAgICAgICBsb2FkRXJyb3IrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZEVycm9yPTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb2FkRXJyb3IgPD0gdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgICAgLy8gcmVzZXQgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yXG4gICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIDY0c1xuICAgICAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMixsb2FkRXJyb3ItMSkqdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LDY0MDAwKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluICR7ZGVsYXl9IG1zYCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgYXVkaW9TdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XG4gICAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICAgIGlmKHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gU3RhdGUuRVJST1IgOiBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHdoaWxlIGxvYWRpbmcgZnJhZyxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hlZCgpIHtcbiAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMudGljaygpO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBhdWRpbyB0cmFjayBjb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgICAgICAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYXVkaW8gdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgbGV0IGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsIHthdWRpb1RyYWNrcyA6IHRyYWNrc30pO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgbGV0IGlkID0gMDtcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZih0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuYXVkaW9UcmFjayA9IGlkO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZCsrO1xuICAgIH0pO1xuICAgIGlmIChkZWZhdWx0Rm91bmQgPT09IGZhbHNlICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ25vIGRlZmF1bHQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgdXNlIGZpcnN0IGF1ZGlvIHRyYWNrIGFzIGRlZmF1bHQnKTtcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IDA7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9UcmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xuICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xuICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IGF1ZGlvVHJhY2tJZCB8fCB0aGlzLnRyYWNrc1thdWRpb1RyYWNrSWRdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrSW50ZXJuYWwoYXVkaW9UcmFja0lkKTtcbiAgICB9XG4gIH1cblxuIHNldEF1ZGlvVHJhY2tJbnRlcm5hbChuZXdJZCkge1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA+PSAwICYmIG5ld0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdLCB0eXBlID0gYXVkaW9UcmFjay50eXBlO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0gsIHtpZDogbmV3SWQsIHR5cGUgOiB0eXBlfSk7XG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGF1ZGlvIFRyYWNrXG4gICAgICAgbGV0IGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XG4gICAgICBpZiAodHlwZSAhPT0gJ21haW4nICYmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5saXZlID09PSB0cnVlKSkge1xuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORywge3VybDogYXVkaW9UcmFjay51cmwsIGlkOiBuZXdJZH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBCdWZmZXIgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcblxuXG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5CVUZGRVJfUkVTRVQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ESU5HLFxuICAgICAgRXZlbnQuQlVGRkVSX0NPREVDUyxcbiAgICAgIEV2ZW50LkJVRkZFUl9FT1MsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hJTkcsXG4gICAgICBFdmVudC5MRVZFTF9VUERBVEVEKTtcblxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXG4gICAgLy8gKHRoZSBhY3R1YWwgZHVyYXRpb24gbWF5IGJlIHR3ZWFrZWQgc2xpZ2hseSBieSB0aGUgYnJvd3NlcilcbiAgICB0aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBudWxsO1xuXG4gICAgLy8gU291cmNlIEJ1ZmZlciBsaXN0ZW5lcnNcbiAgICB0aGlzLm9uc2J1ZSA9IHRoaXMub25TQlVwZGF0ZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25zYmUgID0gdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcbiAgICBsZXQgYXVkaW9FeHBlY3RlZCA9IGRhdGEuYXVkaW8sXG4gICAgICAgIHZpZGVvRXhwZWN0ZWQgPSBkYXRhLnZpZGVvLFxuICAgICAgICBzb3VyY2VCdWZmZXJOYiA9IDA7XG4gICAgaWYgKGF1ZGlvRXhwZWN0ZWQgfHwgdmlkZW9FeHBlY3RlZCkge1xuICAgICAgc291cmNlQnVmZmVyTmIgPSAoYXVkaW9FeHBlY3RlZCA/IDEgOiAwKSArICh2aWRlb0V4cGVjdGVkID8gMSA6IDApO1xuICAgICAgbG9nZ2VyLmxvZyhgJHtzb3VyY2VCdWZmZXJOYn0gc291cmNlQnVmZmVyKHMpIGV4cGVjdGVkYCk7XG4gICAgfVxuICAgIHRoaXMuc291cmNlQnVmZmVyTmIgPSBzb3VyY2VCdWZmZXJOYjtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gc2V0dXAgdGhlIG1lZGlhIHNvdXJjZVxuICAgICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgLy9NZWRpYSBTb3VyY2UgbGlzdGVuZXJzXG4gICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbk1lZGlhU291cmNlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbm1zZSA9IHRoaXMub25NZWRpYVNvdXJjZUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICBtZWRpYS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBkZXRhY2hpbmcnKTtcbiAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmIChtcykge1xuICAgICAgaWYgKG1zLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1zLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6JHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcblxuICAgICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5vbm1zbyA9IHRoaXMub25tc2UgPSB0aGlzLm9ubXNjID0gbnVsbDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1FRElBX0RFVEFDSEVEKTtcbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VPcGVuKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBvcGVuZWQnKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1FRElBX0FUVEFDSEVELCB7IG1lZGlhIDogdGhpcy5tZWRpYSB9KTtcbiAgICBsZXQgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgLy8gb25jZSByZWNlaXZlZCwgZG9uJ3QgbGlzdGVuIGFueW1vcmUgdG8gc291cmNlb3BlbiBldmVudFxuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICB9XG5cbiAgY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xuICAgIC8vIGlmIGFueSBidWZmZXIgY29kZWNzIHBlbmRpbmcsIGNoZWNrIGlmIHdlIGhhdmUgZW5vdWdoIHRvIGNyZWF0ZSBzb3VyY2VCdWZmZXJzXG4gICAgbGV0IHBlbmRpbmdUcmFja3MgPSB0aGlzLnBlbmRpbmdUcmFja3MsXG4gICAgICAgIHBlbmRpbmdUcmFja3NOYiA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcbiAgICAvLyBpZiBhbnkgcGVuZGluZyB0cmFja3MgYW5kIChpZiBuYiBvZiBwZW5kaW5nIHRyYWNrcyBtYXRjaGluZyBleHBlY3RlZCBuYiBvciBpZiB1bmtub293biBleHBlY3RlZCBuYilcbiAgICBpZiAocGVuZGluZ1RyYWNrc05iICYmIChcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9PT0gcGVuZGluZ1RyYWNrc05iIHx8XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyTmIgPT09IDApKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYVNvdXJjZUNsb3NlKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VFbmRlZCgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgfVxuXG5cbiAgb25TQlVwZGF0ZUVuZCgpIHtcblxuICAgIGlmICh0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICB0aGlzLmRvRmx1c2goKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcbiAgICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRFRCwgeyBwYXJlbnQgOiB0aGlzLnBhcmVudH0pO1xuXG4gICAgLy8gZG9uJ3QgYXBwZW5kIGluIGZsdXNoaW5nIG1vZGVcbiAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gIH1cblxuICBvblNCVXBkYXRlRXJyb3IoZXZlbnQpIHtcbiAgICBsb2dnZXIuZXJyb3IoYHNvdXJjZUJ1ZmZlciBlcnJvcjoke2V2ZW50fWApO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyB0aGlzIGVycm9yIG1pZ2h0IG5vdCBhbHdheXMgYmUgZmF0YWwgKGl0IGlzIGZhdGFsIGlmIGRlY29kZSBlcnJvciBpcyBzZXQsIGluIHRoYXQgY2FzZVxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlfSk7XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBkbyBtb3JlIHRoYW4gdGhhdCwgYXMgYWNjb3JkaW4gdG8gdGhlIHNwZWMsIHVwZGF0ZWVuZCB3aWxsIGJlIGZpcmVkIGp1c3QgYWZ0ZXJcbiAgfVxuXG4gIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGZvcih2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICB0aGlzLmZsdXNoUmFuZ2UgPSBbXTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gIH1cblxuICBvbkJ1ZmZlckNvZGVjcyh0cmFja3MpIHtcbiAgICAvLyBpZiBzb3VyY2UgYnVmZmVyKHMpIG5vdCBjcmVhdGVkIHlldCwgYXBwZW5kZWQgYnVmZmVyIHRyYWNrcyBpbiB0aGlzLnBlbmRpbmdUcmFja3NcbiAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yICh2YXIgdHJhY2tOYW1lIGluIHRyYWNrcykgeyB0aGlzLnBlbmRpbmdUcmFja3NbdHJhY2tOYW1lXSA9IHRyYWNrc1t0cmFja05hbWVdOyB9XG4gICAgICBsZXQgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgaWYgKG1lZGlhU291cmNlICYmIG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAvLyB0cnkgdG8gY3JlYXRlIHNvdXJjZWJ1ZmZlcnMgaWYgbWVkaWFzb3VyY2Ugb3BlbmVkXG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBjcmVhdGVTb3VyY2VCdWZmZXJzKHRyYWNrcykge1xuICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcixtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG5cbiAgICBmb3IgKGxldCB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICBpZighc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgIGxldCBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGAke3RyYWNrLmNvbnRhaW5lcn07Y29kZWNzPSR7Y29kZWN9YDtcbiAgICAgICAgbG9nZ2VyLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyIHdpdGggbWltZVR5cGU6JHttaW1lVHlwZX1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgICAgdHJhY2suYnVmZmVyID0gc2I7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjoke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBlcnI6IGVyciwgbWltZVR5cGUgOiBtaW1lVHlwZX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzIDogdHJhY2tzIH0gKTtcbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kaW5nKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgIGlmICghdGhpcy5zZWdtZW50cykge1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gWyBkYXRhIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRGYWlsKGRhdGEpIHtcbiAgICBsb2dnZXIuZXJyb3IoYHNvdXJjZUJ1ZmZlciBlcnJvcjoke2RhdGEuZXZlbnR9YCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IHRoaXMuZnJhZ0N1cnJlbnR9KTtcbiAgfVxuXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICBvbkJ1ZmZlckVvcyhkYXRhKSB7XG4gICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgbGV0IGRhdGFUeXBlID0gZGF0YS50eXBlO1xuICAgIGZvcihsZXQgdHlwZSBpbiBzYikge1xuICAgICAgaWYgKCFkYXRhVHlwZSB8fCB0eXBlID09PSBkYXRhVHlwZSkge1xuICAgICAgICBpZiAoIXNiW3R5cGVdLmVuZGVkKSB7XG4gICAgICAgICAgc2JbdHlwZV0uZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYCR7dHlwZX0gc291cmNlQnVmZmVyIG5vdyBFT1NgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoZWNrRW9zKCk7XG4gIH1cblxuIC8vIGlmIGFsbCBzb3VyY2UgYnVmZmVycyBhcmUgbWFya2VkIGFzIGVuZGVkLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZS5cbiBjaGVja0VvcygpIHtcbiAgICB2YXIgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlciwgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IobGV0IHR5cGUgaW4gc2IpIHtcbiAgICAgIGlmICghc2JbdHlwZV0uZW5kZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYoc2JbdHlwZV0udXBkYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNFb3MgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci5sb2coJ2FsbCBtZWRpYSBkYXRhIGF2YWlsYWJsZSwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UgYW5kIHN0b3AgbG9hZGluZyBmcmFnbWVudCcpO1xuICAgIC8vTm90aWZ5IHRoZSBtZWRpYSBlbGVtZW50IHRoYXQgaXQgbm93IGhhcyBhbGwgb2YgdGhlIG1lZGlhIGRhdGFcbiAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gfVxuXG5cbiAgb25CdWZmZXJGbHVzaGluZyhkYXRhKSB7XG4gICAgdGhpcy5mbHVzaFJhbmdlLnB1c2goe3N0YXJ0OiBkYXRhLnN0YXJ0T2Zmc2V0LCBlbmQ6IGRhdGEuZW5kT2Zmc2V0LCB0eXBlIDogZGF0YS50eXBlfSk7XG4gICAgLy8gYXR0ZW1wdCBmbHVzaCBpbW1lZGlhdGx5XG4gICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgIHRoaXMuZG9GbHVzaCgpO1xuICB9XG5cbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQpIHtcbiAgICBsZXQgZGV0YWlscyA9IGV2ZW50LmRldGFpbHM7XG4gICAgaWYgKGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sZXZlbER1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uICsgZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9pc3N1ZXMvMzU1XG4gIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sZXZlbER1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNvdXJjZUJ1ZmZlciB8fCBtZWRpYS5yZWFkeVN0YXRlID09PSAwIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgaWYgKHNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZykge1xuICAgICAgICAvLyBjYW4ndCBzZXQgZHVyYXRpb24gd2hpbHN0IGEgYnVmZmVyIGlzIHVwZGF0aW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX21zRHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgIC8vIGluaXRpYWxpc2UgdG8gdGhlIHZhbHVlIHRoYXQgdGhlIG1lZGlhIHNvdXJjZSBpcyByZXBvcnRpbmdcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSBtZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gdGhpcy5fbGV2ZWxEdXJhdGlvbiB3YXMgdGhlIGxhc3QgdmFsdWUgd2Ugc2V0LlxuICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgIC8vIG9ubHkgdXBkYXRlIG1lZGlhc291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWwsIGFzIHRoZXlcbiAgICBpZiAodGhpcy5fbGV2ZWxEdXJhdGlvbiA+IHRoaXMuX21zRHVyYXRpb24pIHtcbiAgICAgIGxvZ2dlci5sb2coYFVwZGF0aW5nIG1lZGlhc291cmNlIGR1cmF0aW9uIHRvICR7dGhpcy5fbGV2ZWxEdXJhdGlvbn1gKTtcbiAgICAgIG1lZGlhU291cmNlLmR1cmF0aW9uID0gdGhpcy5fbGV2ZWxEdXJhdGlvbjtcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSB0aGlzLl9sZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGRvRmx1c2goKSB7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidWZmZXIgcmFuZ2VzIHRvIGZsdXNoXG4gICAgd2hpbGUodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5mbHVzaFJhbmdlWzBdO1xuICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXG4gICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlcihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCByYW5nZS50eXBlKSkge1xuICAgICAgICAvLyByYW5nZSBmbHVzaGVkLCByZW1vdmUgZnJvbSBmbHVzaCBhcnJheVxuICAgICAgICB0aGlzLmZsdXNoUmFuZ2Uuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XG4gICAgICAgIC8vIGF2b2lkIGxvb3BpbmcsIHdhaXQgZm9yIFNCIHVwZGF0ZSBlbmQgdG8gcmV0cmlnZ2VyIGEgZmx1c2hcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXG4gICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gZmFsc2U7XG5cbiAgICAgIC8vIGxldCdzIHJlY29tcHV0ZSB0aGlzLmFwcGVuZGVkLCB3aGljaCBpcyB1c2VkIHRvIGF2b2lkIGZsdXNoIGxvb3BpbmdcbiAgICAgIHZhciBhcHBlbmRlZCA9IDA7XG4gICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICBhcHBlbmRlZCArPSBzb3VyY2VCdWZmZXJbdHlwZV0uYnVmZmVyZWQubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRlZCA9IGFwcGVuZGVkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hFRCk7XG4gICAgfVxuICB9XG5cbiAgZG9BcHBlbmRpbmcoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzLCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlciwgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMubWVkaWEuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ3RyeWluZyB0byBhcHBlbmQgYWx0aG91Z2ggYSBtZWRpYSBlcnJvciBvY2N1cmVkLCBmbHVzaCBzZWdtZW50IGFuZCBhYm9ydCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcHBlbmRpbmcpIHtcbiAgICAgICAgLy9sb2dnZXIubG9nKGBzYiBhcHBlbmRpbmcgaW4gcHJvZ3Jlc3NgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHR5cGUgPSBzZWdtZW50LnR5cGU7XG4gICAgICAgICAgaWYoc291cmNlQnVmZmVyW3R5cGVdKSB7XG4gICAgICAgICAgICAvLyByZXNldCBzb3VyY2VCdWZmZXIgZW5kZWQgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIHNlZ21lbnRcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlclt0eXBlXS5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy9sb2dnZXIubG9nKGBhcHBlbmRpbmcgJHtzZWdtZW50LmNvbnRlbnR9ICR7c2VnbWVudC50eXBlfSBTQiwgc2l6ZToke3NlZ21lbnQuZGF0YS5sZW5ndGh9LCAke3NlZ21lbnQucGFyZW50fWApO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBzZWdtZW50LnBhcmVudDtcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlclt0eXBlXS5hcHBlbmRCdWZmZXIoc2VnbWVudC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAwO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCsrO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGRvbid0IGhhdmUgYW55IHNvdXJjZSBidWZmZXIgbWF0Y2hpbmcgd2l0aCB0aGlzIHNlZ21lbnQgdHlwZSxcbiAgICAgICAgICAgIC8vIGl0IG1lYW5zIHRoYXQgTWVkaWFzb3VyY2UgZmFpbHMgdG8gY3JlYXRlIHNvdXJjZWJ1ZmZlclxuICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGlzIHNlZ21lbnQsIGFuZCB0cmlnZ2VyIHVwZGF0ZSBlbmRcbiAgICAgICAgICAgIHRoaXMub25TQlVwZGF0ZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICAgIGxvZ2dlci5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFwcGVuZCBidWZmZXI6JHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xuICAgICAgICAgIHZhciBldmVudCA9IHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SfTtcbiAgICAgICAgICBpZihlcnIuY29kZSAhPT0gMjIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgICAgZXZlbnQuZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiByZXRyeWluZyBoZWxwIHJlY292ZXJpbmcgdGhpc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGZhaWwgJHtobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnl9IHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIHNvdXJjZUJ1ZmZlcmApO1xuICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgIGZsdXNoIHNwZWNpZmllZCBidWZmZXJlZCByYW5nZSxcbiAgICByZXR1cm4gdHJ1ZSBvbmNlIHJhbmdlIGhhcyBiZWVuIGZsdXNoZWQuXG4gICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxuICAqL1xuICBmbHVzaEJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlSW4pIHtcbiAgICB2YXIgc2IsIGksIGJ1ZlN0YXJ0LCBidWZFbmQsIGZsdXNoU3RhcnQsIGZsdXNoRW5kLCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2ZsdXNoQnVmZmVyLHBvcy9zdGFydC9lbmQ6ICcgKyB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lICsgJy8nICsgc3RhcnRPZmZzZXQgKyAnLycgKyBlbmRPZmZzZXQpO1xuICAgICAgLy8gc2FmZWd1YXJkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgOiBkb24ndCB0cnkgdG8gZmx1c2ggbW9yZSB0aGFuIHRoZSBuYiBvZiBhcHBlbmRlZCBzZWdtZW50c1xuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyIDwgdGhpcy5hcHBlbmRlZCkge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHNvdXJjZWJ1ZmZlciB0eXBlIGlzIGRlZmluZWQgKHR5cGVJbik6IGlmIHllcywgbGV0J3Mgb25seSBmbHVzaCB0aGlzIG9uZVxuICAgICAgICAgIC8vIGlmIG5vLCBsZXQncyBmbHVzaCBhbGwgc291cmNlYnVmZmVyc1xuICAgICAgICAgIGlmICh0eXBlSW4gJiYgdHlwZSAhPT0gdHlwZUluKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNiLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICAgICAgICAgIGJ1ZkVuZCA9IHNiLmJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmaXJlZm94IG5vdCBhYmxlIHRvIHByb3Blcmx5IGZsdXNoIG11bHRpcGxlIGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEgJiYgZW5kT2Zmc2V0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFN0YXJ0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1c2hTdGFydCA9IE1hdGgubWF4KGJ1ZlN0YXJ0LCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBNYXRoLm1pbihidWZFbmQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogc29tZXRpbWVzIHNvdXJjZWJ1ZmZlci5yZW1vdmUoKSBkb2VzIG5vdCBmbHVzaFxuICAgICAgICAgICAgICAgICB0aGUgZXhhY3QgZXhwZWN0ZWQgdGltZSByYW5nZS5cbiAgICAgICAgICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXG4gICAgICAgICAgICAgICAgIG9ubHkgZmx1c2ggYnVmZmVyIHJhbmdlIG9mIGxlbmd0aCBncmVhdGVyIHRoYW4gNTAwbXMuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmIChNYXRoLm1pbihmbHVzaEVuZCxidWZFbmQpIC0gZmx1c2hTdGFydCA+IDAuNSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYGZsdXNoICR7dHlwZX0gWyR7Zmx1c2hTdGFydH0sJHtmbHVzaEVuZH1dLCBvZiBbJHtidWZTdGFydH0sJHtidWZFbmR9XSwgcG9zOiR7dGhpcy5tZWRpYS5jdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgICAgICBzYi5yZW1vdmUoZmx1c2hTdGFydCwgZmx1c2hFbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2Fib3J0ICcgKyB0eXBlICsgJyBhcHBlbmQgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhYm9ydCBhbnkgYXBwZW5kaW5nIGluIHByb2dyZXNzXG4gICAgICAgICAgICAvL3NiLmFib3J0KCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybignY2Fubm90IGZsdXNoLCBzYiB1cGRhdGluZyBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2Fib3J0IGZsdXNoaW5nIHRvbyBtYW55IHJldHJpZXMnKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coJ2J1ZmZlciBmbHVzaGVkJyk7XG4gICAgfVxuICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZCAhXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcblxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblx0Y29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCk7ICAgXG5cdH1cblx0XG5cdGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMucmVzdHJpY3RlZExldmVscyA9IG51bGw7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblx0XG4gIG9uRnBzRHJvcExldmVsQ2FwcGluZyhkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRMZXZlbHMpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNMZXZlbFJlc3RyaWN0ZWQoZGF0YS5kcm9wcGVkTGV2ZWwpKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaChkYXRhLmRyb3BwZWRMZXZlbCk7XG4gICAgfVxuICB9XG4gIFxuXHRvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDsgIFxuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICAgIHRoaXMuaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGRhdGEuZmlyc3RMZXZlbCk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH1cbiAgfVxuICBcbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgbGV0IGxldmVsc0xlbmd0aCA9IHRoaXMubGV2ZWxzID8gdGhpcy5sZXZlbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmICh0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgdGhpcy5obHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nOyAgICAgICAgXG4gICAgICB9ICBcbiAgICB9XG4gIH1cbiAgXG4gIC8qXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgKi9cbiAgZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgIGxldCByZXN1bHQgPSAwLFxuICAgICAgICBpLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgbVdpZHRoID0gdGhpcy5tZWRpYVdpZHRoLFxuICAgICAgICBtSGVpZ2h0ID0gdGhpcy5tZWRpYUhlaWdodCxcbiAgICAgICAgbFdpZHRoID0gMCxcbiAgICAgICAgbEhlaWdodCA9IDA7XG4gICAgICAgIFxuICAgIGZvciAoaSA9IDA7IGkgPD0gY2FwTGV2ZWxJbmRleDsgaSsrKSB7XG4gICAgICBsZXZlbCA9IHRoaXMubGV2ZWxzW2ldO1xuICAgICAgaWYgKHRoaXMuaXNMZXZlbFJlc3RyaWN0ZWQoaSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgbFdpZHRoID0gbGV2ZWwud2lkdGg7XG4gICAgICBsSGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0O1xuICAgICAgaWYgKG1XaWR0aCA8PSBsV2lkdGggfHwgbUhlaWdodCA8PSBsSGVpZ2h0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgXG4gIGlzTGV2ZWxSZXN0cmljdGVkKGxldmVsKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgJiYgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpICE9PSAtMSkgPyB0cnVlIDogZmFsc2U7XG4gIH1cbiAgXG4gIGdldCBjb250ZW50U2NhbGVGYWN0b3IoKSB7XG4gICAgbGV0IHBpeGVsUmF0aW8gPSAxO1xuICAgIHRyeSB7XG4gICAgICBwaXhlbFJhdGlvID0gIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH0gY2F0Y2goZSkge31cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuICBcbiAgZ2V0IG1lZGlhV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoO1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWVkaWEud2lkdGggfHwgdGhpcy5tZWRpYS5jbGllbnRXaWR0aCB8fCB0aGlzLm1lZGlhLm9mZnNldFdpZHRoO1xuICAgICAgd2lkdGggKj0gdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuICBcbiAgZ2V0IG1lZGlhSGVpZ2h0KCkge1xuICAgIGxldCBoZWlnaHQ7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWVkaWEuaGVpZ2h0IHx8IHRoaXMubWVkaWEuY2xpZW50SGVpZ2h0IHx8IHRoaXMubWVkaWEub2Zmc2V0SGVpZ2h0O1xuICAgICAgaGVpZ2h0ICo9IHRoaXMuY29udGVudFNjYWxlRmFjdG9yOyBcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7IiwiLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5pbXBvcnQgRVdNQSBmcm9tICcuLi91dGlscy9ld21hJztcblxuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihobHMsc2xvdyxmYXN0LGRlZmF1bHRFc3RpbWF0ZSkge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcbiAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3cpO1xuICAgIHRoaXMuZmFzdF8gPSBuZXcgRVdNQShmYXN0KTtcbiAgfVxuXG4gIHNhbXBsZShkdXJhdGlvbk1zLG51bUJ5dGVzKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIHZhciBiYW5kd2lkdGggPSA4MDAwKiBudW1CeXRlcyAvIGR1cmF0aW9uTXMsXG4gICAgLy9jb25zb2xlLmxvZygnaW5zdGFudCBidzonKyBNYXRoLnJvdW5kKGJhbmR3aWR0aCkpO1xuICAgIC8vIHdlIHdlaWdodCBzYW1wbGUgdXNpbmcgbG9hZGluZyBkdXJhdGlvbi4uLi5cbiAgICAgICAgd2VpZ2h0ID0gZHVyYXRpb25NcyAvIDEwMDA7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUod2VpZ2h0LGJhbmR3aWR0aCk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUod2VpZ2h0LGJhbmR3aWR0aCk7XG4gIH1cblxuXG4gIGdldEVzdGltYXRlKCkge1xuICAgIGlmICghdGhpcy5mYXN0XyB8fCAhdGhpcy5zbG93XyB8fCB0aGlzLmZhc3RfLmdldFRvdGFsV2VpZ2h0KCkgPCB0aGlzLm1pbldlaWdodF8pIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coJ3Nsb3cgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpKTtcbiAgICAvL2NvbnNvbGUubG9nKCdmYXN0IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSx0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcblxuIiwiLypcbiAqIEZQUyBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRlBTQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlcntcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1FRElBX0FUVEFDSElORyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgfVxuICBcbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgdGhpcy52aWRlbyA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIHRoaXMuaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCk7XG4gICAgfSBcbiAgfVxuICBcbiAgY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICBsZXQgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUsXG4gICAgICAgICAgICBjdXJyZW50RHJvcHBlZCA9IGRyb3BwZWRGcmFtZXMgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzLFxuICAgICAgICAgICAgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyxcbiAgICAgICAgICAgIGRyb3BwZWRGUFMgPSAxMDAwICogY3VycmVudERyb3BwZWQgLyBjdXJyZW50UGVyaW9kO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QLCB7Y3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lc30pO1xuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gdGhpcy5obHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSB0aGlzLmhscy5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtsZXZlbDogY3VycmVudExldmVsLCBkcm9wcGVkTGV2ZWw6IHRoaXMuaGxzLmN1cnJlbnRMZXZlbH0pO1xuICAgICAgICAgICAgICB0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICB0aGlzLmhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH1cbiAgXG4gIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgbGV0IHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdGhpcy52aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHRoaXMudmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHRoaXMudmlkZW8sIHRoaXMudmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHRoaXMudmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpOyAgXG4gICAgICB9XG4gICAgfVxuICB9IFxufVxuXG5leHBvcnQgZGVmYXVsdCBGUFNDb250cm9sbGVyO1xuXG4iLCIvKlxuICogTGV2ZWwgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcblxuY2xhc3MgTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXG4gICAgICBFdmVudC5FUlJPUik7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IC0xO1xuICB9XG5cbiAgc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FubG9hZCA9IHRydWU7XG4gICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xuICAgIHZhciBsZXZlbHMwID0gW10sIGxldmVscyA9IFtdLCBiaXRyYXRlU3RhcnQsIGksIGJpdHJhdGVTZXQgPSB7fSwgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2UsIGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlLCBobHMgPSB0aGlzLmhscztcblxuICAgIC8vIHJlZ3JvdXAgcmVkdW5kYW50IGxldmVsIHRvZ2V0aGVyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBpZihsZXZlbC52aWRlb0NvZGVjKSB7XG4gICAgICAgIHZpZGVvQ29kZWNGb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZihsZXZlbC5hdWRpb0NvZGVjIHx8IChsZXZlbC5hdHRycyAmJiBsZXZlbC5hdHRycy5BVURJTykpIHtcbiAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZWR1bmRhbnRMZXZlbElkID0gYml0cmF0ZVNldFtsZXZlbC5iaXRyYXRlXTtcbiAgICAgIGlmIChyZWR1bmRhbnRMZXZlbElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYml0cmF0ZVNldFtsZXZlbC5iaXRyYXRlXSA9IGxldmVsczAubGVuZ3RoO1xuICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICBsZXZlbHMwLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxzMFtyZWR1bmRhbnRMZXZlbElkXS51cmwucHVzaChsZXZlbC51cmwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgbGV2ZWwgaWYgd2UgYWxzbyBoYXZlIGxldmVscyB3aXRoIGF1ZGlvK3ZpZGVvIGNvZGVjcyBzaWduYWxsZWRcbiAgICBpZih2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMwLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICBpZihsZXZlbC52aWRlb0NvZGVjKSB7XG4gICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzMDtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGtlZXAgbGV2ZWwgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbihsZXZlbCkge1xuICAgICAgdmFyIGNoZWNrU3VwcG9ydGVkQXVkaW8gPSBmdW5jdGlvbihjb2RlYykgeyByZXR1cm4gTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKGBhdWRpby9tcDQ7Y29kZWNzPSR7Y29kZWN9YCk7fTtcbiAgICAgIHZhciBjaGVja1N1cHBvcnRlZFZpZGVvID0gZnVuY3Rpb24oY29kZWMpIHsgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChgdmlkZW8vbXA0O2NvZGVjcz0ke2NvZGVjfWApO307XG4gICAgICB2YXIgYXVkaW9Db2RlYyA9IGxldmVsLmF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMgPSBsZXZlbC52aWRlb0NvZGVjO1xuXG4gICAgICByZXR1cm4gKCFhdWRpb0NvZGVjIHx8IGNoZWNrU3VwcG9ydGVkQXVkaW8oYXVkaW9Db2RlYykpICYmXG4gICAgICAgICAgICAgKCF2aWRlb0NvZGVjIHx8IGNoZWNrU3VwcG9ydGVkVmlkZW8odmlkZW9Db2RlYykpO1xuICAgIH0pO1xuXG4gICAgaWYobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICAgIGJpdHJhdGVTdGFydCA9IGxldmVsc1swXS5iaXRyYXRlO1xuICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG4gICAgICBsZXZlbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5iaXRyYXRlIC0gYi5iaXRyYXRlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gICAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxldmVsc1tpXS5iaXRyYXRlID09PSBiaXRyYXRlU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9maXJzdExldmVsID0gaTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBtYW5pZmVzdCBsb2FkZWQsJHtsZXZlbHMubGVuZ3RofSBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZToke2JpdHJhdGVTdGFydH1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfUEFSU0VELCB7bGV2ZWxzOiB0aGlzLl9sZXZlbHMsIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsIHN0YXRzOiBkYXRhLnN0YXRzLCBhdWRpbyA6IGF1ZGlvQ29kZWNGb3VuZCwgdmlkZW8gOiB2aWRlb0NvZGVjRm91bmR9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogaGxzLnVybCwgcmVhc29uOiAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCd9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0IGxldmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICB9XG5cbiAgZ2V0IGxldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgfVxuXG4gIHNldCBsZXZlbChuZXdMZXZlbCkge1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKGxldmVscyAmJiBsZXZlbHMubGVuZ3RoID4gbmV3TGV2ZWwpIHtcbiAgICAgIGlmICh0aGlzLl9sZXZlbCAhPT0gbmV3TGV2ZWwgfHwgbGV2ZWxzW25ld0xldmVsXS5kZXRhaWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRMZXZlbEludGVybmFsKG5ld0xldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuIHNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpIHtcbiAgICBsZXQgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdMZXZlbCA+PSAwICYmIG5ld0xldmVsIDwgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXdMZXZlbH1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENILCB7bGV2ZWw6IG5ld0xldmVsfSk7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdLCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbC4gZG9uJ3QgcmVsb2FkIGxpdmUgcGxheWxpc3QgbW9yZSB0aGFuIG9uY2UgcGVyIHNlY29uZFxuICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHxcbiAgICAgICAgICAobGV2ZWxEZXRhaWxzLmxpdmUgPT09IHRydWUgJiYgKHBlcmZvcm1hbmNlLm5vdygpIC0gbGV2ZWxEZXRhaWxzLnRsb2FkID4gMTAwMCkgKSkge1xuICAgICAgICAvLyBsZXZlbCBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBsZXZlbCAke25ld0xldmVsfWApO1xuICAgICAgICB2YXIgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7dXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbmV3TGV2ZWwsIGlkOiB1cmxJZH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsIGxldmVsOiBuZXdMZXZlbCwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCd9KTtcbiAgICB9XG4gfVxuXG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFudWFsTGV2ZWw7XG4gIH1cblxuICBzZXQgbWFudWFsTGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBmaXJzdExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICB9XG5cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXJ0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICBpZihkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGRldGFpbHMgPSBkYXRhLmRldGFpbHMsIGhscyA9IHRoaXMuaGxzLCBsZXZlbElkLCBsZXZlbCwgbGV2ZWxFcnJvciA9IGZhbHNlO1xuICAgIC8vIHRyeSB0byByZWNvdmVyIG5vdCBmYXRhbCBlcnJvcnNcbiAgICBzd2l0Y2goZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgIGxldmVsSWQgPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGxldmVsSWQgPSBkYXRhLmNvbnRleHQubGV2ZWw7XG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvKiB0cnkgdG8gc3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxuICAgICAqIGlmIG5vIHJlZHVuZGFudCBzdHJlYW0gYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gKGlmIGluIGF1dG8gbW9kZSBhbmQgY3VycmVudCBsZXZlbCBub3QgMClcbiAgICAgKiBvdGhlcndpc2UsIHdlIGNhbm5vdCByZWNvdmVyIHRoaXMgbmV0d29yayBlcnJvciAuLi5cbiAgICAgKiBkb24ndCByYWlzZSBGUkFHX0xPQURfRVJST1IgYW5kIEZSQUdfTE9BRF9USU1FT1VUIGFzIGZhdGFsLCBhcyBpdCBpcyBoYW5kbGVkIGJ5IG1lZGlhQ29udHJvbGxlclxuICAgICAqL1xuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdO1xuICAgICAgaWYgKGxldmVsLnVybElkIDwgKGxldmVsLnVybC5sZW5ndGggLSAxKSkge1xuICAgICAgICBsZXZlbC51cmxJZCsrO1xuICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwke2RldGFpbHN9IGZvciBsZXZlbCAke2xldmVsSWR9OiBzd2l0Y2hpbmcgdG8gcmVkdW5kYW50IHN0cmVhbSBpZCAke2xldmVsLnVybElkfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgY291bGQgdHJ5IHRvIHJlY292ZXIgaWYgaW4gYXV0byBtb2RlIGFuZCBjdXJyZW50IGxldmVsIG5vdCBsb3dlc3QgbGV2ZWwgKDApXG4gICAgICAgIGxldCByZWNvdmVyYWJsZSA9ICgodGhpcy5fbWFudWFsTGV2ZWwgPT09IC0xKSAmJiBsZXZlbElkKTtcbiAgICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsJHtkZXRhaWxzfTogZW1lcmdlbmN5IHN3aXRjaC1kb3duIGZvciBuZXh0IGZyYWdtZW50YCk7XG4gICAgICAgICAgaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZihsZXZlbCAmJiBsZXZlbC5kZXRhaWxzICYmIGxldmVsLmRldGFpbHMubGl2ZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30gb24gbGl2ZSBzdHJlYW0sIGRpc2NhcmRgKTtcbiAgICAgICAgICBpZiAobGV2ZWxFcnJvcikge1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhpcy5fbGV2ZWwgc28gdGhhdCBhbm90aGVyIGNhbGwgdG8gc2V0IGxldmVsKCkgd2lsbCByZXRyaWdnZXIgYSBmcmFnIGxvYWRcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gRlJBR19MT0FEX0VSUk9SIGFuZCBGUkFHX0xPQURfVElNRU9VVCBhcmUgaGFuZGxlZCBieSBtZWRpYUNvbnRyb2xsZXJcbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SICYmIGRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgY2Fubm90IHJlY292ZXIgJHtkZXRhaWxzfSBlcnJvcmApO1xuICAgICAgICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZChkYXRhKSB7XG4gICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcbiAgICAgaWYgKGRhdGEubGV2ZWwgPT09IHRoaXMuX2xldmVsKSB7XG4gICAgICBsZXQgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCooIG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSxcbiAgICAgICAgICAgIGN1ckxldmVsID0gdGhpcy5fbGV2ZWxzW2RhdGEubGV2ZWxdLFxuICAgICAgICAgICAgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XG4gICAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZW5kU04gPT09IGN1ckRldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAvLyBmb2xsb3cgSExTIFNwZWMsIElmIHRoZSBjbGllbnQgcmVsb2FkcyBhIFBsYXlsaXN0IGZpbGUgYW5kIGZpbmRzIHRoYXQgaXQgaGFzIG5vdFxuICAgICAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAgICAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLz0yO1xuICAgICAgICAgIGxvZ2dlci5sb2coYHNhbWUgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIHR3aWNlIGZhc3RlcmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlY3JlbWVudCByZWxvYWRJbnRlcnZhbCB3aXRoIGxldmVsIGxvYWRpbmcgZGVsYXlcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gcGVyZm9ybWFuY2Uubm93KCkgLSBkYXRhLnN0YXRzLnRyZXF1ZXN0O1xuICAgICAgICAvLyBpbiBhbnkgY2FzZSwgZG9uJ3QgcmVsb2FkIG1vcmUgdGhhbiBldmVyeSBzZWNvbmRcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBNYXRoLm1heCgxMDAwLE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIGluICR7cmVsb2FkSW50ZXJ2YWx9IG1zYCk7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMub250aWNrLHJlbG9hZEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgdmFyIGxldmVsSWQgPSB0aGlzLl9sZXZlbDtcbiAgICBpZiAobGV2ZWxJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY2FubG9hZCkge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdLCB1cmxJZCA9IGxldmVsLnVybElkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7dXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbGV2ZWxJZCwgaWQ6IHVybElkfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMuX21hbnVhbExldmVsICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgIHJldHVybiB0aGlzLmhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5leHRMb2FkTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICBpZiAodGhpcy5fbWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICB0aGlzLmhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExldmVsQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIFN0cmVhbSBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xuaW1wb3J0IEJ1ZmZlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgRGVtdXhlciBmcm9tICcuLi9kZW11eC9kZW11eGVyJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBMZXZlbEhlbHBlciBmcm9tICcuLi9oZWxwZXIvbGV2ZWwtaGVscGVyJztcbmltcG9ydCBUaW1lUmFuZ2VzIGZyb20gJy4uL3V0aWxzL3RpbWVSYW5nZXMnO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgU3RhdGUgPSB7XG4gIFNUT1BQRUQgOiAnU1RPUFBFRCcsXG4gIFNUQVJUSU5HIDogJ1NUQVJUSU5HJyxcbiAgSURMRSA6ICdJRExFJyxcbiAgUEFVU0VEIDogJ1BBVVNFRCcsXG4gIEtFWV9MT0FESU5HIDogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HIDogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZIDogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgV0FJVElOR19MRVZFTCA6ICdXQUlUSU5HX0xFVkVMJyxcbiAgUEFSU0lORyA6ICdQQVJTSU5HJyxcbiAgUEFSU0VEIDogJ1BBUlNFRCcsXG4gIEVOREVEIDogJ0VOREVEJyxcbiAgRVJST1IgOiAnRVJST1InXG59O1xuXG5jbGFzcyBTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsXG4gICAgICBFdmVudC5GUkFHX1BBUlNFRCxcbiAgICAgIEV2ZW50LkVSUk9SLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENILFxuICAgICAgRXZlbnQuQlVGRkVSX0NSRUFURUQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hFRCk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMudGlja3MgPSAwO1xuICAgIHRoaXMub250aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCdtYWluJyk7XG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgfVxuICAgICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGlmIChtZWRpYSAmJiBsYXN0Q3VycmVudFRpbWUgPiAwKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYGNvbmZpZ3VyZSBzdGFydFBvc2l0aW9uIEAke2xhc3RDdXJyZW50VGltZX1gKTtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RQYXVzZWQpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdyZXN1bWluZyB2aWRlbycpO1xuICAgICAgICAgIG1lZGlhLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUQVJUSU5HO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oJ2Nhbm5vdCBzdGFydCBsb2FkaW5nIGFzIG1hbmlmZXN0IG5vdCBwYXJzZWQgeWV0Jyk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCgpIHtcbiAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICB0aWNrKCkge1xuICAgIHRoaXMudGlja3MrKztcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB9XG4gIH1cblxuICBkb1RpY2soKSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuU1RBUlRJTkc6XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XG4gICAgICAgICAgdGhpcy5mcmFnQml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgIC8vIHdoZW4gdGhpcyByZXR1cm5zIGZhbHNlIHRoZXJlIHdhcyBhbiBlcnJvciBhbmQgd2Ugc2hhbGwgcmV0dXJuIGltbWVkaWF0bHlcbiAgICAgICAgLy8gZnJvbSBjdXJyZW50IHRpY2tcbiAgICAgICAgaWYgKCF0aGlzLl9kb1RpY2tJZGxlKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdO1xuICAgICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICBpZiAobGV2ZWwgJiYgbGV2ZWwuZGV0YWlscykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgIGlmKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8ICh0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEuc2Vla2luZykpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBtZWRpYUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlYCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgY2FzZSBTdGF0ZS5QQVVTRUQ6XG4gICAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gY2hlY2sgYnVmZmVyXG4gICAgdGhpcy5fY2hlY2tCdWZmZXIoKTtcbiAgICAvLyBjaGVjay91cGRhdGUgY3VycmVudCBmcmFnbWVudFxuICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH1cblxuICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxuICAvLyBOT1RFOiBNYXliZSB3ZSBjb3VsZCByYXRoZXIgc2NoZWR1bGUgYSBjaGVjayBmb3IgYnVmZmVyIGxlbmd0aCBhZnRlciBoYWxmIG9mIHRoZSBjdXJyZW50bHlcbiAgLy8gICAgICAgcGxheWVkIHNlZ21lbnQsIG9yIG9uIHBhdXNlL3BsYXkvc2VlayBpbnN0ZWFkIG9mIG5haXZlbHkgY2hlY2tpbmcgZXZlcnkgMTAwbXM/XG4gIF9kb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxuICAgIC8vIGV4aXQgbG9vcFxuICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICBpZiAoIW1lZGlhICYmXG4gICAgICAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICBsZXQgcG9zO1xuICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBsb2FkIGxldmVsXG4gICAgbGV0IGxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWw7XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgbGV0IG1heEJ1ZkxlbjtcbiAgICBpZiAoKHRoaXMubGV2ZWxzW2xldmVsXSkuaGFzT3duUHJvcGVydHkoJ2JpdHJhdGUnKSkge1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gdGhpcy5sZXZlbHNbbGV2ZWxdLmJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgLy8gZW5zdXJlIHVwIHRvIGBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoYCBvZiBidWZmZXIgdXBmcm9udFxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgLi4uXG4gICAgbG9nZ2VyLnRyYWNlKGBidWZmZXIgbGVuZ3RoIG9mICR7YnVmZmVyTGVuLnRvRml4ZWQoMyl9IGlzIGJlbG93IG1heCBvZiAke21heEJ1Zkxlbi50b0ZpeGVkKDMpfS4gY2hlY2tpbmcgZm9yIG1vcmUgcGF5bG9hZCAuLi5gKTtcblxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG5cbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsc1tsZXZlbF0uZGV0YWlscztcbiAgICAvLyBpZiBsZXZlbCBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIGxldmVsIHJldHJpZXZhbFxuICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIGVuc3VyZSB0aGF0IG5ldyBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgdG8gYXZvaWQgbG9hZGluZy90cnkgdG8gbG9hZFxuICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcbiAgICBpZiAodHlwZW9mIGxldmVsRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZmluYWxpemUgbWVkaWEgc3RyZWFtXG4gICAgbGV0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmxpdmUgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zbiA9PT0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgc2Vla2luZyBvciBpZiB3ZSBhcmUgc2Vla2luZyBidXQgZXZlcnl0aGluZyAoYWxtb3N0KSB0aWwgdGhlIGVuZCBpcyBidWZmZXJlZCwgbGV0J3Mgc2lnbmFsIGVvc1xuICAgICAgICAvLyB3ZSBkb24ndCBjb21wYXJlIGV4YWN0bHkgbWVkaWEuZHVyYXRpb24gPT09IGJ1ZmZlckluZm8uZW5kIGFzIHRoZXJlIGNvdWxkIGJlIHNvbWUgc3VidGxlIG1lZGlhIGR1cmF0aW9uIGRpZmZlcmVuY2Ugd2hlbiBzd2l0Y2hpbmdcbiAgICAgICAgLy8gYmV0d2VlbiBkaWZmZXJlbnQgcmVuZGl0aW9ucy4gdXNpbmcgaGFsZiBmcmFnIGR1cmF0aW9uIHNob3VsZCBoZWxwIGNvcGUgd2l0aCB0aGVzZSBjYXNlcy5cbiAgICAgICAgaWYgKCFtZWRpYS5zZWVraW5nIHx8IChtZWRpYS5kdXJhdGlvbi1idWZmZXJJbmZvLmVuZCkgPD0gZnJhZ1ByZXZpb3VzLmR1cmF0aW9uLzIpIHtcbiAgICAgICAgLy8gRmluYWxpemUgdGhlIG1lZGlhIHN0cmVhbVxuICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hdWRpb1RyYWNrVHlwZSA9PT0gJ0FVRElPJykge1xuICAgICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLGRhdGEpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgdGhlIGxldmVsRGV0YWlscyBmb3IgdGhlIHNlbGVjdGVkIHZhcmlhbnQsIGxldHMgY29udGludWUgZW5yaWNoZW4gb3VyIHN0cmVhbSAobG9hZCBrZXlzL2ZyYWdtZW50cyBvciB0cmlnZ2VyIEVPUywgZXRjLi4pXG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoUGF5bG9hZE9yRW9zKHtwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlsc30pO1xuICB9XG5cbiAgX2ZldGNoUGF5bG9hZE9yRW9zKHtwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlsc30pIHtcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWw7XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGxldCBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXG4gICAgICAgIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuLTFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4tMV0uZHVyYXRpb24sXG4gICAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxuICAgICAgICBmcmFnO1xuXG4gICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBmcmFnID0gdGhpcy5fZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCh7bGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVufSk7XG4gICAgICAvLyBpZiBpdCBleHBsaWNpdGVseSByZXR1cm5zIG51bGwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnQgYW5kIGV4aXQgZnVuY3Rpb24gbm93XG4gICAgICBpZiAoZnJhZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICBpZiAoYnVmZmVyRW5kIDwgc3RhcnQpIHtcbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICBmcmFnID0gdGhpcy5fZmluZEZyYWdtZW50KHtzdGFydCwgZnJhZ1ByZXZpb3VzLCBmcmFnTGVuLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHN9KTtcbiAgICB9XG4gICAgaWYoZnJhZykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRGcmFnbWVudE9yS2V5KHtmcmFnLCBsZXZlbCwgbGV2ZWxEZXRhaWxzLCBwb3MsIGJ1ZmZlckVuZH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KHtsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW59KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgbGV0IGZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxuICAgIC8vbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XG4gICAgbGV0IG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KmxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydCwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcbiAgICAgICAgbGV0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc3RhcnQsIGxldmVsRGV0YWlscyk7XG4gICAgICAgIGxvZ2dlci5sb2coYGJ1ZmZlciBlbmQ6ICR7YnVmZmVyRW5kfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdCwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgICAgYnVmZmVyRW5kID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUgJiYgbWVkaWEuZHVyYXRpb24gPiBsaXZlU3luY1Bvc2l0aW9uKSB7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgZW5kIG9mIGJ1ZmZlciBncmVhdGVyIHRoYW4gbGl2ZSBlZGdlLCBkb24ndCBsb2FkIGFueSBmcmFnbWVudFxuICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIGxpdmUgcGxheWxpc3QgaW50ZXJtaXR0ZW50bHkgc2xpZGVzIGluIHRoZSBwYXN0LlxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjEsMTgyNTgwMTY3XVxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY5XVxuICAgIC8vIExvYWRpbmcgMTgyNTgwMTY4IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxuICAgIC8vIExvYWRpbmcgMTgyNTgwMTY5IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY4XSA8PT09PT09PT09PT09PSBoZXJlIHdlIHNob3VsZCBoYXZlIGJ1ZmZlckVuZCA+IGVuZC4gaW4gdGhhdCBjYXNlIGJyZWFrIHRvIGF2b2lkIHJlbG9hZGluZyAxODI1ODAxNjhcbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTY0LDE4MjU4MDE3MV1cbiAgICAvL1xuICAgIGlmIChsZXZlbERldGFpbHMuUFRTS25vd24gJiYgYnVmZmVyRW5kID4gZW5kKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgIWxldmVsRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgLyogd2UgYXJlIHN3aXRjaGluZyBsZXZlbCBvbiBsaXZlIHBsYXlsaXN0LCBidXQgd2UgZG9uJ3QgaGF2ZSBhbnkgUFRTIGluZm8gZm9yIHRoYXQgcXVhbGl0eSBsZXZlbCAuLi5cbiAgICAgICAgIHRyeSB0byBsb2FkIGZyYWcgbWF0Y2hpbmcgd2l0aCBuZXh0IFNOLlxuICAgICAgICAgZXZlbiBpZiBTTiBhcmUgbm90IHN5bmNocm9uaXplZCBiZXR3ZWVuIHBsYXlsaXN0cywgbG9hZGluZyB0aGlzIGZyYWcgd2lsbCBoZWxwIHVzXG4gICAgICAgICBjb21wdXRlIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZSBhZnRlciBpbiBjYXNlIGl0IHdhcyBub3QgdGhlIHJpZ2h0IGNvbnNlY3V0aXZlIG9uZSAqL1xuICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICAgICBzbyBsZXQncyBsb2FkIG1pZCBmcmFnbWVudC4gaXQgd2lsbCBoZWxwIGNvbXB1dGluZyBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmVcbiAgICAgICAgKi9cbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCB1bmtub3duLCBsb2FkIG1pZGRsZSBmcmFnIDogJHtmcmFnLnNufWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIF9maW5kRnJhZ21lbnQoe3N0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlsc30pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICBsZXQgZnJhZyxcbiAgICAgICAgZm91bmRGcmFnLFxuICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG5cbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICBpZiAoYnVmZmVyRW5kID4gZW5kIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICAgIH1cbiAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgICAgICAgIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgICAgICAgICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgLy9sb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgICAgICBpZiAoKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9Ly8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXTtcbiAgICB9XG4gICAgaWYgKGZvdW5kRnJhZykge1xuICAgICAgZnJhZyA9IGZvdW5kRnJhZztcbiAgICAgIHN0YXJ0ID0gZm91bmRGcmFnLnN0YXJ0O1xuICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgaWYgKGZyYWcuc24gPCBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICBsZXQgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXMuZGVsdGFQVFMsXG4gICAgICAgICAgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzaWduaWZpY2FudCBkZWx0YSBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbGFyZ2VyIHRoYW4gbWF4IGFsbG93ZWQgaG9sZSxcbiAgICAgICAgICAvLyBhbmQgaWYgcHJldmlvdXMgcmVtdXhlZCBmcmFnbWVudCBkaWQgbm90IHN0YXJ0IHdpdGggYSBrZXlmcmFtZS4gKGZyYWdQcmV2aW91cy5kcm9wcGVkKVxuICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBsb2FkIHByZXZpb3VzIGZyYWdtZW50IGFnYWluIHRvIGdldCBsYXN0IGtleWZyYW1lXG4gICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIHJlbG9hZCBhZ2FpbiBjdXJyZW50IGZyYWdtZW50ICh0aGF0IHdheSB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaWxsIHRoZSBidWZmZXIgaG9sZSAuLi4pXG4gICAgICAgICAgaWYgKGRlbHRhUFRTICYmIGRlbHRhUFRTID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgZnJhZ1ByZXZpb3VzLmRyb3BwZWQgJiYgY3VyU05JZHgpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHgtMV07XG4gICAgICAgICAgICBsb2dnZXIud2FybihgU04ganVzdCBsb2FkZWQsIHdpdGggbGFyZ2UgUFRTIGdhcCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbWF5YmUgZnJhZyBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lID8gbG9hZCBwcmV2aW91cyBvbmUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNgKTtcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCBwcmV2aW91cyBmcmFnIGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciB3aGVuIG5leHQgZnJhZ21lbnQgd2lsbCBnZXQgcmVsb2FkZWRcbiAgICAgICAgICAgIGZyYWdQcmV2aW91cy5sb2FkQ291bnRlci0tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4KzFdO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBfbG9hZEZyYWdtZW50T3JLZXkoe2ZyYWcsIGxldmVsLCBsZXZlbERldGFpbHMsIHBvcywgYnVmZmVyRW5kfSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWc7XG5cbiAgICAvL2xvZ2dlci5sb2coJ2xvYWRpbmcgZnJhZyAnICsgaSArJyxwb3MvYnVmRW5kOicgKyBwb3MudG9GaXhlZCgzKSArICcvJyArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcbiAgICBpZiAoKGZyYWcuZGVjcnlwdGRhdGEudXJpICE9IG51bGwpICYmIChmcmFnLmRlY3J5cHRkYXRhLmtleSA9PSBudWxsKSkge1xuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7bGV2ZWxEZXRhaWxzLnN0YXJ0U059ICwke2xldmVsRGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9YCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259IG9mIFske2xldmVsRGV0YWlscy5zdGFydFNOfSAsJHtsZXZlbERldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfSwgY3VycmVudFRpbWU6JHtwb3N9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xuICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXG4gICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICBsZXQgbWF4VGhyZXNob2xkID0gY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIDMgdGltZXMsIGFuZCBpZiBpdCBoYXMgYmVlbiByZWxvYWRlZCByZWNlbnRseVxuICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XG4gICAgICB9XG4gICAgICBmcmFnLmxvYWRJZHggPSB0aGlzLmZyYWdMb2FkSWR4O1xuICAgICAgZnJhZy5hdXRvTGV2ZWwgPSBobHMuYXV0b0xldmVsRW5hYmxlZDtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgZW5naW5lIHN0YXRlIHRyYW5zaXRpb24gZnJvbSAke3ByZXZpb3VzU3RhdGV9IHRvICR7bmV4dFN0YXRlfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVFJFQU1fU1RBVEVfVFJBTlNJVElPTiwge3ByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZX0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICBnZXRCdWZmZXJSYW5nZShwb3NpdGlvbikge1xuICAgIHZhciBpLCByYW5nZSxcbiAgICAgICAgYnVmZmVyUmFuZ2UgPSB0aGlzLmJ1ZmZlclJhbmdlO1xuICAgIGlmIChidWZmZXJSYW5nZSkge1xuICAgICAgZm9yIChpID0gYnVmZmVyUmFuZ2UubGVuZ3RoIC0gMTsgaSA+PTA7IGktLSkge1xuICAgICAgICByYW5nZSA9IGJ1ZmZlclJhbmdlW2ldO1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gcmFuZ2Uuc3RhcnQgJiYgcG9zaXRpb24gPD0gcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRCdWZmZXJSYW5nZSh0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZnJhZy5sZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZ2V0IG5leHRCdWZmZXJSYW5nZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgLy8gZmlyc3QgZ2V0IGVuZCByYW5nZSBvZiBjdXJyZW50IGZyYWdtZW50XG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJSYW5nZSh0aGlzLmdldEJ1ZmZlclJhbmdlKHRoaXMubWVkaWEuY3VycmVudFRpbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZm9sbG93aW5nQnVmZmVyUmFuZ2UocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlclJhbmdlKHJhbmdlLmVuZCArIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IG5leHRMZXZlbCgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLm5leHRCdWZmZXJSYW5nZTtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZS5mcmFnLmxldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgaXNCdWZmZXJlZChwb3NpdGlvbikge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBsZXQgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9jaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICB2YXIgcmFuZ2VDdXJyZW50LCBjdXJyZW50VGltZSwgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbyAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXG4gICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxuICAgICAgKi9cbiAgICAgIGlmKGN1cnJlbnRUaW1lID4gdmlkZW8ucGxheWJhY2tSYXRlKnRoaXMubGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0J1ZmZlcmVkKGN1cnJlbnRUaW1lKSkge1xuICAgICAgICByYW5nZUN1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0J1ZmZlcmVkKGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXG4gICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxuICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgIHJhbmdlQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuICAgICAgaWYgKHJhbmdlQ3VycmVudCkge1xuICAgICAgICB2YXIgZnJhZ1BsYXlpbmcgPSByYW5nZUN1cnJlbnQuZnJhZztcbiAgICAgICAgaWYgKGZyYWdQbGF5aW5nICE9PSB0aGlzLmZyYWdQbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19DSEFOR0VELCB7ZnJhZzogZnJhZ1BsYXlpbmd9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICBsb2dnZXIubG9nKCdpbW1lZGlhdGVMZXZlbFN3aXRjaCcpO1xuICAgIGlmICghdGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gdHJ1ZTtcbiAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsIHByZXZpb3VzbHlQYXVzZWQ7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IG1lZGlhLnBhdXNlZDtcbiAgICAgICAgbWVkaWEucGF1c2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvbid0IHJlc3RhcnQgcGxheWJhY2sgYWZ0ZXIgaW5zdGFudCBsZXZlbCBzd2l0Y2ggaW4gY2FzZSBtZWRpYSBub3QgYXR0YWNoZWRcbiAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZpb3VzbHlQYXVzZWQgPSBwcmV2aW91c2x5UGF1c2VkO1xuICAgIH1cbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywge3N0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0pO1xuICB9XG5cbiAgLypcbiAgICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCBlbmQsIGFmdGVyIG5ldyBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZCA6XG4gICAgICAtIG51ZGdlIHZpZGVvIGRlY29kZXIgYnkgc2xpZ2h0bHkgYWRqdXN0aW5nIHZpZGVvIGN1cnJlbnRUaW1lIChpZiBjdXJyZW50VGltZSBidWZmZXJlZClcbiAgICAgIC0gcmVzdW1lIHRoZSBwbGF5YmFjayBpZiBuZWVkZWRcbiAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IGZhbHNlO1xuICAgICAgaWYodGhpcy5pc0J1ZmZlcmVkKG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgICAvLyBvbmx5IG51ZGdlIGlmIGN1cnJlbnRUaW1lIGlzIGJ1ZmZlcmVkXG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lIC09IDAuMDAwMTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wcmV2aW91c2x5UGF1c2VkKSB7XG4gICAgICAgIG1lZGlhLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgLyogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2sgOlxuICAgICAgIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICAgIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAgICB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgbmV3IHNlZ21lbnQgZmV0Y2ggdGltZVxuICAgICovXG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheSwgY3VycmVudFJhbmdlLCBuZXh0UmFuZ2U7XG4gICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgY3VycmVudFJhbmdlID0gdGhpcy5nZXRCdWZmZXJSYW5nZShtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICBpZiAoY3VycmVudFJhbmdlICYmIGN1cnJlbnRSYW5nZS5zdGFydCA+IDEpIHtcbiAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBjdXJyZW50UmFuZ2Uuc3RhcnQgLSAxfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCkge1xuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcbiAgICAgICAgdmFyIG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbCxuZXh0TGV2ZWwgPSB0aGlzLmxldmVsc1tuZXh0TGV2ZWxJZF0sIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5iaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICAvL2xvZ2dlci5sb2coJ2ZldGNoZGVsYXk6JytmZXRjaGRlbGF5KTtcbiAgICAgIC8vIGZpbmQgYnVmZmVyIHJhbmdlIHRoYXQgd2lsbCBiZSByZWFjaGVkIG9uY2UgbmV3IGZyYWdtZW50IHdpbGwgYmUgZmV0Y2hlZFxuICAgICAgbmV4dFJhbmdlID0gdGhpcy5nZXRCdWZmZXJSYW5nZShtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuICAgICAgaWYgKG5leHRSYW5nZSkge1xuICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgIG5leHRSYW5nZSA9IHRoaXMuZm9sbG93aW5nQnVmZmVyUmFuZ2UobmV4dFJhbmdlKTtcbiAgICAgICAgaWYgKG5leHRSYW5nZSkge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAvLyBmbHVzaCBwb3NpdGlvbiBpcyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhpcyBuZXcgYnVmZmVyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywge3N0YXJ0T2Zmc2V0OiBuZXh0UmFuZ2Uuc3RhcnQsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkaW5nIGNvdW50ZXIgb24gTVNFIGRldGFjaGluZyB0byBhdm9pZCByZXBvcnRpbmcgRlJBR19MT09QX0xPQURJTkdfRVJST1IgYWZ0ZXIgZXJyb3IgcmVjb3ZlcnlcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZCBjb3VudGVyXG4gICAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgICBpZihsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gIH1cblxuICBvbk1lZGlhU2Vla2luZygpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiB1bmRlZmluZWQ7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc2Vla2luZyB0byAnICsgY3VycmVudFRpbWUpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcpIHtcbiAgICAgIGxldCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsY3VycmVudFRpbWUsdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIHNlZWtpbmcgdG8gYSB1bmJ1ZmZlcmVkIGFyZWEgQU5EIGlmIGZyYWcgbG9hZGluZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGZyYWdDdXJyZW50KSB7XG4gICAgICAgIGxldCB0b2xlcmFuY2UgPSB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgICAgICAgICAgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2UsXG4gICAgICAgICAgICBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugc2VlayBwb3NpdGlvbiB3aWxsIGJlIG91dCBvZiBjdXJyZW50bHkgbG9hZGVkIGZyYWcgcmFuZ2UgOiBpZiBvdXQgY2FuY2VsIGZyYWcgbG9hZCwgaWYgaW4sIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIHdoaWxlIGZyYWdtZW50IGxvYWQgaW4gcHJvZ3Jlc3MsIGNhbmNlbCBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciBidXQgd2l0aGluIGN1cnJlbnRseSBsb2FkZWQgZnJhZ21lbnQgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gY2hlY2sgZm9yIHBvdGVudGlhbCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRlJBR19MT0FESU5HICYmIHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgIH1cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVrZWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc2Vla2VkIHRvICcgKyB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdNRU5UX1BMQVlJTkcgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25NZWRpYUVuZGVkKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIGVuZGVkJyk7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cblxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIGxvZ2dlci5sb2coJ3RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfUkVTRVQpO1xuICAgIHRoaXMuYnVmZmVyUmFuZ2UgPSBbXTtcbiAgICB0aGlzLnN0YWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcbiAgICB2YXIgYWFjID0gZmFsc2UsIGhlYWFjID0gZmFsc2UsIGNvZGVjO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICAgIGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XG4gICAgICAgICAgYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gKGFhYyAmJiBoZWFhYyk7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgbG9nZ2VyLmxvZygnYm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xuICAgIH1cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIHRoaXMuc3RhcnRMZXZlbExvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBvbkxldmVsTG9hZGVkKGRhdGEpIHtcbiAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWwsXG4gICAgICAgIGN1ckxldmVsID0gdGhpcy5sZXZlbHNbbmV3TGV2ZWxJZF0sXG4gICAgICAgIGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICBzbGlkaW5nID0gMDtcblxuICAgIGxvZ2dlci5sb2coYGxldmVsICR7bmV3TGV2ZWxJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0sZHVyYXRpb246JHtkdXJhdGlvbn1gKTtcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG5ld0xldmVsSWQ7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB2YXIgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XG4gICAgICBpZiAoY3VyRGV0YWlscykge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscyxuZXdEZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9VUERBVEVELCB7IGRldGFpbHM6IG5ld0RldGFpbHMsIGxldmVsOiBuZXdMZXZlbElkIH0pO1xuXG4gICAgaWYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID09PSBmYWxzZSkge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYoIWlzTmFOKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgJHtzdGFydFRpbWVPZmZzZXR9LCBjb3VudCBmcm9tIGVuZCBvZiBsYXN0IGZyYWdtZW50YCk7XG4gICAgICAgICAgICBzdGFydFRpbWVPZmZzZXQgPSBzbGlkaW5nICsgZHVyYXRpb24gKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgc2V0IHN0YXJ0IHBvc2l0aW9uIHRvIGJlIGZyYWdtZW50IE4tdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICh1c3VhbGx5IDMpXG4gICAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gJHt0aGlzLnN0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbktleUxvYWRlZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcbiAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5mcmFnLnR5cGUgPT09ICdtYWluJyAmJlxuICAgICAgICBkYXRhLmZyYWcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIGRhdGEuZnJhZy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcbiAgICAgIGxvZ2dlci5sb2coYExvYWRlZCAgJHtmcmFnQ3VycmVudC5zbn0gb2YgbGV2ZWwgJHtmcmFnQ3VycmVudC5sZXZlbH1gKTtcbiAgICAgIGlmICh0aGlzLmZyYWdCaXRyYXRlVGVzdCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIC4uLiB3ZSBqdXN0IGxvYWRlZCBhIGZyYWdtZW50IHRvIGRldGVybWluZSBhZGVxdWF0ZSBzdGFydCBiaXRyYXRlIGFuZCBpbml0aWFsaXplIGF1dG9zd2l0Y2ggYWxnb1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5mcmFnQml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5zdGF0cy50cGFyc2VkID0gZGF0YS5zdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IGRhdGEuc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZCA6ICdtYWluJ30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAgICAgdGhpcy5zdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXSxcbiAgICAgICAgICAgIGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscyxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnQgPSBmcmFnQ3VycmVudC5zdGFydERUUyAhPT0gdW5kZWZpbmVkID8gZnJhZ0N1cnJlbnQuc3RhcnREVFMgIDogZnJhZ0N1cnJlbnQuc3RhcnQsXG4gICAgICAgICAgICBsZXZlbCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgICAgaWYodGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgaWYoYXVkaW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5sYXN0QXVkaW9Db2RlYztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoYXVkaW9Db2RlYykge1xuICAgICAgICAgICAgaWYoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0tMSkge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZyA9IDA7XG4gICAgICAgIGxvZ2dlci5sb2coYERlbXV4aW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9LCBjYyAke2ZyYWdDdXJyZW50LmNjfWApO1xuICAgICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICAgICAgZGVtdXhlciA9IHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCdtYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgYXVkaW9Db2RlYywgY3VycmVudExldmVsLnZpZGVvQ29kZWMsIHN0YXJ0LCBmcmFnQ3VycmVudC5jYywgbGV2ZWwsIHNuLCBkdXJhdGlvbiwgZnJhZ0N1cnJlbnQuZGVjcnlwdGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICB9XG5cbiAgb25GcmFnUGFyc2luZ0luaXRTZWdtZW50KGRhdGEpIHtcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdmFyIHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFja05hbWUsIHRyYWNrO1xuXG4gICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICAgIGlmICh0cmFja3MuYXVkaW8gJiYgdGhpcy5hdWRpb1RyYWNrVHlwZSA9PT0gJ0FVRElPJykge1xuICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgfVxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgaWYodHJhY2spIHtcbiAgICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS5hdWRpb0NvZGVjLFxuICAgICAgICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmKGF1ZGlvQ29kZWMgJiYgdGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgaWYoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0tMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2UgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3RcbiAgICAgICAgLy8gZm9yY2UgSEUtQUFDICwgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgdGhhdCB3YXksXG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgbW9ubyBzdHJlYW1zIE9SIG9uIEZGXG4gICAgICAgIC8vIHRoZXNlIGNvbmRpdGlvbnMgbWlnaHQgbmVlZCB0byBiZSByZXZpZXdlZCAuLi5cbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtXG4gICAgICAgICAgIGlmKHRyYWNrLm1ldGFkYXRhLmNoYW5uZWxDb3VudCAhPT0gMSAmJlxuICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIGZpcmVmb3hcbiAgICAgICAgICAgIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG4gICAgICAgIGlmKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG9gICsgYXVkaW9Db2RlYyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgIH1cbiAgICAgIHRyYWNrID0gdHJhY2tzLnZpZGVvO1xuICAgICAgaWYodHJhY2spIHtcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLnZpZGVvQ29kZWM7XG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgcmVtdXhlciBzcGVjaWZ5IHRoYXQgYSB1bmlxdWUgdHJhY2sgbmVlZHMgdG8gZ2VuZXJhdGVkLFxuICAgICAgLy8gbGV0J3MgbWVyZ2UgYWxsIHRyYWNrcyB0b2dldGhlclxuICAgICAgaWYgKGRhdGEudW5pcXVlKSB7XG4gICAgICAgIHZhciBtZXJnZWRUcmFjayA9IHtcbiAgICAgICAgICAgIGNvZGVjIDogJycsXG4gICAgICAgICAgICBsZXZlbENvZGVjIDogJydcbiAgICAgICAgICB9O1xuICAgICAgICBmb3IgKHRyYWNrTmFtZSBpbiBkYXRhLnRyYWNrcykge1xuICAgICAgICAgIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgICAgbWVyZ2VkVHJhY2suY29udGFpbmVyID0gdHJhY2suY29udGFpbmVyO1xuICAgICAgICAgIGlmIChtZXJnZWRUcmFjay5jb2RlYykge1xuICAgICAgICAgICAgbWVyZ2VkVHJhY2suY29kZWMgKz0gICcsJztcbiAgICAgICAgICAgIG1lcmdlZFRyYWNrLmxldmVsQ29kZWMgKz0gICcsJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodHJhY2suY29kZWMpIHtcbiAgICAgICAgICAgIG1lcmdlZFRyYWNrLmNvZGVjICs9ICB0cmFjay5jb2RlYztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrLmxldmVsQ29kZWMpIHtcbiAgICAgICAgICAgIG1lcmdlZFRyYWNrLmxldmVsQ29kZWMgKz0gIHRyYWNrLmxldmVsQ29kZWM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyYWNrcyA9IHsgYXVkaW92aWRlbyA6IG1lcmdlZFRyYWNrIH07XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsdHJhY2tzKTtcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuICAgICAgZm9yICh0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICAgIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gdHJhY2s6JHt0cmFja05hbWV9LGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XG4gICAgICAgIHZhciBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmcrKztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHt0eXBlOiB0cmFja05hbWUsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQgOiAnbWFpbicsIGNvbnRlbnQgOiAnaW5pdFNlZ21lbnQnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ0RhdGEoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAoZGF0YS50eXBlICE9PSAnYXVkaW8nIHx8IHRoaXMuYXVkaW9UcmFja1R5cGUgIT09ICdBVURJTycpICYmIC8vIGZpbHRlciBvdXQgbWFpbiBhdWRpbyBpZiBhdWRpbyB0cmFjayBpcyBsb2FkZWQgdGhyb3VnaCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXSxcbiAgICAgICAgICBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkICR7ZGF0YS50eXBlfSxQVFM6WyR7ZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpfSwke2RhdGEuZW5kUFRTLnRvRml4ZWQoMyl9XSxEVFM6WyR7ZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpfS8ke2RhdGEuZW5kRFRTLnRvRml4ZWQoMyl9XSxuYjoke2RhdGEubmJ9LGRyb3BwZWQ6JHtkYXRhLmRyb3BwZWQgfHwgMH1gKTtcblxuICAgICAgdmFyIGRyaWZ0ID0gTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhsZXZlbC5kZXRhaWxzLGZyYWcuc24sZGF0YS5zdGFydFBUUyxkYXRhLmVuZFBUUyxkYXRhLnN0YXJ0RFRTLGRhdGEuZW5kRFRTKSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1BUU19VUERBVEVELCB7ZGV0YWlsczogbGV2ZWwuZGV0YWlscywgbGV2ZWw6IHRoaXMubGV2ZWwsIGRyaWZ0OiBkcmlmdH0pO1xuXG4gICAgICAvLyBoYXMgcmVtdXhlciBkcm9wcGVkIHZpZGVvIGZyYW1lcyBsb2NhdGVkIGJlZm9yZSBmaXJzdCBrZXlmcmFtZSA/XG4gICAgICBpZihkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgZnJhZy5kcm9wcGVkID0gZGF0YS5kcm9wcGVkO1xuICAgICAgfVxuXG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQXBwZW5kaW5nKys7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywge3R5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQgOiAnbWFpbicsY29udGVudCA6ICdkYXRhJ30pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZGF0YS5lbmRQVFM7XG4gICAgICB0aGlzLmJ1ZmZlclJhbmdlLnB1c2goe3R5cGU6IGRhdGEudHlwZSwgc3RhcnQ6IGRhdGEuc3RhcnRQVFMsIGVuZDogZGF0YS5lbmRQVFMsIGZyYWc6IGZyYWd9KTtcblxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoKGRhdGEpIHtcbiAgICB2YXIgYXVkaW9UcmFja1R5cGUgPSBkYXRhLnR5cGU7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIGlmIChhdWRpb1RyYWNrVHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIC8vIGRlc3Ryb3kgZGVtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcbiAgICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgIGlmICh0aGlzLnZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMudmlkZW9CdWZmZXIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hdWRpb1RyYWNrVHlwZSA9IGF1ZGlvVHJhY2tUeXBlO1xuICB9XG5cblxuICBvbkJ1ZmZlckNyZWF0ZWQoZGF0YSkge1xuICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgbWVkaWFUcmFjaywgbmFtZSwgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgZm9yKHZhciB0eXBlIGluIHRyYWNrcykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSB0cmFja3NbdHlwZV0uYnVmZmVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIGxvZ2dlci5sb2coYGFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kZWQoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmctLTtcbiAgICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQoKSB7XG4gICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiB0aGlzLnBlbmRpbmdBcHBlbmRpbmcgPT09IDApICB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIHdlIHNob3VsZCBnZXQgcmlkIG9mIHRoaXMuZnJhZ0xhc3RLYnBzXG4gICAgICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudGZpcnN0KSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQgOiAnbWFpbid9KTtcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIGJ1ZmZlcmVkIDogJHtUaW1lUmFuZ2VzLnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnbWFpbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5IHx8XG4gICAgICAgICAgICAvLyBrZWVwIHJldHJ5aW5nIC8gZG9uJ3QgcmFpc2UgZmF0YWwgbmV0d29yayBlcnJvciBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgICAgICAodGhpcy5tZWRpYSAmJiB0aGlzLmlzQnVmZmVyZWQodGhpcy5tZWRpYS5jdXJyZW50VGltZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgICAvLyByZXNldCBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gNjRzXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLGxvYWRFcnJvci0xKSp0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksNjQwMDApO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYG1lZGlhQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBtZWRpYUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5gKTtcbiAgICAgICAgICAgIC8vIHJlZGlzcGF0Y2ggc2FtZSBlcnJvciBidXQgd2l0aCBmYXRhbCBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vICB3aGVuIGluIEVSUk9SIHN0YXRlLCBkb24ndCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGluIGNhc2UgYSBub24tZmF0YWwgZXJyb3IgaXMgcmVjZWl2ZWRcbiAgICAgICAgaWYodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmcsIG90aGVyd2lzZSBtb3ZlIHRvIElETEUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBTdGF0ZS5FUlJPUiA6IFN0YXRlLklETEU7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbWVkaWFDb250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gd2hpbGUgbG9hZGluZyBmcmFnLHN3aXRjaCB0byAke3RoaXMuc3RhdGV9IHN0YXRlIC4uLmApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIC8vIG9ubHkgcmVkdWNlIG1heCBidWYgbGVuIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fMKgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICAgICAgdGhpcy5jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoLz0yO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHt0aGlzLmNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9cyBhbmQgc3dpdGNoIHRvIElETEUgc3RhdGVgKTtcbiAgICAgICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG5fY2hlY2tCdWZmZXIoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvciwgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB2YXIgaXNTYWZhcmkgPSB2ZW5kb3IgJiYgdmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJiB1c2VyQWdlbnQgJiYgIXVzZXJBZ2VudC5tYXRjaCgnQ3JpT1MnKTtcbiAgICAvLyBpZiByZWFkeSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMCksIHdlIGFyZSBhbGxvd2VkIHRvIHNlZWtcbiAgICBpZihtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgIGJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQ7XG4gICAgICAvLyBhZGp1c3QgY3VycmVudFRpbWUgdG8gc3RhcnQgcG9zaXRpb24gb24gbG9hZGVkIG1ldGFkYXRhXG4gICAgICBpZighdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAgICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICAgICAgbGV0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uQnVmZmVyZWQgPSB0aGlzLmlzQnVmZmVyZWQoc3RhcnRQb3NpdGlvbik7XG4gICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIG5vdCBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIHN0YXJ0UG9zaXRpb24gb3Igc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGFydFBvc2l0aW9uIHx8ICFzdGFydFBvc2l0aW9uQnVmZmVyZWQpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGB0YXJnZXQgc3RhcnQgcG9zaXRpb246JHtzdGFydFBvc2l0aW9ufWApO1xuICAgICAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBsZXQncyBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApXG4gICAgICAgICAgaWYoIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCkge1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGJ1ZmZlcmVkLnN0YXJ0KDApO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIG5vdCBidWZmZXJlZCwgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKSAke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICAvLyByZWFkeVN0YXRlIDw9IDIgY2FuIG5vdCBzdWNjZXNzZnVsbHkgc2VlayBpbiBzYWZhcmlcbiAgICAgICAgICBpZiAoIWlzU2FmYXJpIHx8IG1lZGlhLnJlYWR5U3RhdGUgPiAyKSB7XG4gICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLGN1cnJlbnRUaW1lLDApLFxuICAgICAgICAgICAgZXhwZWN0ZWRQbGF5aW5nID0gIShtZWRpYS5wYXVzZWQgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBwYXVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWEuZW5kZWQgIHx8IC8vIG5vdCBwbGF5aW5nIHdoZW4gbWVkaWEgaXMgZW5kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWEuYnVmZmVyZWQubGVuZ3RoID09PSAwKSwgLy8gbm90IHBsYXlpbmcgaWYgbm90aGluZyBidWZmZXJlZFxuICAgICAgICAgICAganVtcFRocmVzaG9sZCA9IDAuNCwgLy8gdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgcmFuZ2UgZW5kXG4gICAgICAgICAgICBwbGF5aGVhZE1vdmluZyA9IGN1cnJlbnRUaW1lID4gbWVkaWEucGxheWJhY2tSYXRlKnRoaXMubGFzdEN1cnJlbnRUaW1lO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YWxsZWQgJiYgcGxheWhlYWRNb3ZpbmcpIHtcbiAgICAgICAgICB0aGlzLnN0YWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAJHtjdXJyZW50VGltZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBidWZmZXIgdXBmcm9udFxuICAgICAgICAvLyBpZiBsZXNzIHRoYW4ganVtcFRocmVzaG9sZCBzZWNvbmQgaXMgYnVmZmVyZWQsIGxldCdzIGNoZWNrIGluIG1vcmUgZGV0YWlsc1xuICAgICAgICBpZihleHBlY3RlZFBsYXlpbmcgJiYgYnVmZmVySW5mby5sZW4gPD0ganVtcFRocmVzaG9sZCkge1xuICAgICAgICAgIGlmKHBsYXloZWFkTW92aW5nKSB7XG4gICAgICAgICAgICAvLyBwbGF5aGVhZCBtb3ZpbmdcbiAgICAgICAgICAgIGp1bXBUaHJlc2hvbGQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb24gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwbGF5aGVhZCBub3QgbW92aW5nIEFORCBtZWRpYSBleHBlY3RlZCB0byBwbGF5XG4gICAgICAgICAgICBpZighdGhpcy5zdGFsbGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgcGxheWJhY2sgc2VlbXMgc3R1Y2sgQCR7Y3VycmVudFRpbWV9YCk7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiBmYWxzZX0pO1xuICAgICAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb24gKz0gdGhpcy5jb25maWcuc2Vla0hvbGVOdWRnZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgYmVsb3cgdGhyZXNob2xkLCB0cnkgdG8ganVtcCB0byBzdGFydCBvZiBuZXh0IGJ1ZmZlciByYW5nZSBpZiBjbG9zZVxuICAgICAgICAgIGlmKGJ1ZmZlckluZm8ubGVuIDw9IGp1bXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIC8vIG5vIGJ1ZmZlciBhdmFpbGFibGUgQCBjdXJyZW50VGltZSwgY2hlY2sgaWYgbmV4dCBidWZmZXIgaXMgY2xvc2UgKHdpdGhpbiBhIGNvbmZpZy5tYXhTZWVrSG9sZSBzZWNvbmQgcmFuZ2UpXG4gICAgICAgICAgICB2YXIgbmV4dEJ1ZmZlclN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQsIGRlbHRhID0gbmV4dEJ1ZmZlclN0YXJ0LWN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgaWYobmV4dEJ1ZmZlclN0YXJ0ICYmXG4gICAgICAgICAgICAgICAoZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhTZWVrSG9sZSkgJiZcbiAgICAgICAgICAgICAgIChkZWx0YSA+IDApKSB7XG4gICAgICAgICAgICAgIC8vIG5leHQgYnVmZmVyIGlzIGNsb3NlICEgYWRqdXN0IGN1cnJlbnRUaW1lIHRvIG5leHRCdWZmZXJTdGFydFxuICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgZW5zdXJlIGVmZmVjdGl2ZSB2aWRlbyBkZWNvZGluZ1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke21lZGlhLmN1cnJlbnRUaW1lfSB0byBuZXh0IGJ1ZmZlcmVkIEAgJHtuZXh0QnVmZmVyU3RhcnR9ICsgbnVkZ2UgJHt0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbn1gKTtcbiAgICAgICAgICAgICAgbGV0IGhvbGUgPSBuZXh0QnVmZmVyU3RhcnQgKyB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiAtIG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAvLyBmcmVxdWVudGx5IHNlZWtpbmcgbWF5IGNhdXNlIGZyZXF1ZW50bHkgZmxpY2tlciBpbiBzYWZhcmlcbiAgICAgICAgICAgICAgaWYgKCFpc1NhZmFyaSB8fCAodGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb24gJiYgdGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb24gJSAoMTAgKiB0aGlzLmNvbmZpZy5zZWVrSG9sZU51ZGdlRHVyYXRpb24pIDwgdGhpcy5jb25maWcuc2Vla0hvbGVOdWRnZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dEJ1ZmZlclN0YXJ0ICsgdGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsIGZhdGFsOiBmYWxzZSwgaG9sZSA6IGhvbGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hlZCgpIHtcbiAgICAvKiBhZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgcmVidWlsZCBidWZmZXIgUmFuZ2UgYXJyYXlcbiAgICAgIGxvb3AgdGhyb3VnaCBleGlzdGluZyBidWZmZXIgcmFuZ2UgYW5kIGNoZWNrIGlmXG4gICAgICBjb3JyZXNwb25kaW5nIHJhbmdlIGlzIHN0aWxsIGJ1ZmZlcmVkLiBvbmx5IHB1c2ggdG8gbmV3IGFycmF5IGFscmVhZHkgYnVmZmVyZWQgcmFuZ2VcbiAgICAqL1xuICAgIHZhciBuZXdSYW5nZSA9IFtdLHJhbmdlLGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVyUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJhbmdlID0gdGhpcy5idWZmZXJSYW5nZVtpXTtcbiAgICAgIGlmICh0aGlzLmlzQnVmZmVyZWQoKHJhbmdlLnN0YXJ0ICsgcmFuZ2UuZW5kKSAvIDIpKSB7XG4gICAgICAgIG5ld1JhbmdlLnB1c2gocmFuZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJ1ZmZlclJhbmdlID0gbmV3UmFuZ2U7XG5cbiAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICB9XG5cbiAgc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG5cbiAgY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBsZXZlbERldGFpbHMpIHtcbiAgICBsZXQgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gOiB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgcmV0dXJuIHNsaWRpbmcgKyBNYXRoLm1heCgwLCBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAtIHRhcmdldExhdGVuY3kpO1xuICB9XG5cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpdmVTeW5jUG9zaXRpb247XG4gIH1cblxuICBzZXQgbGl2ZVN5bmNQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2xpdmVTeW5jUG9zaXRpb24gPSB2YWx1ZTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgU3RyZWFtQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIFRpbWVsaW5lIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBDZWE2MDhQYXJzZXIgZnJvbSAnLi4vdXRpbHMvY2VhLTYwOC1wYXJzZXInO1xuXG5jbGFzcyBUaW1lbGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgICAgICAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgICAgICAgICAgICBFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsXG4gICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgICAgICAgICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgICAgICAgICAgICBFdmVudC5MRVZFTF9TV0lUQ0gpO1xuXG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKVxuICAgIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIGNoYW5uZWwxID1cbiAgICAgIHtcbiAgICAgICAgJ25ld0N1ZSc6IGZ1bmN0aW9uKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFzZWxmLnRleHRUcmFjazEpXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2sxID0gc2VsZi5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgJ1Vua25vd24gQ0MxJywgJ2VuJyk7XG4vLyAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMS5tb2RlID0gJ3Nob3dpbmcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuQ3Vlcy5uZXdDdWUoc2VsZi50ZXh0VHJhY2sxLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFubmVsMiA9XG4gICAgICB7XG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbilcbiAgICAgICAge1xuICAgICAgICAgIGlmICghc2VsZi50ZXh0VHJhY2syKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMiA9IHNlbGYuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsICdVbmtub3duIENDMicsICdlcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuQ3Vlcy5uZXdDdWUoc2VsZi50ZXh0VHJhY2syLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7ICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBDZWE2MDhQYXJzZXIoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICB9XG4gIH1cblxuICBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKVxuICB7XG4gICAgaWYgKHRyYWNrICYmIHRyYWNrLmN1ZXMpXG4gICAge1xuICAgICAgd2hpbGUgKHRyYWNrLmN1ZXMubGVuZ3RoID4gMClcbiAgICAgIHtcbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZylcbiAge1xuICAgIGlmICh0aGlzLm1lZGlhKVxuICAgIHtcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nKClcbiAge1xuICAgIHRoaXMubGFzdFB0cyA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIG9uTGV2ZWxTd2l0Y2goKVxuICB7XG4gICAgaWYgKHRoaXMuaGxzLmN1cnJlbnRMZXZlbC5jbG9zZWRDYXB0aW9ucyA9PT0gJ05PTkUnKVxuICAgIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQoZGF0YSlcbiAge1xuICAgIGlmIChkYXRhLmZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICB2YXIgcHRzID0gZGF0YS5mcmFnLnN0YXJ0OyAvL051bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBmcmFnIGZvciBhIHByZXZpb3VzbHkgbG9hZGVkIHRpbWVyYW5nZSwgcmVtb3ZlIGFsbCBjYXB0aW9uc1xuICAgICAgLy8gVE9ETzogY29uc2lkZXIganVzdCByZW1vdmluZyBjYXB0aW9ucyBmb3IgdGhlIHRpbWVyYW5nZVxuICAgICAgaWYgKHB0cyA8PSB0aGlzLmxhc3RQdHMpXG4gICAgICB7XG4gICAgICB0aGlzLmNsZWFyQ3VycmVudEN1ZXModGhpcy50ZXh0VHJhY2sxKTtcbiAgICAgIHRoaXMuY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazIpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0UHRzID0gcHRzO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YShkYXRhKSB7XG4gICAgLy8gcHVzaCBhbGwgb2YgdGhlIENFQS03MDggbWVzc2FnZXMgaW50byB0aGUgaW50ZXJwcmV0ZXJcbiAgICAvLyBpbW1lZGlhdGVseS4gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIG91ciBQVFMgdmFsdWVcbiAgICBpZiAodGhpcy5lbmFibGVkKVxuICAgIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLnNhbXBsZXMubGVuZ3RoOyBpKyspXG4gICAgICB7XG4gICAgICAgIHZhciBjY2RhdGFzID0gdGhpcy5leHRyYWN0Q2VhNjA4RGF0YShkYXRhLnNhbXBsZXNbaV0uYnl0ZXMpO1xuICAgICAgICB0aGlzLmNlYTYwOFBhcnNlci5hZGREYXRhKGRhdGEuc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSlcbiAge1xuICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgIHZhciBwb3NpdGlvbiA9IDI7XG4gICAgdmFyIHRtcEJ5dGUsIGNjYnl0ZTEsIGNjYnl0ZTIsIGNjVmFsaWQsIGNjVHlwZTtcbiAgICB2YXIgYWN0dWFsQ0NCeXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NieXRlMSA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUyID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjVmFsaWQgPSAoNCAmIHRtcEJ5dGUpID09PSAwID8gZmFsc2UgOiB0cnVlO1xuICAgICAgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XG5cbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgIGlmIChjY1R5cGUgPT09IDApIC8vIHx8IGNjVHlwZSA9PT0gMVxuICAgICAgICB7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lbGluZUNvbnRyb2xsZXI7XG4iLCIvKlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbiBhZGFwdGF0aW9uIG9mIHRoZSBBRVMgZGVjcnlwdGlvbiBhbGdvcml0aG1cbiAqIGZyb20gdGhlIFN0YW5kZm9yZCBKYXZhc2NyaXB0IENyeXB0b2dyYXBoeSBMaWJyYXJ5LiBUaGF0IHdvcmsgaXNcbiAqIGNvdmVyZWQgYnkgdGhlIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIHBlcm1pc3Npb25zIG5vdGljZTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEwIEVtaWx5IFN0YXJrLCBNaWtlIEhhbWJ1cmcsIERhbiBCb25laC5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQVVUSE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTlxuICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uXG4gKiBhcmUgdGhvc2Ugb2YgdGhlIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nXG4gKiBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZCBvciBpbXBsaWVkLCBvZiB0aGUgYXV0aG9ycy5cbiAqL1xuY2xhc3MgQUVTIHtcblxuICAvKipcbiAgICogU2NoZWR1bGUgb3V0IGFuIEFFUyBrZXkgZm9yIGJvdGggZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbi4gVGhpc1xuICAgKiBpcyBhIGxvdy1sZXZlbCBjbGFzcy4gVXNlIGEgY2lwaGVyIG1vZGUgdG8gZG8gYnVsayBlbmNyeXB0aW9uLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIGtleSB7QXJyYXl9IFRoZSBrZXkgYXMgYW4gYXJyYXkgb2YgNCwgNiBvciA4IHdvcmRzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGV4cGFuZGVkIFMtYm94IGFuZCBpbnZlcnNlIFMtYm94IHRhYmxlcy4gVGhlc2Ugd2lsbCBiZSBjb21wdXRlZFxuICAgICAqIG9uIHRoZSBjbGllbnQgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHNlbmQgdGhlbSBkb3duIHRoZSB3aXJlLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byB0YWJsZXMsIF90YWJsZXNbMF0gaXMgZm9yIGVuY3J5cHRpb24gYW5kXG4gICAgICogX3RhYmxlc1sxXSBpcyBmb3IgZGVjcnlwdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCA0IHN1Yi10YWJsZXMgYXJlIHRoZSBleHBhbmRlZCBTLWJveCB3aXRoIE1peENvbHVtbnMuIFRoZVxuICAgICAqIGxhc3QgKF90YWJsZXNbMDFdWzRdKSBpcyB0aGUgUy1ib3ggaXRzZWxmLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90YWJsZXMgPSBbW1tdLFtdLFtdLFtdLFtdXSxbW10sW10sW10sW10sW11dXTtcblxuICAgIHRoaXMuX3ByZWNvbXB1dGUoKTtcblxuICAgIHZhciBpLCBqLCB0bXAsXG4gICAgZW5jS2V5LCBkZWNLZXksXG4gICAgc2JveCA9IHRoaXMuX3RhYmxlc1swXVs0XSwgZGVjVGFibGUgPSB0aGlzLl90YWJsZXNbMV0sXG4gICAga2V5TGVuID0ga2V5Lmxlbmd0aCwgcmNvbiA9IDE7XG5cbiAgICBpZiAoa2V5TGVuICE9PSA0ICYmIGtleUxlbiAhPT0gNiAmJiBrZXlMZW4gIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleUxlbik7XG4gICAgfVxuXG4gICAgZW5jS2V5ID0ga2V5LnNsaWNlKDApO1xuICAgIGRlY0tleSA9IFtdO1xuICAgIHRoaXMuX2tleSA9IFtlbmNLZXksIGRlY0tleV07XG5cbiAgICAvLyBzY2hlZHVsZSBlbmNyeXB0aW9uIGtleXNcbiAgICBmb3IgKGkgPSBrZXlMZW47IGkgPCA0ICoga2V5TGVuICsgMjg7IGkrKykge1xuICAgICAgdG1wID0gZW5jS2V5W2ktMV07XG5cbiAgICAgIC8vIGFwcGx5IHNib3hcbiAgICAgIGlmIChpJWtleUxlbiA9PT0gMCB8fCAoa2V5TGVuID09PSA4ICYmIGkla2V5TGVuID09PSA0KSkge1xuICAgICAgICB0bXAgPSBzYm94W3RtcD4+PjI0XTw8MjQgXiBzYm94W3RtcD4+MTYmMjU1XTw8MTYgXiBzYm94W3RtcD4+OCYyNTVdPDw4IF4gc2JveFt0bXAmMjU1XTtcblxuICAgICAgICAvLyBzaGlmdCByb3dzIGFuZCBhZGQgcmNvblxuICAgICAgICBpZiAoaSVrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICB0bXAgPSB0bXA8PDggXiB0bXA+Pj4yNCBeIHJjb248PDI0O1xuICAgICAgICAgIHJjb24gPSByY29uPDwxIF4gKHJjb24+PjcpKjI4MztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbmNLZXlbaV0gPSBlbmNLZXlbaS1rZXlMZW5dIF4gdG1wO1xuICAgIH1cblxuICAgIC8vIHNjaGVkdWxlIGRlY3J5cHRpb24ga2V5c1xuICAgIGZvciAoaiA9IDA7IGk7IGorKywgaS0tKSB7XG4gICAgICB0bXAgPSBlbmNLZXlbaiYzID8gaSA6IGkgLSA0XTtcbiAgICAgIGlmIChpPD00IHx8IGo8NCkge1xuICAgICAgICBkZWNLZXlbal0gPSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNLZXlbal0gPSBkZWNUYWJsZVswXVtzYm94W3RtcD4+PjI0ICAgICAgXV0gXlxuICAgICAgICAgIGRlY1RhYmxlWzFdW3Nib3hbdG1wPj4xNiAgJiAyNTVdXSBeXG4gICAgICAgICAgZGVjVGFibGVbMl1bc2JveFt0bXA+PjggICAmIDI1NV1dIF5cbiAgICAgICAgICBkZWNUYWJsZVszXVtzYm94W3RtcCAgICAgICYgMjU1XV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgUy1ib3ggdGFibGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZWNvbXB1dGUoKSB7XG4gICAgdmFyIGVuY1RhYmxlID0gdGhpcy5fdGFibGVzWzBdLCBkZWNUYWJsZSA9IHRoaXMuX3RhYmxlc1sxXSxcbiAgICBzYm94ID0gZW5jVGFibGVbNF0sIHNib3hJbnYgPSBkZWNUYWJsZVs0XSxcbiAgICBpLCB4LCB4SW52LCBkPVtdLCB0aD1bXSwgeDIsIHg0LCB4OCwgcywgdEVuYywgdERlYztcblxuICAgIC8vIENvbXB1dGUgZG91YmxlIGFuZCB0aGlyZCB0YWJsZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHRoWyggZFtpXSA9IGk8PDEgXiAoaT4+NykqMjgzICleaV09aTtcbiAgICB9XG5cbiAgICBmb3IgKHggPSB4SW52ID0gMDsgIXNib3hbeF07IHggXj0geDIgfHwgMSwgeEludiA9IHRoW3hJbnZdIHx8IDEpIHtcbiAgICAgIC8vIENvbXB1dGUgc2JveFxuICAgICAgcyA9IHhJbnYgXiB4SW52PDwxIF4geEludjw8MiBeIHhJbnY8PDMgXiB4SW52PDw0O1xuICAgICAgcyA9IHM+PjggXiBzJjI1NSBeIDk5O1xuICAgICAgc2JveFt4XSA9IHM7XG4gICAgICBzYm94SW52W3NdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBNaXhDb2x1bW5zXG4gICAgICB4OCA9IGRbeDQgPSBkW3gyID0gZFt4XV1dO1xuICAgICAgdERlYyA9IHg4KjB4MTAxMDEwMSBeIHg0KjB4MTAwMDEgXiB4MioweDEwMSBeIHgqMHgxMDEwMTAwO1xuICAgICAgdEVuYyA9IGRbc10qMHgxMDEgXiBzKjB4MTAxMDEwMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBlbmNUYWJsZVtpXVt4XSA9IHRFbmMgPSB0RW5jPDwyNCBeIHRFbmM+Pj44O1xuICAgICAgICBkZWNUYWJsZVtpXVtzXSA9IHREZWMgPSB0RGVjPDwyNCBeIHREZWM+Pj44O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXBhY3RpZnkuIENvbnNpZGVyYWJsZSBzcGVlZHVwIG9uIEZpcmVmb3guXG4gICAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgZW5jVGFibGVbaV0gPSBlbmNUYWJsZVtpXS5zbGljZSgwKTtcbiAgICAgIGRlY1RhYmxlW2ldID0gZGVjVGFibGVbaV0uc2xpY2UoMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHQgMTYgYnl0ZXMsIHNwZWNpZmllZCBhcyBmb3VyIDMyLWJpdCB3b3Jkcy5cbiAgICogQHBhcmFtIGVuY3J5cHRlZDAge251bWJlcn0gdGhlIGZpcnN0IHdvcmQgdG8gZGVjcnlwdFxuICAgKiBAcGFyYW0gZW5jcnlwdGVkMSB7bnVtYmVyfSB0aGUgc2Vjb25kIHdvcmQgdG8gZGVjcnlwdFxuICAgKiBAcGFyYW0gZW5jcnlwdGVkMiB7bnVtYmVyfSB0aGUgdGhpcmQgd29yZCB0byBkZWNyeXB0XG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQzIHtudW1iZXJ9IHRoZSBmb3VydGggd29yZCB0byBkZWNyeXB0XG4gICAqIEBwYXJhbSBvdXQge0ludDMyQXJyYXl9IHRoZSBhcnJheSB0byB3cml0ZSB0aGUgZGVjcnlwdGVkIHdvcmRzXG4gICAqIGludG9cbiAgICogQHBhcmFtIG9mZnNldCB7bnVtYmVyfSB0aGUgb2Zmc2V0IGludG8gdGhlIG91dHB1dCBhcnJheSB0byBzdGFydFxuICAgKiB3cml0aW5nIHJlc3VsdHNcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBwbGFpbnRleHQuXG4gICAqL1xuICBkZWNyeXB0KGVuY3J5cHRlZDAsIGVuY3J5cHRlZDEsIGVuY3J5cHRlZDIsIGVuY3J5cHRlZDMsIG91dCwgb2Zmc2V0KSB7XG4gICAgdmFyIGtleSA9IHRoaXMuX2tleVsxXSxcbiAgICAvLyBzdGF0ZSB2YXJpYWJsZXMgYSxiLGMsZCBhcmUgbG9hZGVkIHdpdGggcHJlLXdoaXRlbmVkIGRhdGFcbiAgICBhID0gZW5jcnlwdGVkMCBeIGtleVswXSxcbiAgICBiID0gZW5jcnlwdGVkMyBeIGtleVsxXSxcbiAgICBjID0gZW5jcnlwdGVkMiBeIGtleVsyXSxcbiAgICBkID0gZW5jcnlwdGVkMSBeIGtleVszXSxcbiAgICBhMiwgYjIsIGMyLFxuXG4gICAgbklubmVyUm91bmRzID0ga2V5Lmxlbmd0aCAvIDQgLSAyLCAvLyBrZXkubGVuZ3RoID09PSAyID9cbiAgICBpLFxuICAgIGtJbmRleCA9IDQsXG4gICAgdGFibGUgPSB0aGlzLl90YWJsZXNbMV0sXG5cbiAgICAvLyBsb2FkIHVwIHRoZSB0YWJsZXNcbiAgICB0YWJsZTAgICAgPSB0YWJsZVswXSxcbiAgICB0YWJsZTEgICAgPSB0YWJsZVsxXSxcbiAgICB0YWJsZTIgICAgPSB0YWJsZVsyXSxcbiAgICB0YWJsZTMgICAgPSB0YWJsZVszXSxcbiAgICBzYm94ICA9IHRhYmxlWzRdO1xuXG4gICAgLy8gSW5uZXIgcm91bmRzLiBDcmliYmVkIGZyb20gT3BlblNTTC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbklubmVyUm91bmRzOyBpKyspIHtcbiAgICAgIGEyID0gdGFibGUwW2E+Pj4yNF0gXiB0YWJsZTFbYj4+MTYgJiAyNTVdIF4gdGFibGUyW2M+PjggJiAyNTVdIF4gdGFibGUzW2QgJiAyNTVdIF4ga2V5W2tJbmRleF07XG4gICAgICBiMiA9IHRhYmxlMFtiPj4+MjRdIF4gdGFibGUxW2M+PjE2ICYgMjU1XSBeIHRhYmxlMltkPj44ICYgMjU1XSBeIHRhYmxlM1thICYgMjU1XSBeIGtleVtrSW5kZXggKyAxXTtcbiAgICAgIGMyID0gdGFibGUwW2M+Pj4yNF0gXiB0YWJsZTFbZD4+MTYgJiAyNTVdIF4gdGFibGUyW2E+PjggJiAyNTVdIF4gdGFibGUzW2IgJiAyNTVdIF4ga2V5W2tJbmRleCArIDJdO1xuICAgICAgZCAgPSB0YWJsZTBbZD4+PjI0XSBeIHRhYmxlMVthPj4xNiAmIDI1NV0gXiB0YWJsZTJbYj4+OCAmIDI1NV0gXiB0YWJsZTNbYyAmIDI1NV0gXiBrZXlba0luZGV4ICsgM107XG4gICAgICBrSW5kZXggKz0gNDtcbiAgICAgIGE9YTI7IGI9YjI7IGM9YzI7XG4gICAgfVxuXG4gICAgLy8gTGFzdCByb3VuZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBvdXRbKDMgJiAtaSkgKyBvZmZzZXRdID1cbiAgICAgICAgc2JveFthPj4+MjQgICAgICBdPDwyNCBeXG4gICAgICAgIHNib3hbYj4+MTYgICYgMjU1XTw8MTYgXlxuICAgICAgICBzYm94W2M+PjggICAmIDI1NV08PDggIF5cbiAgICAgICAgc2JveFtkICAgICAgJiAyNTVdICAgICBeXG4gICAgICAgIGtleVtrSW5kZXgrK107XG4gICAgICBhMj1hOyBhPWI7IGI9YzsgYz1kOyBkPWEyO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBRVM7XG4iLCIvKlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbiBhZGFwdGF0aW9uIG9mIHRoZSBBRVMgZGVjcnlwdGlvbiBhbGdvcml0aG1cbiAqIGZyb20gdGhlIFN0YW5kZm9yZCBKYXZhc2NyaXB0IENyeXB0b2dyYXBoeSBMaWJyYXJ5LiBUaGF0IHdvcmsgaXNcbiAqIGNvdmVyZWQgYnkgdGhlIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIHBlcm1pc3Npb25zIG5vdGljZTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEwIEVtaWx5IFN0YXJrLCBNaWtlIEhhbWJ1cmcsIERhbiBCb25laC5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQVVUSE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTlxuICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uXG4gKiBhcmUgdGhvc2Ugb2YgdGhlIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nXG4gKiBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZCBvciBpbXBsaWVkLCBvZiB0aGUgYXV0aG9ycy5cbiAqL1xuXG5pbXBvcnQgQUVTIGZyb20gJy4vYWVzJztcblxuY2xhc3MgQUVTMTI4RGVjcnlwdGVyIHtcblxuICBjb25zdHJ1Y3RvcihrZXksIGluaXRWZWN0b3IpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLml2ID0gaW5pdFZlY3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IG5ldHdvcmstb3JkZXIgKGJpZy1lbmRpYW4pIGJ5dGVzIGludG8gdGhlaXIgbGl0dGxlLWVuZGlhblxuICAgKiByZXByZXNlbnRhdGlvbi5cbiAgICovXG4gIG50b2god29yZCkge1xuICAgIHJldHVybiAod29yZCA8PCAyNCkgfFxuICAgICAgKCh3b3JkICYgMHhmZjAwKSA8PCA4KSB8XG4gICAgICAoKHdvcmQgJiAweGZmMDAwMCkgPj4gOCkgfFxuICAgICAgKHdvcmQgPj4+IDI0KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIERlY3J5cHQgYnl0ZXMgdXNpbmcgQUVTLTEyOCB3aXRoIENCQyBhbmQgUEtDUyM3IHBhZGRpbmcuXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQge1VpbnQ4QXJyYXl9IHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAgICogQHBhcmFtIGtleSB7VWludDMyQXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgZGVjcnlwdGlvbiBrZXlcbiAgICogQHBhcmFtIGluaXRWZWN0b3Ige1VpbnQzMkFycmF5fSB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIChJVikgdG9cbiAgICogdXNlIGZvciB0aGUgZmlyc3Qgcm91bmQgb2YgQ0JDLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgZGVjcnlwdGVkIGJ5dGVzXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BZHZhbmNlZF9FbmNyeXB0aW9uX1N0YW5kYXJkXG4gICAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CbG9ja19jaXBoZXJfbW9kZV9vZl9vcGVyYXRpb24jQ2lwaGVyX0Jsb2NrX0NoYWluaW5nXy4yOENCQy4yOVxuICAgKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMzE1XG4gICAqL1xuICBkb0RlY3J5cHQoZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IpIHtcbiAgICB2YXJcbiAgICAgIC8vIHdvcmQtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAgICAgIGVuY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZW5jcnlwdGVkLmJ1ZmZlciwgZW5jcnlwdGVkLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZC5ieXRlTGVuZ3RoID4+IDIpLFxuXG4gICAgZGVjaXBoZXIgPSBuZXcgQUVTKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleSkpLFxuXG4gICAgLy8gYnl0ZSBhbmQgd29yZC1sZXZlbCBhY2Nlc3MgZm9yIHRoZSBkZWNyeXB0ZWQgb3V0cHV0XG4gICAgZGVjcnlwdGVkID0gbmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkLmJ5dGVMZW5ndGgpLFxuICAgIGRlY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZGVjcnlwdGVkLmJ1ZmZlciksXG5cbiAgICAvLyB0ZW1wb3JhcnkgdmFyaWFibGVzIGZvciB3b3JraW5nIHdpdGggdGhlIElWLCBlbmNyeXB0ZWQsIGFuZFxuICAgIC8vIGRlY3J5cHRlZCBkYXRhXG4gICAgaW5pdDAsIGluaXQxLCBpbml0MiwgaW5pdDMsXG4gICAgZW5jcnlwdGVkMCwgZW5jcnlwdGVkMSwgZW5jcnlwdGVkMiwgZW5jcnlwdGVkMyxcblxuICAgIC8vIGl0ZXJhdGlvbiB2YXJpYWJsZVxuICAgIHdvcmRJeDtcblxuICAgIC8vIHB1bGwgb3V0IHRoZSB3b3JkcyBvZiB0aGUgSVYgdG8gZW5zdXJlIHdlIGRvbid0IG1vZGlmeSB0aGVcbiAgICAvLyBwYXNzZWQtaW4gcmVmZXJlbmNlIGFuZCBlYXNpZXIgYWNjZXNzXG4gICAgaW5pdDAgPSB+fmluaXRWZWN0b3JbMF07XG4gICAgaW5pdDEgPSB+fmluaXRWZWN0b3JbMV07XG4gICAgaW5pdDIgPSB+fmluaXRWZWN0b3JbMl07XG4gICAgaW5pdDMgPSB+fmluaXRWZWN0b3JbM107XG5cbiAgICAvLyBkZWNyeXB0IGZvdXIgd29yZCBzZXF1ZW5jZXMsIGFwcGx5aW5nIGNpcGhlci1ibG9jayBjaGFpbmluZyAoQ0JDKVxuICAgIC8vIHRvIGVhY2ggZGVjcnlwdGVkIGJsb2NrXG4gICAgZm9yICh3b3JkSXggPSAwOyB3b3JkSXggPCBlbmNyeXB0ZWQzMi5sZW5ndGg7IHdvcmRJeCArPSA0KSB7XG4gICAgICAvLyBjb252ZXJ0IGJpZy1lbmRpYW4gKG5ldHdvcmsgb3JkZXIpIHdvcmRzIGludG8gbGl0dGxlLWVuZGlhblxuICAgICAgLy8gKGphdmFzY3JpcHQgb3JkZXIpXG4gICAgICBlbmNyeXB0ZWQwID0gfn50aGlzLm50b2goZW5jcnlwdGVkMzJbd29yZEl4XSk7XG4gICAgICBlbmNyeXB0ZWQxID0gfn50aGlzLm50b2goZW5jcnlwdGVkMzJbd29yZEl4ICsgMV0pO1xuICAgICAgZW5jcnlwdGVkMiA9IH5+dGhpcy5udG9oKGVuY3J5cHRlZDMyW3dvcmRJeCArIDJdKTtcbiAgICAgIGVuY3J5cHRlZDMgPSB+fnRoaXMubnRvaChlbmNyeXB0ZWQzMlt3b3JkSXggKyAzXSk7XG5cbiAgICAgIC8vIGRlY3J5cHQgdGhlIGJsb2NrXG4gICAgICBkZWNpcGhlci5kZWNyeXB0KGVuY3J5cHRlZDAsXG4gICAgICAgICAgZW5jcnlwdGVkMSxcbiAgICAgICAgICBlbmNyeXB0ZWQyLFxuICAgICAgICAgIGVuY3J5cHRlZDMsXG4gICAgICAgICAgZGVjcnlwdGVkMzIsXG4gICAgICAgICAgd29yZEl4KTtcblxuICAgICAgLy8gWE9SIHdpdGggdGhlIElWLCBhbmQgcmVzdG9yZSBuZXR3b3JrIGJ5dGUtb3JkZXIgdG8gb2J0YWluIHRoZVxuICAgICAgLy8gcGxhaW50ZXh0XG4gICAgICBkZWNyeXB0ZWQzMlt3b3JkSXhdICAgICA9IHRoaXMubnRvaChkZWNyeXB0ZWQzMlt3b3JkSXhdIF4gaW5pdDApO1xuICAgICAgZGVjcnlwdGVkMzJbd29yZEl4ICsgMV0gPSB0aGlzLm50b2goZGVjcnlwdGVkMzJbd29yZEl4ICsgMV0gXiBpbml0MSk7XG4gICAgICBkZWNyeXB0ZWQzMlt3b3JkSXggKyAyXSA9IHRoaXMubnRvaChkZWNyeXB0ZWQzMlt3b3JkSXggKyAyXSBeIGluaXQyKTtcbiAgICAgIGRlY3J5cHRlZDMyW3dvcmRJeCArIDNdID0gdGhpcy5udG9oKGRlY3J5cHRlZDMyW3dvcmRJeCArIDNdIF4gaW5pdDMpO1xuXG4gICAgICAvLyBzZXR1cCB0aGUgSVYgZm9yIHRoZSBuZXh0IHJvdW5kXG4gICAgICBpbml0MCA9IGVuY3J5cHRlZDA7XG4gICAgICBpbml0MSA9IGVuY3J5cHRlZDE7XG4gICAgICBpbml0MiA9IGVuY3J5cHRlZDI7XG4gICAgICBpbml0MyA9IGVuY3J5cHRlZDM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY3J5cHRlZDtcbiAgfVxuXG4gIGxvY2FsRGVjcnlwdChlbmNyeXB0ZWQsIGtleSwgaW5pdFZlY3RvciwgZGVjcnlwdGVkKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5kb0RlY3J5cHQoZW5jcnlwdGVkLFxuICAgICAgICBrZXksXG4gICAgICAgIGluaXRWZWN0b3IpO1xuICAgIGRlY3J5cHRlZC5zZXQoYnl0ZXMsIGVuY3J5cHRlZC5ieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIGRlY3J5cHQoZW5jcnlwdGVkKSB7XG4gICAgdmFyXG4gICAgICBzdGVwID0gNCAqIDgwMDAsXG4gICAgLy9lbmNyeXB0ZWQzMiA9IG5ldyBJbnQzMkFycmF5KGVuY3J5cHRlZC5idWZmZXIpLFxuICAgIGVuY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZW5jcnlwdGVkKSxcbiAgICBkZWNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQuYnl0ZUxlbmd0aCksXG4gICAgaSA9IDA7XG5cbiAgICAvLyBzcGxpdCB1cCB0aGUgZW5jcnlwdGlvbiBqb2IgYW5kIGRvIHRoZSBpbmRpdmlkdWFsIGNodW5rcyBhc3luY2hyb25vdXNseVxuICAgIHZhciBrZXkgPSB0aGlzLmtleTtcbiAgICB2YXIgaW5pdFZlY3RvciA9IHRoaXMuaXY7XG4gICAgdGhpcy5sb2NhbERlY3J5cHQoZW5jcnlwdGVkMzIuc3ViYXJyYXkoaSwgaSArIHN0ZXApLCBrZXksIGluaXRWZWN0b3IsIGRlY3J5cHRlZCk7XG5cbiAgICBmb3IgKGkgPSBzdGVwOyBpIDwgZW5jcnlwdGVkMzIubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGluaXRWZWN0b3IgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgICAgICAgIHRoaXMubnRvaChlbmNyeXB0ZWQzMltpIC0gNF0pLFxuICAgICAgICAgIHRoaXMubnRvaChlbmNyeXB0ZWQzMltpIC0gM10pLFxuICAgICAgICAgIHRoaXMubnRvaChlbmNyeXB0ZWQzMltpIC0gMl0pLFxuICAgICAgICAgIHRoaXMubnRvaChlbmNyeXB0ZWQzMltpIC0gMV0pXG4gICAgICBdKTtcbiAgICAgIHRoaXMubG9jYWxEZWNyeXB0KGVuY3J5cHRlZDMyLnN1YmFycmF5KGksIGkgKyBzdGVwKSwga2V5LCBpbml0VmVjdG9yLCBkZWNyeXB0ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUVTMTI4RGVjcnlwdGVyO1xuIiwiLypcbiAqIEFFUzEyOCBkZWNyeXB0aW9uLlxuICovXG5cbmltcG9ydCBBRVMxMjhEZWNyeXB0ZXIgZnJvbSAnLi9hZXMxMjgtZGVjcnlwdGVyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIERlY3J5cHRlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJyb3dzZXJDcnlwdG8gPSB3aW5kb3cgPyB3aW5kb3cuY3J5cHRvIDogY3J5cHRvO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9ICF0aGlzLnN1YnRsZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxuICBkZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmhscy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIHRoaXMuZGVjcnlwdEJ5U29mdHdhcmUoZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY3J5cHRCeVdlYkNyeXB0byhkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgZGVjcnlwdEJ5V2ViQ3J5cHRvKGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVjcnlwdGluZyBieSBXZWJDcnlwdG8gQVBJJyk7XG5cbiAgICB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lIDogJ0FFUy1DQkMnLCBsZW5ndGggOiAxMjggfSwgZmFsc2UsIFsnZGVjcnlwdCddKS5cbiAgICAgIHRoZW4oKGltcG9ydGVkS2V5KSA9PiB7XG4gICAgICAgIHRoaXMuc3VidGxlLmRlY3J5cHQoeyBuYW1lIDogJ0FFUy1DQkMnLCBpdiA6IGl2LmJ1ZmZlciB9LCBpbXBvcnRlZEtleSwgZGF0YSkuXG4gICAgICAgICAgdGhlbihjYWxsYmFjaykuXG4gICAgICAgICAgY2F0Y2ggKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pLlxuICAgIGNhdGNoICgoZXJyKSA9PiB7XG4gICAgICB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICBkZWNyeXB0QnlTb2Z0d2FyZShkYXRhLCBrZXk4LCBpdjgsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVjcnlwdGluZyBieSBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uJyk7XG5cbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhrZXk4LmJ1ZmZlcik7XG4gICAgdmFyIGtleSA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgIHZpZXcuZ2V0VWludDMyKDApLFxuICAgICAgICB2aWV3LmdldFVpbnQzMig0KSxcbiAgICAgICAgdmlldy5nZXRVaW50MzIoOCksXG4gICAgICAgIHZpZXcuZ2V0VWludDMyKDEyKVxuICAgIF0pO1xuXG4gICAgdmlldyA9IG5ldyBEYXRhVmlldyhpdjguYnVmZmVyKTtcbiAgICB2YXIgaXYgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgICAgICB2aWV3LmdldFVpbnQzMigwKSxcbiAgICAgICAgdmlldy5nZXRVaW50MzIoNCksXG4gICAgICAgIHZpZXcuZ2V0VWludDMyKDgpLFxuICAgICAgICB2aWV3LmdldFVpbnQzMigxMilcbiAgICBdKTtcblxuICAgIHZhciBkZWNyeXB0ZXIgPSBuZXcgQUVTMTI4RGVjcnlwdGVyKGtleSwgaXYpO1xuICAgIGNhbGxiYWNrKGRlY3J5cHRlci5kZWNyeXB0KGRhdGEpLmJ1ZmZlcik7XG4gIH1cblxuICBvbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICBsb2dnZXIubG9nKCdkaXNhYmxpbmcgdG8gdXNlIFdlYkNyeXB0byBBUEknKTtcbiAgICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9IHRydWU7XG4gICAgICB0aGlzLmRlY3J5cHRCeVNvZnR3YXJlKGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYGRlY3J5cHRpbmcgZXJyb3IgOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzIDogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUiwgZmF0YWwgOiB0cnVlLCByZWFzb24gOiBlcnIubWVzc2FnZX0pO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IERlY3J5cHRlcjtcbiIsIi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuaW1wb3J0IEFEVFMgZnJvbSAnLi9hZHRzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xuXG4gY2xhc3MgQUFDRGVtdXhlciB7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGlkLCByZW11eGVyQ2xhc3MsIGNvbmZpZykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5yZW11eGVyQ2xhc3MgPSByZW11eGVyQ2xhc3M7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5yZW11eGVyID0gbmV3IHRoaXMucmVtdXhlckNsYXNzKG9ic2VydmVyLGlkLCBjb25maWcpO1xuICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICB9XG5cbiAgaW5zZXJ0RGlzY29udGludWl0eSgpIHtcbiAgICB0aGlzLl9hYWNUcmFjayA9IHtjb250YWluZXIgOiAnYXVkaW8vYWR0cycsIHR5cGU6ICdhdWRpbycsIGlkIDotMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMH07XG4gIH1cblxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgQURUUyBzeW5jIHdvcmNcbiAgICB2YXIgaWQzID0gbmV3IElEMyhkYXRhKSwgb2Zmc2V0LGxlbjtcbiAgICBpZihpZDMuaGFzVGltZVN0YW1wKSB7XG4gICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgZm9yIChvZmZzZXQgPSBpZDMubGVuZ3RoLCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmIChkYXRhW29mZnNldCsxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgdHJhY2ssXG4gICAgICAgIGlkMyA9IG5ldyBJRDMoZGF0YSksXG4gICAgICAgIHB0cyA9IDkwKmlkMy50aW1lU3RhbXAsXG4gICAgICAgIGNvbmZpZywgZnJhbWVMZW5ndGgsIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgaGVhZGVyTGVuZ3RoLCBzdGFtcCwgbGVuLCBhYWNTYW1wbGU7XG5cbiAgICBsZXQgY29udGlndW91cyA9IGZhbHNlO1xuICAgIGlmIChjYyAhPT0gdGhpcy5sYXN0Q0MpIHtcbiAgICAgIGxvZ2dlci5sb2coYCR7dGhpcy5pZH0gZGlzY29udGludWl0eSBkZXRlY3RlZGApO1xuICAgICAgdGhpcy5sYXN0Q0MgPSBjYztcbiAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgICAgdGhpcy5yZW11eGVyLnN3aXRjaExldmVsKCk7XG4gICAgICB0aGlzLnJlbXV4ZXIuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWwgIT09IHRoaXMubGFzdExldmVsKSB7XG4gICAgICBsb2dnZXIubG9nKCdhdWRpbyB0cmFjayBzd2l0Y2ggZGV0ZWN0ZWQnKTtcbiAgICAgIHRoaXMubGFzdExldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLnJlbXV4ZXIuc3dpdGNoTGV2ZWwoKTtcbiAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgIH0gZWxzZSBpZiAoc24gPT09ICh0aGlzLmxhc3RTTisxKSkge1xuICAgICAgY29udGlndW91cyA9IHRydWU7XG4gICAgfVxuICAgIHRyYWNrID0gdGhpcy5fYWFjVHJhY2s7XG4gICAgdGhpcy5sYXN0U04gPSBzbjtcbiAgICB0aGlzLmxhc3RMZXZlbCA9IGxldmVsO1xuXG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGgsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmIChkYXRhW29mZnNldCsxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5hdWRpb3NhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgIHRyYWNrLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30scmF0ZToke2NvbmZpZy5zYW1wbGVyYXRlfSxuYiBjaGFubmVsOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgICB9XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IDEwMjQgKiA5MDAwMCAvIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZTtcbiAgICB3aGlsZSAoKG9mZnNldCArIDUpIDwgbGVuKSB7XG4gICAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICAgIGhlYWRlckxlbmd0aCA9ICghIShkYXRhW29mZnNldCArIDFdICYgMHgwMSkgPyA3IDogOSk7XG4gICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgICBmcmFtZUxlbmd0aCA9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExKSB8XG4gICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgICAgICAgICAgICAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcbiAgICAgIGZyYW1lTGVuZ3RoICAtPSBoZWFkZXJMZW5ndGg7XG4gICAgICAvL3N0YW1wID0gcGVzLnB0cztcblxuICAgICAgaWYgKChmcmFtZUxlbmd0aCA+IDApICYmICgob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpIDw9IGxlbikpIHtcbiAgICAgICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgLy9sb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgICAgICBhYWNTYW1wbGUgPSB7dW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcH07XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XG4gICAgICAgIG9mZnNldCArPSBmcmFtZUxlbmd0aCArIGhlYWRlckxlbmd0aDtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgICBmb3IgKCA7IG9mZnNldCA8IChsZW4gLSAxKTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgobGV2ZWwsIHNuICwgdGhpcy5fYWFjVHJhY2sse3NhbXBsZXMgOiBbXX0sIHtzYW1wbGVzIDogWyB7IHB0czogcHRzLCBkdHMgOiBwdHMsIHVuaXQgOiBpZDMucGF5bG9hZH0gXX0sIHsgc2FtcGxlczogW10gfSwgdGltZU9mZnNldCwgY29udGlndW91cyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDRGVtdXhlcjtcbiIsIi8qKlxuICogIEFEVFMgcGFyc2VyIGhlbHBlclxuICovXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4gY2xhc3MgQURUUyB7XG5cbiAgc3RhdGljIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICB2YXIgYWR0c09iamVjdFR5cGUsIC8vIDppbnRcbiAgICAgICAgYWR0c1NhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgICAgICBhZHRzQ2hhbmVsQ29uZmlnLCAvLyA6aW50XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbXG4gICAgICAgICAgICA5NjAwMCwgODgyMDAsXG4gICAgICAgICAgICA2NDAwMCwgNDgwMDAsXG4gICAgICAgICAgICA0NDEwMCwgMzIwMDAsXG4gICAgICAgICAgICAyNDAwMCwgMjIwNTAsXG4gICAgICAgICAgICAxNjAwMCwgMTIwMDAsXG4gICAgICAgICAgICAxMTAyNSwgODAwMCxcbiAgICAgICAgICAgIDczNTBdO1xuICAgIC8vIGJ5dGUgMlxuICAgIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhDMCkgPj4+IDYpICsgMTtcbiAgICBhZHRzU2FtcGxlaW5nSW5kZXggPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNDKSA+Pj4gMik7XG4gICAgaWYoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aC0xKSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogYGludmFsaWQgQURUUyBzYW1wbGluZyBpbmRleDoke2FkdHNTYW1wbGVpbmdJbmRleH1gfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcbiAgICAvLyBieXRlIDNcbiAgICBhZHRzQ2hhbmVsQ29uZmlnIHw9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4QzApID4+PiA2KTtcbiAgICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LEFEVFMgZGF0YTp0eXBlOiR7YWR0c09iamVjdFR5cGV9LHNhbXBsZWluZ0luZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fVske2FkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdfUh6XSxjaGFubmVsQ29uZmlnOiR7YWR0c0NoYW5lbENvbmZpZ31gKTtcbiAgICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEpIHtcbiAgICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikge1xuICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgICAgfVxuICAgICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG4gICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChjaHJvbWUgLi4uKVxuICAgICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgICAqL1xuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgICBpZiAoKGF1ZGlvQ29kZWMgJiYgKChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkpKSB8fFxuICAgICAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikpIHtcbiAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNiAmJiBhZHRzQ2hhbmVsQ29uZmlnID09PSAxKSB8fFxuICAgICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgfVxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgICAwOiBOdWxsXG4gICAgICAxOiBBQUMgTWFpblxuICAgICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgICA2OiBBQUMgU2NhbGFibGVcbiAgICAgc2FtcGxpbmcgZnJlcVxuICAgICAgMDogOTYwMDAgSHpcbiAgICAgIDE6IDg4MjAwIEh6XG4gICAgICAyOiA2NDAwMCBIelxuICAgICAgMzogNDgwMDAgSHpcbiAgICAgIDQ6IDQ0MTAwIEh6XG4gICAgICA1OiAzMjAwMCBIelxuICAgICAgNjogMjQwMDAgSHpcbiAgICAgIDc6IDIyMDUwIEh6XG4gICAgICA4OiAxNjAwMCBIelxuICAgICAgOTogMTIwMDAgSHpcbiAgICAgIDEwOiAxMTAyNSBIelxuICAgICAgMTE6IDgwMDAgSHpcbiAgICAgIDEyOiA3MzUwIEh6XG4gICAgICAxMzogUmVzZXJ2ZWRcbiAgICAgIDE0OiBSZXNlcnZlZFxuICAgICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAgICovXG4gICAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAgIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gICAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcbiAgICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcbiAgICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gICAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XG4gICAgICBjb25maWdbM10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge2NvbmZpZzogY29uZmlnLCBzYW1wbGVyYXRlOiBhZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XSwgY2hhbm5lbENvdW50OiBhZHRzQ2hhbmVsQ29uZmlnLCBjb2RlYzogKCdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSl9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFEVFM7XG4iLCIvKiAgaW5saW5lIGRlbXV4ZXIuXG4gKiAgIHByb2JlIGZyYWdtZW50cyBhbmQgaW5zdGFudGlhdGUgYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEFBQ0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvYWFjZGVtdXhlcic7XG5pbXBvcnQgVFNEZW11eGVyIGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XG5pbXBvcnQgRkxWRGVtdXhlciBmcm9tICcuLi9kZW11eC9mbHZkZW11eGVyJztcbmltcG9ydCBNUDRSZW11eGVyIGZyb20gJy4uL3JlbXV4L21wNC1yZW11eGVyJztcbmltcG9ydCBQYXNzVGhyb3VnaFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlcic7XG5cbmNsYXNzIERlbXV4ZXJJbmxpbmUge1xuXG4gIGNvbnN0cnVjdG9yKGhscyxpZCwgdHlwZVN1cHBvcnRlZCwgY29uZmlnPW51bGwpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jb25maWcgPSB0aGlzLmhscy5jb25maWcgfHwgY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgIGlmIChkZW11eGVyKSB7XG4gICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBwdXNoKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uKSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICBsZXQgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgaWQgPSB0aGlzLmlkO1xuICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgaWYgKEZMVkRlbXV4ZXIucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgZGVtdXhlciA9IG5ldyBGTFZEZW11eGVyKGhscywgaWQsIE1QNFJlbXV4ZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgIH0gZWxzZSBpZiAoVFNEZW11eGVyLnByb2JlKGRhdGEpKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGVTdXBwb3J0ZWQubXAydCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgVFNEZW11eGVyKGhscywgaWQsIFBhc3NUaHJvdWdoUmVtdXhlciwgdGhpcy5jb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgVFNEZW11eGVyKGhscywgaWQsIE1QNFJlbXV4ZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKEFBQ0RlbXV4ZXIucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgZGVtdXhlciA9IG5ldyBBQUNEZW11eGVyKGhscywgaWQsIE1QNFJlbXV4ZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGlkIDogaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246ICdubyBkZW11eCBtYXRjaGluZyB3aXRoIGNvbnRlbnQgZm91bmQnfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVtdXhlciA9IGRlbXV4ZXI7XG4gICAgfVxuICAgIGRlbXV4ZXIucHVzaChkYXRhLGF1ZGlvQ29kZWMsdmlkZW9Db2RlYyx0aW1lT2Zmc2V0LGNjLGxldmVsLHNuLGR1cmF0aW9uKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVySW5saW5lO1xuIiwiLyogZGVtdXhlciB3ZWIgd29ya2VyLlxuICogIC0gbGlzdGVuIHRvIHdvcmtlciBtZXNzYWdlLCBhbmQgdHJpZ2dlciBEZW11eGVySW5saW5lIHVwb24gcmVjZXB0aW9uIG9mIEZyYWdtZW50cy5cbiAqICAtIHByb3ZpZGVzIE1QNCBCb3hlcyBiYWNrIHRvIG1haW4gdGhyZWFkIHVzaW5nIFt0cmFuc2ZlcmFibGUgb2JqZWN0c10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxMS8xMi9UcmFuc2ZlcmFibGUtT2JqZWN0cy1MaWdodG5pbmctRmFzdCkgaW4gb3JkZXIgdG8gbWluaW1pemUgbWVzc2FnZSBwYXNzaW5nIG92ZXJoZWFkLlxuICovXG5cbiBpbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XG4gaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG4gaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuXG52YXIgRGVtdXhlcldvcmtlciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIC8vIG9ic2VydmVyIHNldHVwXG4gIHZhciBvYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICB9O1xuXG4gIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XG4gIH07XG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcbiAgICAvL2NvbnNvbGUubG9nKCdkZW11eGVyIGNtZDonICsgZGF0YS5jbWQpO1xuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICBzZWxmLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgZGF0YS5pZCwgZGF0YS50eXBlU3VwcG9ydGVkLCBKU09OLnBhcnNlKGRhdGEuY29uZmlnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGVtdXgnOlxuICAgICAgICBzZWxmLmRlbXV4ZXIucHVzaChuZXcgVWludDhBcnJheShkYXRhLmRhdGEpLCBkYXRhLmF1ZGlvQ29kZWMsIGRhdGEudmlkZW9Db2RlYywgZGF0YS50aW1lT2Zmc2V0LCBkYXRhLmNjLCBkYXRhLmxldmVsLCBkYXRhLnNuLCBkYXRhLmR1cmF0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uKGV2LGRhdGEpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtldmVudDogZXYsIGRhdGE6ZGF0YSB9KTtcbiAgfTtcblxuICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcblxuICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBwYXNzIGRhdGExL2RhdGEyIGFzIHRyYW5zZmVyYWJsZSBvYmplY3QgKG5vIGNvcHkpXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmdW5jdGlvbihldiwgZGF0YSkge1xuICAgIGxldCBkYXRhMSA9IGRhdGEuZGF0YTEuYnVmZmVyLCBkYXRhMiA9IGRhdGEuZGF0YTIuYnVmZmVyO1xuICAgIC8vIHJlbW92ZSBkYXRhMSBhbmQgZGF0YTIgcmVmZXJlbmNlIGZyb20gZGF0YSB0byBhdm9pZCBjb3B5aW5nIHRoZW0gLi4uXG4gICAgZGVsZXRlIGRhdGEuZGF0YTE7XG4gICAgZGVsZXRlIGRhdGEuZGF0YTI7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7ZXZlbnQ6IGV2LCBkYXRhOmRhdGEgLCBkYXRhMSA6IGRhdGExLCBkYXRhMiA6IGRhdGEyfSxbZGF0YTEsIGRhdGEyXSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcldvcmtlcjtcblxuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XG5pbXBvcnQgRGVtdXhlcldvcmtlciBmcm9tICcuLi9kZW11eC9kZW11eGVyLXdvcmtlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5jbGFzcyBEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMsIGlkKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHZhciB0eXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0IDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQnKSxcbiAgICAgIG1wMnQgOiBobHMuY29uZmlnLmVuYWJsZU1QMlRQYXNzVGhyb3VnaCAmJiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wMnQnKVxuICAgIH07XG4gICAgaWYgKGhscy5jb25maWcuZW5hYmxlV29ya2VyICYmICh0eXBlb2YoV29ya2VyKSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2RlbXV4aW5nIGluIHdlYndvcmtlcicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB3b3JrID0gcmVxdWlyZSgnd2Vid29ya2lmeScpO1xuICAgICAgICAgIGxldCB3ID0gdGhpcy53ID0gd29yayhEZW11eGVyV29ya2VyKTtcbiAgICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICAgIHcub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7IGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IHRydWUsIGV2ZW50IDogJ2RlbXV4ZXJXb3JrZXInLCBlcnIgOiB7IG1lc3NhZ2UgOiBldmVudC5tZXNzYWdlICsgJyAoJyArIGV2ZW50LmZpbGVuYW1lICsgJzonICsgZXZlbnQubGluZW5vICsgJyknIH19KTt9O1xuICAgICAgICAgIHcucG9zdE1lc3NhZ2Uoe2NtZDogJ2luaXQnLCB0eXBlU3VwcG9ydGVkIDogdHlwZVN1cHBvcnRlZCwgaWQgOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShobHMuY29uZmlnKX0pO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShobHMsaWQsdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKGhscyxpZCx0eXBlU3VwcG9ydGVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVtdXhJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGxldCB3ID0gdGhpcy53O1xuICAgIGlmICh3KSB7XG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xuICAgIGlmIChkZWNyeXB0ZXIpIHtcbiAgICAgIGRlY3J5cHRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlY3J5cHRlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVzaERlY3J5cHRlZChkYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbikge1xuICAgIGxldCB3ID0gdGhpcy53O1xuICAgIGlmICh3KSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgKG5vIGNvcHkpXG4gICAgICB3LnBvc3RNZXNzYWdlKHtjbWQ6ICdkZW11eCcsIGRhdGE6IGRhdGEsIGF1ZGlvQ29kZWM6IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWM6IHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQ6IHRpbWVPZmZzZXQsIGNjOiBjYywgbGV2ZWw6IGxldmVsLCBzbiA6IHNuLCBkdXJhdGlvbjogZHVyYXRpb259LCBbZGF0YV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIucHVzaChuZXcgVWludDhBcnJheShkYXRhKSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24sIGRlY3J5cHRkYXRhKSB7XG4gICAgaWYgKChkYXRhLmJ5dGVMZW5ndGggPiAwKSAmJiAoZGVjcnlwdGRhdGEgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLmtleSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpKSB7XG4gICAgICBpZiAodGhpcy5kZWNyeXB0ZXIgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5obHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZGF0YSwgZGVjcnlwdGRhdGEua2V5LCBkZWNyeXB0ZGF0YS5pdiwgZnVuY3Rpb24oZGVjcnlwdGVkRGF0YSl7XG4gICAgICAgIGxvY2FsdGhpcy5wdXNoRGVjcnlwdGVkKGRlY3J5cHRlZERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQoZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uV29ya2VyTWVzc2FnZShldikge1xuICAgIGxldCBkYXRhID0gZXYuZGF0YSxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgLy9jb25zb2xlLmxvZygnb25Xb3JrZXJNZXNzYWdlOicgKyBkYXRhLmV2ZW50KTtcbiAgICBzd2l0Y2goZGF0YS5ldmVudCkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogZGF0YTEgYW5kIGRhdGEyIGFyZSB0cmFuc2ZlcmFibGUgb2JqZWN0c1xuICAgICAgY2FzZSBFdmVudC5GUkFHX1BBUlNJTkdfREFUQTpcbiAgICAgICAgZGF0YS5kYXRhLmRhdGExID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMSk7XG4gICAgICAgIGRhdGEuZGF0YS5kYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTIpO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcjtcblxuIiwiLyoqXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBFeHBHb2xvbWIge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBsb2FkV29yZCgpIHtcbiAgICB2YXJcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5kYXRhLmJ5dGVMZW5ndGggLSB0aGlzLmJ5dGVzQXZhaWxhYmxlLFxuICAgICAgd29ya2luZ0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCksXG4gICAgICBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIHRoaXMuYnl0ZXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgd29ya2luZ0J5dGVzLnNldCh0aGlzLmRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGNvdW50KSB7XG4gICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgIGNvdW50IC09IChza2lwQnl0ZXMgPj4gMyk7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gKHNpemU6aW50KTp1aW50XG4gIHJlYWRCaXRzKHNpemUpIHtcbiAgICB2YXJcbiAgICAgIGJpdHMgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIHNpemUpLCAvLyA6dWludFxuICAgICAgdmFsdSA9IHRoaXMud29yZCA+Pj4gKDMyIC0gYml0cyk7IC8vIDp1aW50XG4gICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfVxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcbiAgICBpZiAoYml0cyA+IDApIHtcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWigpIHtcbiAgICB2YXIgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgIGlmICgwICE9PSAodGhpcy53b3JkICYgKDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpKSkge1xuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXG4gICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcFVFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcEVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dWludFxuICByZWFkVUVHKCkge1xuICAgIHZhciBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcoKSB7XG4gICAgdmFyIHZhbHUgPSB0aGlzLnJlYWRVRUcoKTsgLy8gOmludFxuICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICByZXR1cm4gKDEgKyB2YWx1KSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIHJlYWRCb29sZWFuKCkge1xuICAgIHJldHVybiAxID09PSB0aGlzLnJlYWRCaXRzKDEpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVQnl0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuICAgIC8vICgpOmludFxuICByZWFkVUludCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgRXhwR29sb21iIGRlY29kZXIgcGFzdCBhIHNjYWxpbmcgbGlzdC4gVGhlIHNjYWxpbmdcbiAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcbiAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAqIEBwYXJhbSBjb3VudCB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgKi9cbiAgc2tpcFNjYWxpbmdMaXN0KGNvdW50KSB7XG4gICAgdmFyXG4gICAgICBsYXN0U2NhbGUgPSA4LFxuICAgICAgbmV4dFNjYWxlID0gOCxcbiAgICAgIGosXG4gICAgICBkZWx0YVNjYWxlO1xuICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSAobmV4dFNjYWxlID09PSAwKSA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIHJlYWRTUFMoKSB7XG4gICAgdmFyXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwLFxuICAgICAgc2FyU2NhbGUgPSAxLFxuICAgICAgcHJvZmlsZUlkYyxwcm9maWxlQ29tcGF0LGxldmVsSWRjLFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLFxuICAgICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSxcbiAgICAgIGZyYW1lTWJzT25seUZsYWcsXG4gICAgICBzY2FsaW5nTGlzdENvdW50LFxuICAgICAgaTtcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIHByb2ZpbGVJZGMgPSB0aGlzLnJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHByb2ZpbGVDb21wYXQgPSB0aGlzLnJlYWRCaXRzKDUpOyAvLyBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICB0aGlzLnNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG4gICAgbGV2ZWxJZGMgPSB0aGlzLnJlYWRVQnl0ZSgpOyAvL2xldmVsX2lkYyB1KDgpXG4gICAgdGhpcy5za2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTIyIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA0NCAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODMgIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDg2ICB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTggfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICB2YXIgY2hyb21hRm9ybWF0SWRjID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgIHRoaXMuc2tpcEJpdHMoMSk7IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgICB9XG4gICAgICB0aGlzLnNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICB0aGlzLnNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgaWYgKHRoaXMucmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2tpcFNjYWxpbmdMaXN0KDY0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5za2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZWFkVUVHKCk7IC8vbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICB0aGlzLnNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICB0aGlzLnNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHRoaXMucmVhZFVFRygpO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgdGhpcy5za2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9yZWZfZnJhbWVbIGkgXVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgdGhpcy5za2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgcGljV2lkdGhJbk1ic01pbnVzMSA9IHRoaXMucmVhZFVFRygpO1xuICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICBmcmFtZU1ic09ubHlGbGFnID0gdGhpcy5yZWFkQml0cygxKTtcbiAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgdGhpcy5za2lwQml0cygxKTsgLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuICAgIH1cbiAgICB0aGlzLnNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXG4gICAgaWYgKHRoaXMucmVhZEJvb2xlYW4oKSkgeyAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHRoaXMucmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAodGhpcy5yZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBsZXQgc2FyUmF0aW87XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvSWRjID0gdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTogc2FyUmF0aW8gPSBbMSwxXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiBzYXJSYXRpbyA9IFsxMiwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogc2FyUmF0aW8gPSBbMTAsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6IHNhclJhdGlvID0gWzE2LDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OiBzYXJSYXRpbyA9IFs0MCwzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjogc2FyUmF0aW8gPSBbMjQsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDc6IHNhclJhdGlvID0gWzIwLDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OiBzYXJSYXRpbyA9IFszMiwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTogc2FyUmF0aW8gPSBbODAsMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOiBzYXJSYXRpbyA9IFsxOCwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6IHNhclJhdGlvID0gWzE1LDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjogc2FyUmF0aW8gPSBbNjQsMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOiBzYXJSYXRpbyA9IFsxNjAsOTldOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE0OiBzYXJSYXRpbyA9IFs0LDNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE1OiBzYXJSYXRpbyA9IFszLDJdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OiBzYXJSYXRpbyA9IFsyLDFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI1NToge1xuICAgICAgICAgICAgc2FyUmF0aW8gPSBbdGhpcy5yZWFkVUJ5dGUoKSA8PCA4IHwgdGhpcy5yZWFkVUJ5dGUoKSwgdGhpcy5yZWFkVUJ5dGUoKSA8PCA4IHwgdGhpcy5yZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhclJhdGlvKSB7XG4gICAgICAgICAgc2FyU2NhbGUgPSBzYXJSYXRpb1swXSAvIHNhclJhdGlvWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSAqIHNhclNjYWxlKSxcbiAgICAgIGhlaWdodDogKCgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYpIC0gKChmcmFtZU1ic09ubHlGbGFnPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSlcbiAgICB9O1xuICB9XG5cbiAgcmVhZFNsaWNlVHlwZSgpIHtcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgIHRoaXMucmVhZFVCeXRlKCk7XG4gICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgIHRoaXMucmVhZFVFRygpO1xuICAgIC8vIHJldHVybiBzbGljZV90eXBlXG4gICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4cEdvbG9tYjtcbiIsIi8qKlxuICogQGZpbGU6ICAgZmx2LXBhcnNlci5qc1xuICogQGF1dGhvcjogdGFuc2hhb2h1aVxuICogQGVtYWlsOiAgdGFuc2hhb2h1aUBiYWlkdS5jb21cbiAqIEBkYXRlOiAgIDIwMTYtMDktMDcgMTU6MDY6NDFcbiAqIEBsYXN0IG1vZGlmaWVkIGJ5OiAgIHRhbnNoYW9odWlcbiAqIEBsYXN0IG1vZGlmaWVkIHRpbWU6IDIwMTYtMDktMDcgMTY6MDM6NDVcbiAqL1xuXG5jbGFzcyBGTFZQYXJzZXIge1xuXG4gICAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICAgICAgdGhpcy5oYXNBdWRpb1RhZ3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc1ZpZGVvVGFncyA9IHRydWU7XG4gICAgICAgIHRoaXMuYm9keU9mZnNldCA9IDA7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRGaWxlSGVhZGVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVhZEZpbGVIZWFkZXIgKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgRkxWUGFyc2VyLk1JTl9GSUxFX0hFQURFUl9CWVRFX0NPVU5UKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgdG9vIHNob3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICBpZiAoZGF0YVswXSAhPT0gMHg0Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGTFZIZWFkZXIgU2lnbmF0dXJlWzBdIG5vdCBcIkZcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IDB4NEMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRkxWSGVhZGVyIFNpZ25hdHVyZVsxXSBub3QgXCJMXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhWzJdICE9PSAweDU2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZMVkhlYWRlciBTaWduYXR1cmVbMl0gbm90IFwiVlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRhWzNdICE9PSAweDAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZMVkhlYWRlciBWZXJzaW9uIG5vdCAweDAxJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmxhZ3MgPSBkYXRhWzRdO1xuICAgICAgICB0aGlzLmhhc0F1ZGlvVGFncyA9IChmbGFncyAmIDB4MDQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1ZpZGVvVGFncyA9IChmbGFncyAmIDB4MDEpID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYm9keU9mZnNldCA9IG5ldyBEYXRhVmlldyhkYXRhLnNsaWNlKDUpLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgICAgICBpZiAodGhpcy5ib2R5T2Zmc2V0IDwgRkxWUGFyc2VyLk1JTl9GSUxFX0hFQURFUl9CWVRFX0NPVU5UKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZMVkhlYWRlciBib2R5T2Zmc2V0IHNtYWxsZXIgdGhhbiBtaW5pbXVtJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkZMVlBhcnNlci5NSU5fRklMRV9IRUFERVJfQllURV9DT1VOVCA9IDk7XG5GTFZQYXJzZXIuRklMRV9IRUFERVIgPSAnZmlsZUhlYWRlcic7XG5GTFZQYXJzZXIuUFJFVl9UQUcgPSAncHJldlRhZyc7XG5GTFZQYXJzZXIuSEVBREVSID0gJ2hlYWRlcic7XG5GTFZQYXJzZXIuREFUQSA9ICdkYXRhJztcblxuZXhwb3J0IGRlZmF1bHQgRkxWUGFyc2VyOyIsIi8qKlxuICogQGZpbGU6ICAgZmx2LXRhZy5qc1xuICogQGF1dGhvcjogdGFuc2hhb2h1aVxuICogQGVtYWlsOiAgdGFuc2hhb2h1aUBiYWlkdS5jb21cbiAqIEBkYXRlOiAgIDIwMTYtMDktMDcgMTI6NTY6MDlcbiAqIEBsYXN0IG1vZGlmaWVkIGJ5OiAgIHRhbnNoYW9odWlcbiAqIEBsYXN0IG1vZGlmaWVkIHRpbWU6IDIwMTYtMDktMDggMjA6MTg6NTNcbiAqL1xuXG5jbGFzcyBGTFZUYWcge1xuXG4gICAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICAgICAgdGhpcy50eXBlID0gRkxWVGFnLlRBR19UWVBFX1NDUklQVERBVEFPQkpFQ1Q7XG4gICAgICAgIHRoaXMudGFnRGF0YVNpemUgPSAwO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkSGVhZGVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVhZFByZXZUYWdTaXplIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICB9XG5cbiAgICByZWFkSGVhZGVyIChkYXRhKSB7XG4gICAgICAgIHZhciB0eXBlID0gZGF0YVswXTtcbiAgICAgICAgaWYgKHR5cGUgPT09IEZMVlRhZy5UQUdfVFlQRV9BVURJTyB8fCB0eXBlID09PSBGTFZUYWcuVEFHX1RZUEVfVklERU8gfHwgdHlwZSA9PT0gRkxWVGFnLlRBR19UWVBFX1NDUklQVERBVEFPQkpFQ1QpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgRkxWVGFnVHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YWdEYXRhU2l6ZSA9IChkYXRhWzFdIDw8IDE2IHwgZGF0YVsyXSA8PCA4IHwgZGF0YVszXSk7XG5cbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSAoZGF0YVs3XSA8PCAyNCkgfCAoZGF0YVs0XSA8PCAxNikgfCAoZGF0YVs1XSA8PCA4KSB8IChkYXRhWzZdKTtcbiAgICB9XG5cbiAgICByZWFkRGF0YSAoZGF0YSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGTFZUYWcuVEFHX1RZUEVfQVVESU86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEF1ZGlvRGF0YShkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgRkxWVGFnLlRBR19UWVBFX1ZJREVPOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRWaWRlb0RhdGEoZGF0YSk7XG4gICAgICAgICAgICBjYXNlIEZMVlRhZy5UQUdfVFlQRV9TQ1JJUFREQVRBT0JKRUNUOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgRkxWVGFnVHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVhZEF1ZGlvRGF0YSAoZGF0YSkge1xuICAgICAgICB2YXIgdGFnID0ge1xuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIGlkOiBGTFZUYWcuVEFHX1RZUEVfQVVESU8sXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhdWRpb0hlYWRlciA9IGRhdGFbMF07XG4gICAgICAgIHZhciBzb3VuZEZvcm1hdCA9IChhdWRpb0hlYWRlciA+PiA0KSAmIDB4MGY7XG4gICAgICAgIHZhciBzb3VuZFJhdGUgPSAwO1xuICAgICAgICBzd2l0Y2ggKChhdWRpb0hlYWRlciA+PiAyKSAmIDB4MDMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzb3VuZFJhdGUgPSA1NTEyLjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc291bmRSYXRlID0gMTEwMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc291bmRSYXRlID0gMjIwNTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgc291bmRSYXRlID0gNDQxMDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzb3VuZFJhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBQUNcbiAgICAgICAgaWYgKHNvdW5kRm9ybWF0ID09PSAxMCkge1xuICAgICAgICAgICAgdGFnLmNvZGVjID0gJ2FhYyc7XG4gICAgICAgICAgICBsZXQgcGFja2V0VHlwZSA9IGRhdGFbMV07XG4gICAgICAgICAgICB0YWcucGt0X3R5cGUgPSBwYWNrZXRUeXBlO1xuICAgICAgICAgICAgdGFnLmRhdGEgPSBkYXRhLnNsaWNlKDIpO1xuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlYWRWaWRlb0RhdGEgKGRhdGEpIHtcbiAgICAgICAgdmFyIHRhZyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBpZDogRkxWVGFnLlRBR19UWVBFX1ZJREVPLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdmlkZW9IZWFkZXIgPSBkYXRhWzBdO1xuICAgICAgICB2YXIgY29kZWNJRCA9ICh2aWRlb0hlYWRlciAmIDB4MGYpO1xuICAgICAgICB2YXIgZnJhbWVUeXBlID0gKHZpZGVvSGVhZGVyID4+IDQpICYgMHgwZjtcbiAgICAgICAgdGFnLmtleSA9IGZyYW1lVHlwZSA9PT0gMSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgLy8gQVZDIFxuICAgICAgICBpZiAoY29kZWNJRCA9PT0gNykge1xuICAgICAgICAgICAgdGFnLmNvZGVjID0gJ2F2Yyc7XG4gICAgICAgICAgICBsZXQgcGFja2V0VHlwZSA9IGRhdGFbMV07XG4gICAgICAgICAgICB0YWcucGt0X3R5cGUgPSBwYWNrZXRUeXBlO1xuICAgICAgICAgICAgaWYgKHBhY2tldFR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9zaXRpb25UaW1lID0gZGF0YVsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvblRpbWUgfD0gZGF0YVszXSA8PCA4O1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uVGltZSB8PSBkYXRhWzRdO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGlvblRpbWUgJiAweDAwODAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uVGltZSB8PSAweGZmMDAwMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWcuY3RzID0gY29tcG9zaXRpb25UaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnLmRhdGEgPSBkYXRhLnNsaWNlKDUpO1xuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5GTFZUYWcuUFJFVl9UQUdfQllURV9DT1VOVCA9IDQ7XG5GTFZUYWcuVEFHX1RZUEVfQVVESU8gPSAweDA4O1xuRkxWVGFnLlRBR19UWVBFX1ZJREVPID0gMHgwOTtcbkZMVlRhZy5UQUdfVFlQRV9TQ1JJUFREQVRBT0JKRUNUID0gMHgxMjtcbkZMVlRhZy5UQUdfSEVBREVSX0JZVEVfQ09VTlQgPSAxMTtcblxuZXhwb3J0IGRlZmF1bHQgRkxWVGFnOyIsIi8qKlxuICogQGZpbGU6ICAgZmx2ZGVtdXhlci5qc1xuICogQGF1dGhvcjogdGFuc2hhb2h1aVxuICogQGVtYWlsOiAgdGFuc2hhb2h1aUBiYWlkdS5jb21cbiAqIEBkYXRlOiAgIDIwMTYtMDktMDcgMTA6MjM6NTdcbiAqIEBsYXN0IG1vZGlmaWVkIGJ5OiAgIHRhbnNoYW9odWlcbiAqIEBsYXN0IG1vZGlmaWVkIHRpbWU6IDIwMTYtMDktMDggMjI6NDM6MTdcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFeHBHb2xvbWIgZnJvbSAnLi9leHAtZ29sb21iJztcbmltcG9ydCBGTFZQYXJzZXIgZnJvbSAnLi4vZGVtdXgvZmx2LXBhcnNlcic7XG5pbXBvcnQgRkxWVGFnIGZyb20gJy4uL2RlbXV4L2Zsdi10YWcnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcblxuY2xhc3MgRkxWRGVtdXhlciB7XG5cbiAgICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIGlkLCByZW11eGVyQ2xhc3MsIGNvbmZpZykge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5yZW11eGVyQ2xhc3MgPSByZW11eGVyQ2xhc3M7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmxhc3RDQyA9IDA7XG4gICAgICAgIHRoaXMuZmx2UGFyc2VyID0gbmV3IEZMVlBhcnNlcigpO1xuICAgICAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgdGhpcy5yZW11eGVyQ2xhc3Mob2JzZXJ2ZXIsIGlkLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9mbHZQYXJzZXJTdGF0ZSA9IEZMVlBhcnNlci5GSUxFX0hFQURFUjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJvYmUgKGRhdGEpIHtcbiAgICAgICAgLy8gZmx2IHN0YXJ0aW5nIHdpdGggMHg0NiAweDRDIDB4NTYsIDB4MDFcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gRkxWUGFyc2VyLk1JTl9GSUxFX0hFQURFUl9CWVRFX0NPVU5UICYmIGRhdGFbMF0gPT09IDB4NDYgJiYgZGF0YVsxXSA9PT0gMHg0QyAmJiBkYXRhWzJdID09PSAweDU2ICYmIGRhdGFbM10gPT09IDB4MDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoTGV2ZWwgKCkge1xuICAgICAgICB0aGlzLl9hdmNUcmFjayA9IHtjb250YWluZXIgOiAndmlkZW8veC1mbHYnLCB0eXBlOiAndmlkZW8nLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDAsIG5iTmFsdSA6IDAsIGRyb3BwZWQgOiAwfTtcbiAgICAgICAgdGhpcy5fYWFjVHJhY2sgPSB7Y29udGFpbmVyIDogJ3ZpZGVvL3gtZmx2JywgdHlwZTogJ2F1ZGlvJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICAgICAgdGhpcy5faWQzVHJhY2sgPSB7dHlwZTogJ2lkMycsIGlkIDotMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMH07XG4gICAgICAgIHRoaXMuX3R4dFRyYWNrID0ge3R5cGU6ICd0ZXh0JywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlczogW10sIGxlbjogMH07XG4gICAgICAgIHRoaXMuYWFjTGFzdFBUUyA9IG51bGw7XG4gICAgICAgIHRoaXMuYWFjRGVsdGEgPSAwO1xuICAgICAgICB0aGlzLmF2Y0xhc3RQVFMgPSBudWxsO1xuICAgICAgICB0aGlzLmF2Y0RlbHRhID0gMDtcbiAgICAgICAgdGhpcy5yZW11eGVyLnN3aXRjaExldmVsKCk7XG4gICAgfVxuXG4gICAgaW5zZXJ0RGlzY29udGludWl0eSAoKSB7XG4gICAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoKTtcbiAgICAgICAgdGhpcy5yZW11eGVyLmluc2VydERpc2NvbnRpbnVpdHkoKTtcbiAgICB9XG5cbiAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgcHVzaCAoZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGNUYWcgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgICAgIHRoaXMuY29udGlndW91cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFhY0RlbHRhID0gMDtcbiAgICAgICAgdGhpcy5hdmNEZWx0YSA9IDA7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuX2ZsdlBhcnNlclN0YXRlID0gRkxWUGFyc2VyLkZJTEVfSEVBREVSO1xuXG4gICAgICAgIGlmIChjYyAhPT0gdGhpcy5sYXN0Q0MpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ2Rpc2NvbnRpbnVpdHkgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q0MgPSBjYztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgIT09IHRoaXMubGFzdExldmVsKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdsZXZlbCBzd2l0Y2ggZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExldmVsID0gbGV2ZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoc24gPT09ICh0aGlzLmxhc3RTTiArIDEpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFNOID0gc247XG5cbiAgICAgICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbGVuOyApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fZmx2UGFyc2VyU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEZMVlBhcnNlci5GSUxFX0hFQURFUjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHZQYXJzZXIucmVhZEZpbGVIZWFkZXIoZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBGTFZQYXJzZXIuTUlOX0ZJTEVfSEVBREVSX0JZVEVfQ09VTlQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmx2UGFyc2VyU3RhdGUgPSBGTFZQYXJzZXIuUFJFVl9UQUc7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMuZmx2UGFyc2VyLmJvZHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRkxWUGFyc2VyLlBSRVZfVEFHOlxuICAgICAgICAgICAgICAgICAgICBjVGFnID0gbmV3IEZMVlRhZygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mbHZQYXJzZXJTdGF0ZSA9IEZMVlBhcnNlci5IRUFERVI7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IEZMVlRhZy5QUkVWX1RBR19CWVRFX0NPVU5UO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZMVlBhcnNlci5IRUFERVI6XG4gICAgICAgICAgICAgICAgICAgIGNUYWcucmVhZEhlYWRlcihkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIEZMVlRhZy5UQUdfSEVBREVSX0JZVEVfQ09VTlQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmx2UGFyc2VyU3RhdGUgPSBGTFZQYXJzZXIuREFUQTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gRkxWVGFnLlRBR19IRUFERVJfQllURV9DT1VOVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGTFZQYXJzZXIuREFUQTpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZyA9IGNUYWcucmVhZERhdGEoZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjVGFnLnRhZ0RhdGFTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgJiYgdGFnLmNvZGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnLmNvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcucGt0X3R5cGUgPT09IDEgJiYgdGhpcy5fYWFjVHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQUNUYWcodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZy5wa3RfdHlwZSA9PT0gMCAmJiAhdGhpcy5fYWFjVHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBdWRpb0NvbmZpZyh0aGlzLm9ic2VydmVyLCB0YWcuZGF0YSwgMCwgYXVkaW9Db2RlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FhY1RyYWNrLmlkID0gdGFnLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnLmNvZGVjID09PSAnYXZjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcucGt0X3R5cGUgPT09IDEgJiYgdGhpcy5fYXZjVHJhY2subGVuZ3RoU2l6ZU1pbnVzT25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBVkNUYWcodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZy5wa3RfdHlwZSA9PT0gMCAmJiAhdGhpcy5fYXZjVHJhY2subGVuZ3RoU2l6ZU1pbnVzT25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VWaWRlb0NvbmZpZyh0aGlzLm9ic2VydmVyLCB0YWcuZGF0YSwgMCwgYXVkaW9Db2RlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F2Y1RyYWNrLmlkID0gdGFnLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mbHZQYXJzZXJTdGF0ZSA9IEZMVlBhcnNlci5QUkVWX1RBRztcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gY1RhZy50YWdEYXRhU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEZMVlBhcnNlclN0YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYXZjRnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgbGV0IHNhbXBsZXMgPSB0aGlzLl9hdmNUcmFjay5zYW1wbGVzO1xuICAgICAgICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0UFRTID0gc2FtcGxlc1swXS5wdHM7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RQVFMgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0ucHRzOyBcbiAgICAgICAgICAgICAgICB0aGlzLmF2Y0ZyYW1lRHVyYXRpb24gPSBNYXRoLnJvdW5kKChsYXN0UFRTIC0gZmlyc3RQVFMpIC8gKHNhbXBsZXMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW11eChsZXZlbCwgc24sIG51bGwpO1xuICAgIH1cblxuICAgIHJlbXV4IChsZXZlbCwgc24sIGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGxldmVsLCBzbiwgdGhpcy5fYWFjVHJhY2ssIHRoaXMuX2F2Y1RyYWNrLCB0aGlzLl9pZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRoaXMudGltZU9mZnNldCwgdGhpcy5jb250aWd1b3VzLCBkYXRhKTtcbiAgICB9XG5cbiAgICBkZXN0cm95ICgpIHtcbiAgICB9XG5cbiAgICBwYXJzZUFBQ1RhZyAodGFnKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2FhY1RyYWNrO1xuICAgICAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICAgIHZhciBwdHMgPSBNYXRoLnJvdW5kKCh0aGlzLnRpbWVPZmZzZXQgKiAxMDAwICsgdGFnLnRpbWVzdGFtcCkgKiA5MCkgLSB0aGlzLmFhY0RlbHRhO1xuICAgICAgICB2YXIgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUztcbiAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSAxMDI0ICogOTAwMDAgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICAgIGlmIChhYWNMYXN0UFRTICYmICF0aGlzLmFhY0RlbHRhKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFB0cyA9IGFhY0xhc3RQVFMgKyBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgbGV0IGFhY0RlbHRhID0gcHRzIC0gbmV4dFB0cztcbiAgICAgICAgICAgIGlmIChhYWNEZWx0YSA+IGZyYW1lRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFhY0RlbHRhID0gYWFjRGVsdGE7XG4gICAgICAgICAgICAgICAgcHRzID0gbmV4dFB0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgZHRzOiBwdHMsXG4gICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgIHVuaXQ6IHRhZy5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgICB0cmFjay5sZW4gKz0gdGFnLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5hYWNMYXN0UFRTID0gcHRzO1xuICAgIH1cblxuICAgIHBhcnNlQVZDVGFnICh0YWcpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2s7XG4gICAgICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyxcbiAgICAgICAgICAgIHVuaXRzID0gdGhpcy5wYXJzZUFWQ05BTFVuaXQodGFnLmRhdGEpLFxuICAgICAgICAgICAgdW5pdHMyID0gW10sXG4gICAgICAgICAgICBkZWJ1ZyA9IGZhbHNlLFxuICAgICAgICAgICAga2V5ID0gZmFsc2UsXG4gICAgICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlcixcbiAgICAgICAgICAgIGF2Y1NhbXBsZSxcbiAgICAgICAgICAgIHB1c2gsXG4gICAgICAgICAgICBpO1xuICAgICAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgICAgIGlmICh1bml0cy5sZW5ndGggPT09IDAgJiYgc2FtcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBhcHBlbmQgdGFnLmRhdGEgdG8gcHJldmlvdXMgTkFMIHVuaXRcbiAgICAgICAgICAgIHZhciBsYXN0YXZjU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIGxhc3RVbml0ID0gbGFzdGF2Y1NhbXBsZS51bml0cy51bml0c1tsYXN0YXZjU2FtcGxlLnVuaXRzLnVuaXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIHRhZy5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgICAgIHRtcC5zZXQodGFnLmRhdGEsIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgbGFzdGF2Y1NhbXBsZS51bml0cy5sZW5ndGggKz0gdGFnLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHRyYWNrLmxlbiArPSB0YWcuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZyZWUgdGFnLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgICAgICB0YWcuZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciBkZWJ1Z1N0cmluZyA9ICcnO1xuICAgICAgICB2YXIgYXZjTGFzdFBUUyA9IHRoaXMuYXZjTGFzdFBUUztcbiAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSB0aGlzLmF2Y0ZyYW1lRHVyYXRpb247XG4gICAgICAgIHZhciBkdHMgPSBNYXRoLnJvdW5kKCh0aGlzLnRpbWVPZmZzZXQgKiAxMDAwICsgdGFnLnRpbWVzdGFtcCkgKiA5MCkgLSB0aGlzLmF2Y0RlbHRhO1xuICAgICAgICB2YXIgcHRzID0gZHRzICsgdGFnLmN0cyAqIDkwO1xuXG4gICAgICAgIGlmIChhdmNMYXN0UFRTICYmIGZyYW1lRHVyYXRpb24gJiYgIXRoaXMuYXZjRGVsdGEpIHtcbiAgICAgICAgICAgIGxldCBuZXh0UHRzID0gYXZjTGFzdFBUUyArIGZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBsZXQgYXZjRGVsdGEgPSBwdHMgLSBuZXh0UHRzO1xuICAgICAgICAgICAgaWYgKGF2Y0RlbHRhID4gZnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXZjRGVsdGEgPSBhdmNEZWx0YTtcbiAgICAgICAgICAgICAgICBwdHMgPSBuZXh0UHRzO1xuICAgICAgICAgICAgICAgIGR0cyA9IHB0cyAtIHRhZy5jdHMgKiA5MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwdXNoQWNjZXNVbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodW5pdHMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAgICAgICAgICAgLy8gICAgaWYga2V5ZnJhbWUgYWxyZWFkeSBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IE9SXG4gICAgICAgICAgICAgICAgLy8gICAgICAga2V5ZnJhbWUgZm91bmQgaW4gbGFzdCBmcmFnbWVudCAodHJhY2suc3BzKSBBTkRcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5IHx8XG4gICAgICAgICAgICAgICAgICAgIGtleSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAodHJhY2suc3BzICYmIChzYW1wbGVzLmxlbmd0aCB8fCB0aGlzLmNvbnRpZ3VvdXMpKSkge1xuICAgICAgICAgICAgICAgICAgICBhdmNTYW1wbGUgPSB7IHVuaXRzOiB7IHVuaXRzOiB1bml0czIsIGxlbmd0aDogbGVuZ3RoIH0sIHB0czogcHRzLCBkdHM6IGR0cywga2V5OiBrZXkgfTtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLm5iTmFsdSArPSB1bml0czIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgc2FtcGxlcywgdHJhY2sgaXRcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suZHJvcHBlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bml0czIgPSBbXTtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgLy9ORFJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICdORFIgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvL0lEUlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ0lEUiAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vU0VJXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z1N0cmluZyArPSAnU0VJICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodGhpcy5kaXNjYXJkRVBCKHVuaXQuZGF0YSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgZnJhbWVUeXBlXG4gICAgICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhlcmUgY2FuIGJlIG1vcmUgdGhhbiBvbmUgcGF5bG9hZCBpbiBhbiBTRUkgcGFja2V0Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHJlYWQgdHlwZSBhbmQgc2l6ZSBpbiBhIHdoaWxlIGxvb3AgdG8gZ2V0IHRoZW0gYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVJbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQ0NzID0gMzEgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBieXRlcyBwZXIgQ0NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2FtcGxlSW5PcmRlcih0aGlzLl90eHRUcmFjay5zYW1wbGVzLCB7IHR5cGU6IDMsIHB0czogcHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBheWxvYWRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy9TUFNcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICdTUFMgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodW5pdC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnNwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vUFBTXG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z1N0cmluZyArPSAnUFBTICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICdBVUQgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwdXNoQWNjZXNVbml0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ3Vua25vd24gTkFMICcgKyB1bml0LnR5cGUgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHB1c2gpIHtcbiAgICAgICAgICAgICAgICB1bml0czIucHVzaCh1bml0KTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVidWcgfHwgZGVidWdTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGRlYnVnU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoQWNjZXNVbml0KCk7XG4gICAgICAgIHRoaXMuYXZjTGFzdFBUUyA9IHB0cztcbiAgICB9XG5cbiAgICBpbnNlcnRTYW1wbGVJbk9yZGVyIChhcnIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5wdHMgPj0gYXJyW2xlbiAtIDFdLnB0cykge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKHBvcywgMCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VBVkNOQUxVbml0IChhcnJheSkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaztcbiAgICAgICAgdmFyIGxlbmd0aFNpemVNaW51c09uZSA9IHRyYWNrLmxlbmd0aFNpemVNaW51c09uZTtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGxldCB1bml0TGVuID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoU2l6ZU1pbnVzT25lOyBqKyspIHtcbiAgICAgICAgICAgICAgICB1bml0TGVuIHw9IGFycmF5W2kgKyBqXSA8PCAoOCAqIChsZW5ndGhTaXplTWludXNPbmUgLSAxIC0gaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSBsZW5ndGhTaXplTWludXNPbmU7XG4gICAgICAgICAgICBsZXQgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgICB1bml0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB1bml0VHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBhcnJheS5zbGljZShpLCBpICsgdW5pdExlbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaSArPSB1bml0TGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICBwYXJzZUF1ZGlvQ29uZmlnIChvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2FhY1RyYWNrO1xuICAgICAgICB2YXIgYWR0c09iamVjdFR5cGUsIC8vIDppbnRcbiAgICAgICAgICAgIGFkdHNTYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgICAgICAgICBhZHRzQ2hhbmVsQ29uZmlnLCAvLyA6aW50XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgOTYwMDAsIDg4MjAwLFxuICAgICAgICAgICAgICAgIDY0MDAwLCA0ODAwMCxcbiAgICAgICAgICAgICAgICA0NDEwMCwgMzIwMDAsXG4gICAgICAgICAgICAgICAgMjQwMDAsIDIyMDUwLFxuICAgICAgICAgICAgICAgIDE2MDAwLCAxMjAwMCxcbiAgICAgICAgICAgICAgICAxMTAyNSwgODAwMCxcbiAgICAgICAgICAgICAgICA3MzUwXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gKGRhdGFbMF0gJiAweEY4KSA+PiAzO1xuICAgICAgICBhZHRzU2FtcGxlaW5nSW5kZXggPSAoKGRhdGFbMF0gJiAweDcpIDw8IDEpIHwgKGRhdGFbMV0gPj4gNyk7XG4gICAgICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPiBhZHRzU2FtcGxlaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fWAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWR0c0NoYW5lbENvbmZpZyA9IChkYXRhWzFdID4+IDMpICYgMHgwRjtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgY29kZWM6JHthdWRpb0NvZGVjfSxBRFRTIGRhdGE6dHlwZToke2FkdHNPYmplY3RUeXBlfSxzYW1wbGVpbmdJbmRleDoke2FkdHNTYW1wbGVpbmdJbmRleH1bJHthZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XX1Iel0sY2hhbm5lbENvbmZpZzoke2FkdHNDaGFuZWxDb25maWd9YCk7XG4gICAgICAgIC8vIGZpcmVmb3g6IGZyZXEgbGVzcyB0aGFuIDI0a0h6ID0gQUFDIFNCUiAoSEUtQUFDKVxuICAgICAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikge1xuICAgICAgICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG4gICAgICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKGNocm9tZSAuLi4pXG4gICAgICAgICAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcbiAgICAgICAgICAgIGlmICgoYXVkaW9Db2RlYyAmJiAoKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XG4gICAgICAgICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSkge1xuICAgICAgICAgICAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgICAgICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXggLSAzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHBsYXkgYmFjayB3aXRoIGxvdyBmcmVxdWVuY3kgQUFDIExDIG1vbm8gd2hlbiBpbml0aWFsaXplZCB3aXRoIEhFLUFBQy4gIFRoaXMgaXMgbm90IGEgcHJvYmxlbSB3aXRoIHN0ZXJlby5cbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiAoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgICAgICAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgICAgICAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuICAgICAgICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgICAgIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAgICAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgICAgICAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcbiAgICAgICAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgICAgICAgICAvLyBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXhcbiAgICAgICAgICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcbiAgICAgICAgICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgICAgICAgICAgLy8gYWR0c09iamVjdFR5cGUgKGZvcmNlIHRvIDIsIGNocm9tZSBpcyBjaGVja2luZyB0aGF0IG9iamVjdCB0eXBlIGlzIGxlc3MgdGhhbiA1ID8/P1xuICAgICAgICAgICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgICAgICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgICAgICAgICAgY29uZmlnWzNdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgdHJhY2suY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgdHJhY2suYXVkaW9zYW1wbGVyYXRlID0gYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF07XG4gICAgICAgICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBhZHRzQ2hhbmVsQ29uZmlnO1xuICAgICAgICAgICAgdHJhY2suY29kZWMgPSAoJ21wNGEuNDAuJyArIGFkdHNPYmplY3RUeXBlKTtcbiAgICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0sXG4gICAgICAgICAgICBjaGFubmVsQ291bnQ6IGFkdHNDaGFuZWxDb25maWcsXG4gICAgICAgICAgICBjb2RlYzogKCdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVZpZGVvQ29uZmlnIChvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB2aWRlb0NvZGVjKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrO1xuICAgICAgICB2YXIgY29uZmlndXJhdGlvblZlcnNpb24gPSBkYXRhWzBdO1xuICAgICAgICB2YXIgQVZDUHJvZmlsZUluZGljYXRpb24gPSBkYXRhWzFdO1xuICAgICAgICB2YXIgcHJvZmlsZV9jb21wYXRpYmlsaXR5ID0gZGF0YVsyXTtcbiAgICAgICAgdmFyIEFWQ0xldmVsSW5kaWNhdGlvbiA9IGRhdGFbM107XG4gICAgICAgIHZhciBsZW5ndGhTaXplTWludXNPbmUgPSAxICsgKGRhdGFbNF0gJiAzKTtcbiAgICAgICAgdmFyIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzID0gZGF0YVs1XSAmIDB4MUY7XG4gICAgICAgIHZhciBzaWR4ID0gNjtcbiAgICAgICAgdmFyIHNlcXVlbmNlUGFyYW1ldGVyU2V0TGVuZ3RoID0gbmV3IERhdGFWaWV3KGRhdGEuc2xpY2Uoc2lkeCwgc2lkeCArIDIpLmJ1ZmZlcikuZ2V0VWludDE2KDApO1xuICAgICAgICBzaWR4ICs9IDI7XG4gICAgICAgIHZhciBzZXF1ZW5jZVBhcmFtZXRlclNldE5BTFVuaXRzID0gZGF0YS5zbGljZShzaWR4LCBzaWR4ICsgc2VxdWVuY2VQYXJhbWV0ZXJTZXRMZW5ndGgpO1xuICAgICAgICBzaWR4ICs9IHNlcXVlbmNlUGFyYW1ldGVyU2V0TGVuZ3RoO1xuICAgICAgICB2YXIgbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0cyA9IGRhdGFbc2lkeCsrXTtcbiAgICAgICAgdmFyIHBpY3R1cmVQYXJhbWV0ZXJTZXRMZW5ndGggPSBuZXcgRGF0YVZpZXcoZGF0YS5zbGljZShzaWR4LCBzaWR4ICsgMikuYnVmZmVyKS5nZXRVaW50MTYoMCk7XG4gICAgICAgIHNpZHggKz0gMjtcbiAgICAgICAgdmFyIHBpY3R1cmVQYXJhbWV0ZXJTZXROQUxVbml0cyA9IGRhdGEuc2xpY2Uoc2lkeCwgc2lkeCArIHBpY3R1cmVQYXJhbWV0ZXJTZXRMZW5ndGgpO1xuICAgICAgICBpZiAoIXRyYWNrLmxlbmd0aFNpemVNaW51c09uZSkge1xuICAgICAgICAgICAgdHJhY2subGVuZ3RoU2l6ZU1pbnVzT25lID0gbGVuZ3RoU2l6ZU1pbnVzT25lO1xuICAgICAgICAgICAgdmFyIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHNlcXVlbmNlUGFyYW1ldGVyU2V0TkFMVW5pdHMpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3NlcXVlbmNlUGFyYW1ldGVyU2V0TkFMVW5pdHNdO1xuICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gc2VxdWVuY2VQYXJhbWV0ZXJTZXROQUxVbml0cy5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgIHZhciBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoID0gY29kZWNhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgICB0cmFjay5wcHMgPSBbcGljdHVyZVBhcmFtZXRlclNldE5BTFVuaXRzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVuZ3RoU2l6ZU1pbnVzT25lOiBsZW5ndGhTaXplTWludXNPbmUsXG4gICAgICAgICAgICBzZXF1ZW5jZVBhcmFtZXRlclNldE5BTFVuaXRzOiBzZXF1ZW5jZVBhcmFtZXRlclNldE5BTFVuaXRzLFxuICAgICAgICAgICAgcGljdHVyZVBhcmFtZXRlclNldE5BTFVuaXRzOiBwaWN0dXJlUGFyYW1ldGVyU2V0TkFMVW5pdHNcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRkxWRGVtdXhlcjsiLCIvKipcbiAqIElEMyBwYXJzZXJcbiAqL1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG4vL2ltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcblxuIGNsYXNzIElEMyB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX2hhc1RpbWVTdGFtcCA9IGZhbHNlO1xuICAgIHZhciBvZmZzZXQgPSAwLCBieXRlMSxieXRlMixieXRlMyxieXRlNCx0YWdTaXplLGVuZFBvcyxoZWFkZXIsbGVuO1xuICAgICAgZG8ge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsMyk7XG4gICAgICAgIG9mZnNldCs9MztcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgSUQzIGhlYWRlclxuICAgICAgICAgIGlmIChoZWFkZXIgPT09ICdJRDMnKSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgMjQgYml0c1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGFnKHMpIGxlbmd0aFxuICAgICAgICAgICAgICBieXRlMSA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgYnl0ZTIgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgICAgICAgIGJ5dGUzID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICBieXRlNCA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgdGFnU2l6ZSA9IChieXRlMSA8PCAyMSkgKyAoYnl0ZTIgPDwgMTQpICsgKGJ5dGUzIDw8IDcpICsgYnl0ZTQ7XG4gICAgICAgICAgICAgIGVuZFBvcyA9IG9mZnNldCArIHRhZ1NpemU7XG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSUQzIHRhZyBmb3VuZCwgc2l6ZS9lbmQ6ICR7dGFnU2l6ZX0vJHtlbmRQb3N9YCk7XG5cbiAgICAgICAgICAgICAgLy8gcmVhZCBJRDMgdGFnc1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlEM0ZyYW1lcyhkYXRhLCBvZmZzZXQsZW5kUG9zKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gZW5kUG9zO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnM0RJJykge1xuICAgICAgICAgICAgICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi40LjAtc3RydWN0dXJlIGNoYXB0ZXIgMy40LiAgIElEM3YyIGZvb3RlclxuICAgICAgICAgICAgICBvZmZzZXQgKz0gNztcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYDNESSBmb290ZXIgZm91bmQsIGVuZDogJHtvZmZzZXR9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICAgIGxlbiA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYElEMyBsZW46ICR7bGVufWApO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNUaW1lU3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0lEMyB0YWcgZm91bmQsIGJ1dCBubyB0aW1lc3RhbXAnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BheWxvYWQgPSBkYXRhLnN1YmFycmF5KDAsbGVuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgcmVhZFVURihkYXRhLHN0YXJ0LGxlbikge1xuXG4gICAgdmFyIHJlc3VsdCA9ICcnLG9mZnNldCA9IHN0YXJ0LCBlbmQgPSBzdGFydCArIGxlbjtcbiAgICBkbyB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW29mZnNldCsrXSk7XG4gICAgfSB3aGlsZShvZmZzZXQgPCBlbmQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfcGFyc2VJRDNGcmFtZXMoZGF0YSxvZmZzZXQsZW5kUG9zKSB7XG4gICAgdmFyIHRhZ0lkLHRhZ0xlbix0YWdTdGFydCx0YWdGbGFncyx0aW1lc3RhbXA7XG4gICAgd2hpbGUob2Zmc2V0ICsgOCA8PSBlbmRQb3MpIHtcbiAgICAgIHRhZ0lkID0gdGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQpO1xuICAgICAgb2Zmc2V0ICs9NDtcblxuICAgICAgdGFnTGVuID0gZGF0YVtvZmZzZXQrK10gPDwgMjQgK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdIDw8IDE2ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXTtcblxuICAgICAgdGFnRmxhZ3MgPSBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdO1xuXG4gICAgICB0YWdTdGFydCA9IG9mZnNldDtcbiAgICAgIC8vbG9nZ2VyLmxvZyhcIklEMyB0YWcgaWQ6XCIgKyB0YWdJZCk7XG4gICAgICBzd2l0Y2godGFnSWQpIHtcbiAgICAgICAgY2FzZSAnUFJJVic6XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ3BhcnNlIGZyYW1lOicgKyBIZXguaGV4RHVtcChkYXRhLnN1YmFycmF5KG9mZnNldCxlbmRQb3MpKSk7XG4gICAgICAgICAgICAvLyBvd25lciBzaG91bGQgYmUgXCJjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcFwiXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQ0KSA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCs9NDQ7XG4gICAgICAgICAgICAgICAgLy8gc21lbGxpbmcgZXZlbiBiZXR0ZXIgISB3ZSBmb3VuZCB0aGUgcmlnaHQgZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgIC8vIHNraXAgbnVsbCBjaGFyYWN0ZXIgKHN0cmluZyBlbmQpICsgMyBmaXJzdCBieXRlc1xuICAgICAgICAgICAgICAgIG9mZnNldCs9IDQ7XG5cbiAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLCB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgICAgICAgICAgICAgIHZhciBwdHMzM0JpdCAgPSBkYXRhW29mZnNldCsrXSAmIDB4MTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUaW1lU3RhbXAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gKChkYXRhW29mZnNldCsrXSA8PCAyMykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQrK10gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0KytdIDw8ICA3KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdKSAvNDU7XG5cbiAgICAgICAgICAgICAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wICAgKz0gNDc3MjE4NTguODQ7IC8vIDJeMzIgLyA5MFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBJRDMgdGltZXN0YW1wIGZvdW5kOiAke3RpbWVzdGFtcH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBoYXNUaW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfVxuXG4gIGdldCBwYXlsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXlsb2FkO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUQzO1xuXG4iLCIvKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuKi9cblxuIGltcG9ydCBBRFRTIGZyb20gJy4vYWR0cyc7XG4gaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG4gaW1wb3J0IEV4cEdvbG9tYiBmcm9tICcuL2V4cC1nb2xvbWInO1xuLy8gaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuIGltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuIGltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4gY2xhc3MgVFNEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgaWQsIHJlbXV4ZXJDbGFzcywgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnJlbXV4ZXJDbGFzcyA9IHJlbXV4ZXJDbGFzcztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmxhc3RDQyA9IDA7XG4gICAgdGhpcy5yZW11eGVyID0gbmV3IHRoaXMucmVtdXhlckNsYXNzKG9ic2VydmVyLCBpZCwgY29uZmlnKTtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDMqMTg4ICYmIGRhdGFbMF0gPT09IDB4NDcgJiYgZGF0YVsxODhdID09PSAweDQ3ICYmIGRhdGFbMioxODhdID09PSAweDQ3KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaExldmVsKCkge1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl9hdmNUcmFjayA9IHtjb250YWluZXIgOiAndmlkZW8vbXAydCcsIHR5cGU6ICd2aWRlbycsIGlkIDotMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMCwgbmJOYWx1IDogMCwgZHJvcHBlZCA6IDB9O1xuICAgIHRoaXMuX2FhY1RyYWNrID0ge2NvbnRhaW5lciA6ICd2aWRlby9tcDJ0JywgdHlwZTogJ2F1ZGlvJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHt0eXBlOiAnaWQzJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICB0aGlzLl90eHRUcmFjayA9IHt0eXBlOiAndGV4dCcsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXM6IFtdLCBsZW46IDB9O1xuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuYXZjTmFsdVN0YXRlID0gMDtcbiAgICB0aGlzLnJlbXV4ZXIuc3dpdGNoTGV2ZWwoKTtcbiAgfVxuXG4gIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbCgpO1xuICAgIHRoaXMucmVtdXhlci5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgYXZjRGF0YSwgYWFjRGF0YSwgaWQzRGF0YSxcbiAgICAgICAgc3RhcnQsIGxlbiA9IGRhdGEubGVuZ3RoLCBzdHQsIHBpZCwgYXRmLCBvZmZzZXQsXG4gICAgICAgIGNvZGVjc09ubHkgPSB0aGlzLnJlbXV4ZXIucGFzc3Rocm91Z2gsXG4gICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuY29udGlndW91cyA9IGZhbHNlO1xuICAgIGlmIChjYyAhPT0gdGhpcy5sYXN0Q0MpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2Rpc2NvbnRpbnVpdHkgZGV0ZWN0ZWQnKTtcbiAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgICAgdGhpcy5sYXN0Q0MgPSBjYztcbiAgICB9XG4gICAgaWYgKGxldmVsICE9PSB0aGlzLmxhc3RMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZygnbGV2ZWwgc3dpdGNoIGRldGVjdGVkJyk7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKCk7XG4gICAgICB0aGlzLmxhc3RMZXZlbCA9IGxldmVsO1xuICAgIH0gZWxzZSBpZiAoc24gPT09ICh0aGlzLmxhc3RTTisxKSkge1xuICAgICAgdGhpcy5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0U04gPSBzbjtcblxuICAgIHZhciBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCxcbiAgICAgICAgYXZjSWQgPSB0aGlzLl9hdmNUcmFjay5pZCxcbiAgICAgICAgYWFjSWQgPSB0aGlzLl9hYWNUcmFjay5pZCxcbiAgICAgICAgaWQzSWQgPSB0aGlzLl9pZDNUcmFjay5pZCxcbiAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZDtcblxuICAgIHZhciBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULFxuICAgICAgICBwYXJzZVBNVCA9IHRoaXMuX3BhcnNlUE1ULFxuICAgICAgICBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLFxuICAgICAgICBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksXG4gICAgICAgIHBhcnNlQUFDUEVTID0gdGhpcy5fcGFyc2VBQUNQRVMuYmluZCh0aGlzKSxcbiAgICAgICAgcGFyc2VJRDNQRVMgID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcblxuICAgIC8vIGRvbid0IHBhcnNlIGxhc3QgVFMgcGFja2V0IGlmIGluY29tcGxldGVcbiAgICBsZW4gLT0gbGVuICUgMTg4O1xuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcbiAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHBpZCkge1xuICAgICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VBVkNQRVMocGFyc2VQRVMoYXZjRGF0YSkpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlY3NPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHZpZGVvIGNvZGVjIGluZm8gQU5EXG4gICAgICAgICAgICAgICAgICAvLyBpZiBhdWRpbyBQSUQgaXMgdW5kZWZpbmVkIE9SIGlmIHdlIGhhdmUgYXVkaW8gY29kZWMgaW5mbyxcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxsIGNvZGVjIGluZm8gIVxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F2Y1RyYWNrLmNvZGVjICYmIChhYWNJZCA9PT0gLTEgfHwgdGhpcy5fYWFjVHJhY2suY29kZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtdXgobGV2ZWwsc24sZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXZjRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhYWNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGFhY0RhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwYXJzZVBFUyhhYWNEYXRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjc09ubHkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGhlcmUgd2Ugbm93IHRoYXQgd2UgaGF2ZSBhdWRpbyBjb2RlYyBpbmZvXG4gICAgICAgICAgICAgICAgICAvLyBpZiB2aWRlbyBQSUQgaXMgdW5kZWZpbmVkIE9SIGlmIHdlIGhhdmUgdmlkZW8gY29kZWMgaW5mbyxcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxsIGNvZGVjIGluZm9zICFcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hYWNUcmFjay5jb2RlYyAmJiAoYXZjSWQgPT09IC0xIHx8IHRoaXMuX2F2Y1RyYWNrLmNvZGVjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbXV4KGxldmVsLHNuLGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFhY0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFhY0RhdGEpIHtcbiAgICAgICAgICAgICAgYWFjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGFhY0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VJRDNQRVMocGFyc2VQRVMoaWQzRGF0YSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkM0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYXZjSWQgPSB0aGlzLl9hdmNUcmFjay5pZCA9IHBhcnNlZFBJRHMuYXZjO1xuICAgICAgICAgICAgYWFjSWQgPSB0aGlzLl9hYWNUcmFjay5pZCA9IHBhcnNlZFBJRHMuYWFjO1xuICAgICAgICAgICAgaWQzSWQgPSB0aGlzLl9pZDNUcmFjay5pZCA9IHBhcnNlZFBJRHMuaWQzO1xuICAgICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgIHN0YXJ0ID0gLTE4ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnVFMgcGFja2V0IGRpZCBub3Qgc3RhcnQgd2l0aCAweDQ3J30pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwYXJzZSBsYXN0IFBFUyBwYWNrZXRcbiAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgcGFyc2VBVkNQRVMocGFyc2VQRVMoYXZjRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoYWFjRGF0YSkge1xuICAgICAgcGFyc2VBQUNQRVMocGFyc2VQRVMoYWFjRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgcGFyc2VJRDNQRVMocGFyc2VQRVMoaWQzRGF0YSkpO1xuICAgIH1cbiAgICB0aGlzLnJlbXV4KGxldmVsLHNuLG51bGwpO1xuICB9XG5cbiAgcmVtdXgobGV2ZWwsIHNuLCBkYXRhKSB7XG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KGxldmVsLCBzbiwgdGhpcy5fYWFjVHJhY2ssIHRoaXMuX2F2Y1RyYWNrLCB0aGlzLl9pZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRoaXMudGltZU9mZnNldCwgdGhpcy5jb250aWd1b3VzLCBkYXRhKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbCgpO1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgfVxuXG4gIF9wYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gICAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgICAvL2xvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gIH1cblxuICBfcGFyc2VQTVQoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdmFyIHNlY3Rpb25MZW5ndGgsIHRhYmxlRW5kLCBwcm9ncmFtSW5mb0xlbmd0aCwgcGlkLCByZXN1bHQgPSB7IGFhYyA6IC0xLCBhdmMgOiAtMSwgaWQzIDogLTF9O1xuICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgIHN3aXRjaChkYXRhW29mZnNldF0pIHtcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYWFjID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmFhYyA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnSUQzIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYXZjID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgICBsb2dnZXIud2FybignSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCwgbm90IHN1cHBvcnRlZCBmb3Igbm93Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX3BhcnNlUEVTKHN0cmVhbSkge1xuICAgIHZhciBpID0gMCwgZnJhZywgcGVzRmxhZ3MsIHBlc1ByZWZpeCwgcGVzTGVuLCBwZXNIZHJMZW4sIHBlc0RhdGEsIHBlc1B0cywgcGVzRHRzLCBwYXlsb2FkU3RhcnRPZmZzZXQsIGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAgIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgICB3aGlsZShkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgICBkYXRhLnNwbGljZSgxLDEpO1xuICAgIH1cbiAgICAvL3JldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICAgIGZyYWcgPSBkYXRhWzBdO1xuICAgIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweEMwKSB7XG4gICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxuICAgICAgICAgIChmcmFnWzEwXSAmIDB4RkYpICogNDE5NDMwNCArLy8gMSA8PCAyMlxuICAgICAgICAgIChmcmFnWzExXSAmIDB4RkUpICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XG4gICAgICAgICAgKGZyYWdbMTNdICYgMHhGRSkgLyAyO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXG4gICAgICAgICAgaWYgKHBlc1B0cyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgICBwZXNQdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcbiAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBFICkgKiA1MzY4NzA5MTIgKy8vIDEgPDwgMjlcbiAgICAgICAgICAgIChmcmFnWzE1XSAmIDB4RkYgKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcbiAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUgKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XG4gICAgICAgICAgICAoZnJhZ1sxN10gJiAweEZGICkgKiAxMjggKy8vIDEgPDwgN1xuICAgICAgICAgICAgKGZyYWdbMThdICYgMHhGRSApIC8gMjtcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgIGlmIChwZXNEdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgcGVzRHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG5cbiAgICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgIC8vcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGZyYWcgPSBkYXRhLnNoaWZ0KCk7XG4gICAgICAgIHZhciBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldC09bGVuO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgICBsZW4tPXBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgICBpKz1sZW47XG4gICAgICB9XG4gICAgICByZXR1cm4ge2RhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW59O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfcGFyc2VBVkNQRVMocGVzKSB7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxuICAgICAgICB1bml0cyA9IHRoaXMuX3BhcnNlQVZDTkFMdShwZXMuZGF0YSksXG4gICAgICAgIHVuaXRzMiA9IFtdLFxuICAgICAgICBkZWJ1ZyA9IGZhbHNlLFxuICAgICAgICBrZXkgPSBmYWxzZSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgZXhwR29sb21iRGVjb2RlcixcbiAgICAgICAgYXZjU2FtcGxlLFxuICAgICAgICBwdXNoLFxuICAgICAgICBpO1xuICAgIC8vIG5vIE5BTHUgZm91bmRcbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwICYmIHNhbXBsZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICB2YXIgbGFzdGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0VW5pdCA9IGxhc3RhdmNTYW1wbGUudW5pdHMudW5pdHNbbGFzdGF2Y1NhbXBsZS51bml0cy51bml0cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBwZXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICB0bXAuc2V0KHBlcy5kYXRhLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgIGxhc3RhdmNTYW1wbGUudW5pdHMubGVuZ3RoICs9IHBlcy5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICB0cmFjay5sZW4gKz0gcGVzLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgLy9mcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG4gICAgdmFyIGRlYnVnU3RyaW5nID0gJyc7XG5cbiAgICB2YXIgcHVzaEFjY2VzVW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHVuaXRzMi5sZW5ndGgpIHtcbiAgICAgICAgLy8gb25seSBwdXNoIEFWQyBzYW1wbGUgaWYgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lIGlzIG5vdCBtYW5kYXRvcnkgT1JcbiAgICAgICAgLy8gICAgaWYga2V5ZnJhbWUgYWxyZWFkeSBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IE9SXG4gICAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAgIC8vICAgICAgICAgIHNhbXBsZXMgYWxyZWFkeSBhcHBlbmRlZCAod2UgYWxyZWFkeSBmb3VuZCBhIGtleWZyYW1lIGluIHRoaXMgZnJhZ21lbnQpIE9SIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXNcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5IHx8XG4gICAgICAgICAgICBrZXkgPT09IHRydWUgfHxcbiAgICAgICAgICAgICh0cmFjay5zcHMgJiYgKHNhbXBsZXMubGVuZ3RoIHx8IHRoaXMuY29udGlndW91cykpKSB7XG4gICAgICAgICAgYXZjU2FtcGxlID0ge3VuaXRzOiB7IHVuaXRzIDogdW5pdHMyLCBsZW5ndGggOiBsZW5ndGh9LCBwdHM6IHBlcy5wdHMsIGR0czogcGVzLmR0cywga2V5OiBrZXl9O1xuICAgICAgICAgIHNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICAgICAgICAgIHRyYWNrLmxlbiArPSBsZW5ndGg7XG4gICAgICAgICAgdHJhY2submJOYWx1ICs9IHVuaXRzMi5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZHJvcHBlZCBzYW1wbGVzLCB0cmFjayBpdFxuICAgICAgICAgIHRyYWNrLmRyb3BwZWQrKztcbiAgICAgICAgfVxuICAgICAgICB1bml0czIgPSBbXTtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgc3dpdGNoKHVuaXQudHlwZSkge1xuICAgICAgICAvL05EUlxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgaWYoZGVidWcpIHtcbiAgICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICdORFIgJztcbiAgICAgICAgICAgfVxuICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9JRFJcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmKGRlYnVnKSB7XG4gICAgICAgICAgICBkZWJ1Z1N0cmluZyArPSAnSURSICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vU0VJXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ1NFSSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih0aGlzLmRpc2NhcmRFUEIodW5pdC5kYXRhKSk7XG5cbiAgICAgICAgICAvLyBza2lwIGZyYW1lVHlwZVxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYiA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAoIWVuZE9mQ2FwdGlvbnMgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSA+IDEpIHtcbiAgICAgICAgICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxuICAgICAgICAgICAgLy8gVE9ETzogbmVlZCB0byByZWFkIHR5cGUgYW5kIHNpemUgaW4gYSB3aGlsZSBsb29wIHRvIGdldCB0aGVtIGFsbFxuICAgICAgICAgICAgaWYgKHBheWxvYWRUeXBlID09PSA0ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcblxuICAgICAgICAgICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxDQ3MgPSAzMSAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gW2ZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBieXRlcyBwZXIgQ0NcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTYW1wbGVJbk9yZGVyKHRoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGk8cGF5bG9hZFNpemU7IGkrKylcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vU1BTXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ1NQUyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighdHJhY2suc3BzKSB7XG4gICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih1bml0LmRhdGEpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvZGVjYXJyYXkgPSB1bml0LmRhdGEuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL1BQU1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYoZGVidWcpIHtcbiAgICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICdQUFMgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgZGVidWdTdHJpbmcgKz0gJ0FVRCAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoQWNjZXNVbml0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGRlYnVnU3RyaW5nICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYocHVzaCkge1xuICAgICAgICB1bml0czIucHVzaCh1bml0KTtcbiAgICAgICAgbGVuZ3RoKz11bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihkZWJ1ZyB8fCBkZWJ1Z1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coZGVidWdTdHJpbmcpO1xuICAgIH1cbiAgICBwdXNoQWNjZXNVbml0KCk7XG4gIH1cblxuICBfaW5zZXJ0U2FtcGxlSW5PcmRlcihhcnIsIGRhdGEpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgaWYgKGRhdGEucHRzID49IGFycltsZW4tMV0ucHRzKVxuICAgICAge1xuICAgICAgICBhcnIucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICBpZiAoZGF0YS5wdHMgPCBhcnJbcG9zXS5wdHMpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIF9wYXJzZUFWQ05BTHUoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGgsIHZhbHVlLCBvdmVyZmxvdywgc3RhdGUgPSB0aGlzLmF2Y05hbHVTdGF0ZTtcbiAgICB2YXIgdW5pdHMgPSBbXSwgdW5pdCwgdW5pdFR5cGUsIGxhc3RVbml0U3RhcnQsIGxhc3RVbml0VHlwZTtcbiAgICAvL2xvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xuICAgICAgLy8gZmluZGluZyAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyAoMDAgMDAgMDEgT1IgMDAgMDAgMDAgMDEpXG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiggdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaWYoIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgICBpZiAobGFzdFVuaXRTdGFydCkge1xuICAgICAgICAgICAgICB1bml0ID0ge2RhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLCB0eXBlOiBsYXN0VW5pdFR5cGV9O1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgICAgIGxldCBsYXN0U3RhdGUgPSB0aGlzLmF2Y05hbHVTdGF0ZTtcbiAgICAgICAgICAgICAgaWYobGFzdFN0YXRlICYmICAoaSA8PSA0IC0gbGFzdFN0YXRlKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGxhc3RhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdFVuaXRzID0gbGFzdGF2Y1NhbXBsZS51bml0cy51bml0cyxcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdCA9IGxhc3RVbml0c1tsYXN0VW5pdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RhdmNTYW1wbGUudW5pdHMubGVuZ3RoIC09IGxhc3RTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2subGVuIC09IGxhc3RTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuICAgICAgICAgICAgICBvdmVyZmxvdyAgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdHMgPSBsYXN0YXZjU2FtcGxlLnVuaXRzLnVuaXRzLFxuICAgICAgICAgICAgICAgICAgICAgIGxhc3RVbml0ID0gbGFzdFVuaXRzW2xhc3RVbml0cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgICAgICAgbGFzdGF2Y1NhbXBsZS51bml0cy5sZW5ndGggKz0gb3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gb3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCkge1xuICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlIDogc3RhdGV9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgICAgdGhpcy5hdmNOYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICAgKi9cbiAgZGlzY2FyZEVQQihkYXRhKSB7XG4gICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgRVBCUG9zaXRpb25zID0gW10sXG4gICAgICAgIGkgPSAxLFxuICAgICAgICBuZXdMZW5ndGgsIG5ld0RhdGE7XG5cbiAgICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJlxuICAgICAgICAgIGRhdGFbaSArIDFdID09PSAwICYmXG4gICAgICAgICAgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgICAvLyBhcnJheVxuICAgIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICAgIG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gICAgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG5cbiAgX3BhcnNlQUFDUEVTKHBlcykge1xuICAgIHZhciB0cmFjayA9IHRoaXMuX2FhY1RyYWNrLFxuICAgICAgICBkYXRhID0gcGVzLmRhdGEsXG4gICAgICAgIHB0cyA9IHBlcy5wdHMsXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuYXVkaW9Db2RlYyxcbiAgICAgICAgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93LFxuICAgICAgICBhYWNMYXN0UFRTID0gdGhpcy5hYWNMYXN0UFRTLFxuICAgICAgICBjb25maWcsIGZyYW1lTGVuZ3RoLCBmcmFtZUR1cmF0aW9uLCBmcmFtZUluZGV4LCBvZmZzZXQsIGhlYWRlckxlbmd0aCwgc3RhbXAsIGxlbiwgYWFjU2FtcGxlO1xuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGFhY092ZXJGbG93LmJ5dGVMZW5ndGggKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgdG1wLnNldChhYWNPdmVyRmxvdywgMCk7XG4gICAgICB0bXAuc2V0KGRhdGEsIGFhY092ZXJGbG93LmJ5dGVMZW5ndGgpO1xuICAgICAgLy9sb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2FhY092ZXJGbG93LmJ5dGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICBkYXRhID0gdG1wO1xuICAgIH1cbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmIChkYXRhW29mZnNldCsxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHZhciByZWFzb24sIGZhdGFsO1xuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcbiAgICAgICAgcmVhc29uID0gYEFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDoke29mZnNldH1gO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYXRhbCwgcmVhc29uOiByZWFzb259KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5hdWRpb3NhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgIHRyYWNrLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30scmF0ZToke2NvbmZpZy5zYW1wbGVyYXRlfSxuYiBjaGFubmVsOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgICB9XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IDEwMjQgKiA5MDAwMCAvIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZTtcblxuICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgIGlmKGFhY092ZXJGbG93ICYmIGFhY0xhc3RQVFMpIHtcbiAgICAgIHZhciBuZXdQVFMgPSBhYWNMYXN0UFRTK2ZyYW1lRHVyYXRpb247XG4gICAgICBpZihNYXRoLmFicyhuZXdQVFMtcHRzKSA+IDEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSAke01hdGgucm91bmQoKG5ld1BUUy1wdHMpLzkwKX1gKTtcbiAgICAgICAgcHRzPW5ld1BUUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoKG9mZnNldCArIDUpIDwgbGVuKSB7XG4gICAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICAgIGhlYWRlckxlbmd0aCA9ICghIShkYXRhW29mZnNldCArIDFdICYgMHgwMSkgPyA3IDogOSk7XG4gICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgICBmcmFtZUxlbmd0aCA9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExKSB8XG4gICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgICAgICAgICAgICAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcbiAgICAgIGZyYW1lTGVuZ3RoICAtPSBoZWFkZXJMZW5ndGg7XG4gICAgICAvL3N0YW1wID0gcGVzLnB0cztcblxuICAgICAgaWYgKChmcmFtZUxlbmd0aCA+IDApICYmICgob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpIDw9IGxlbikpIHtcbiAgICAgICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgLy9sb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgICAgICBhYWNTYW1wbGUgPSB7dW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcH07XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XG4gICAgICAgIG9mZnNldCArPSBmcmFtZUxlbmd0aCArIGhlYWRlckxlbmd0aDtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgICBmb3IgKCA7IG9mZnNldCA8IChsZW4gLSAxKTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBsZW4pO1xuICAgICAgLy9sb2dnZXIubG9nKGBBQUM6IG92ZXJmbG93IGRldGVjdGVkOiR7bGVuLW9mZnNldH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gYWFjT3ZlckZsb3c7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XG4gIH1cblxuICBfcGFyc2VJRDNQRVMocGVzKSB7XG4gICAgdGhpcy5faWQzVHJhY2suc2FtcGxlcy5wdXNoKHBlcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVFNEZW11eGVyO1xuIiwiZXhwb3J0IGNvbnN0IEVycm9yVHlwZXMgPSB7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICBORVRXT1JLX0VSUk9SOiAnbmV0d29ya0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgTUVESUFfRVJST1I6ICdtZWRpYUVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xuICBPVEhFUl9FUlJPUjogJ290aGVyRXJyb3InXG59O1xuXG5leHBvcnQgY29uc3QgRXJyb3JEZXRhaWxzID0ge1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfRVJST1I6ICdtYW5pZmVzdExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX1RJTUVPVVQ6ICdtYW5pZmVzdExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIE1BTklGRVNUX1BBUlNJTkdfRVJST1I6ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3Qgd2l0aCBvbmx5IGluY29tcGF0aWJsZSBjb2RlY3MgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUjogJ21hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfRVJST1I6ICdsZXZlbExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX1RJTUVPVVQ6ICdsZXZlbExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBzd2l0Y2ggZXJyb3IgLSBkYXRhOiB7IGxldmVsIDogZmF1bHR5IGxldmVsIElkLCBldmVudCA6IGVycm9yIGRlc2NyaXB0aW9ufVxuICBMRVZFTF9TV0lUQ0hfRVJST1I6ICdsZXZlbFN3aXRjaEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjogJ2F1ZGlvVHJhY2tMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVDogJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEZSQUdfTE9BRF9FUlJPUjogJ2ZyYWdMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb29wIGxvYWRpbmcgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOiAnZnJhZ0xvb3BMb2FkaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9USU1FT1VUOiAnZnJhZ0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YTogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvblxuICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBwYXJzaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvblxuICBGUkFHX1BBUlNJTkdfRVJST1I6ICdmcmFnUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgS0VZX0xPQURfRVJST1I6ICdrZXlMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FEX1RJTUVPVVQ6ICdrZXlMb2FkVGltZU91dCcsXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgIGVyciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SOiAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5EX0VSUk9SOiAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORElOR19FUlJPUjogJ2J1ZmZlckFwcGVuZGluZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICBCVUZGRVJfU1RBTExFRF9FUlJPUjogJ2J1ZmZlclN0YWxsZWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgQlVGRkVSX0ZVTExfRVJST1I6ICdidWZmZXJGdWxsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxuICBCVUZGRVJfU0VFS19PVkVSX0hPTEU6ICdidWZmZXJTZWVrT3ZlckhvbGUnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nXG59O1xuIiwiLypcbipcbiogQWxsIG9iamVjdHMgaW4gdGhlIGV2ZW50IGhhbmRsaW5nIGNoYWluIHNob3VsZCBpbmhlcml0IGZyb20gdGhpcyBjbGFzc1xuKlxuKi9cblxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMnO1xuXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscywgLi4uZXZlbnRzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVkRXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMudXNlR2VuZXJpY0hhbmRsZXIgPSB0cnVlO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGlzRXZlbnRIYW5kbGVyKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5oYW5kbGVkRXZlbnRzID09PSAnb2JqZWN0JyAmJiB0aGlzLmhhbmRsZWRFdmVudHMubGVuZ3RoICYmIHR5cGVvZiB0aGlzLm9uRXZlbnQgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdobHNFdmVudEdlbmVyaWMnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JiaWRkZW4gZXZlbnQgbmFtZTogJyArIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy5vbihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmhscy5vZmYoZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBhcmd1bWVudHM6IGV2ZW50IChzdHJpbmcpLCBkYXRhIChhbnkpXG4gICAqL1xuICBvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XG4gIH1cblxuICBvbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSkge1xuICAgIHZhciBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gJ29uJyArIGV2ZW50LnJlcGxhY2UoJ2hscycsICcnKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCAke2V2ZW50fSBoYXMgbm8gZ2VuZXJpYyBoYW5kbGVyIGluIHRoaXMgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNsYXNzICh0cmllZCAke2Z1bmNOYW1lfSlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW2Z1bmNOYW1lXS5iaW5kKHRoaXMsIGRhdGEpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGV2ZW50VG9GdW5jdGlvbi5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKS5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIHByb2Nlc3NpbmcgJHtldmVudH06JHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogZmFsc2UsIGV2ZW50IDogZXZlbnQsIGVyciA6IGVycn0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEhhbmRsZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlyZWQgYmVmb3JlIE1lZGlhU291cmNlIGlzIGF0dGFjaGluZyB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyBtZWRpYSB9XG4gIE1FRElBX0FUVEFDSElORzogJ2hsc01lZGlhQXR0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0FUVEFDSEVEOiAnaGxzTWVkaWFBdHRhY2hlZCcsXG4gIC8vIGZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNIRUQ6ICdobHNNZWRpYURldGFjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXR0ZWRcbiAgQlVGRkVSX1JFU0VUOiAnaGxzQnVmZmVyUmVzZXQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XG4gIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgZGF0YTogeyB0cmFja3MgOiB0cmFja3N9XG4gIEJVRkZFUl9DUkVBVEVEOiAnaGxzQnVmZmVyQ3JlYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gIEJVRkZFUl9BUFBFTkRJTkc6ICdobHNCdWZmZXJBcHBlbmRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcgfVxuICBCVUZGRVJfQVBQRU5ERUQ6ICdobHNCdWZmZXJBcHBlbmRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhXG4gIEJVRkZFUl9FT1M6ICdobHNCdWZmZXJFb3MnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgc2hvdWxkIGJlIGZsdXNoZWQgLSBkYXRhIHtzdGFydE9mZnNldCwgZW5kT2Zmc2V0fVxuICBCVUZGRVJfRkxVU0hJTkc6ICdobHNCdWZmZXJGbHVzaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGhhcyBiZWVuIGZsdXNoZWRcbiAgQlVGRkVSX0ZMVVNIRUQ6ICdobHNCdWZmZXJGbHVzaGVkJyxcbiAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gIE1BTklGRVNUX0xPQURJTkc6ICdobHNNYW5pZmVzdExvYWRpbmcnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdICwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XG4gIE1BTklGRVNUX0xPQURFRDogJ2hsc01hbmlmZXN0TG9hZGVkJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSAsIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgTUFOSUZFU1RfUEFSU0VEOiAnaGxzTWFuaWZlc3RQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGxldmVsIFVSTCAgbGV2ZWwgOiBpZCBvZiBsZXZlbCBiZWluZyBsb2FkZWR9XG4gIExFVkVMX0xPQURJTkc6ICdobHNMZXZlbExvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIExFVkVMX0xPQURFRDogJ2hsc0xldmVsTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQuIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgTEVWRUxfVVBEQVRFRDogJ2hsc0xldmVsVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIFBUUyBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFmdGVyIHBhcnNpbmcgYSBmcmFnbWVudCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCwgZHJpZnQ6IFBUUyBkcmlmdCBvYnNlcnZlZCB3aGVuIHBhcnNpbmcgbGFzdCBmcmFnbWVudCB9XG4gIExFVkVMX1BUU19VUERBVEVEOiAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENIOiAnaGxzTGV2ZWxTd2l0Y2gnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIGRhdGE6IHsgYXVkaW9UcmFja3MgOiBhdWRpb1RyYWNrc31cbiAgQVVESU9fVFJBQ0tTX1VQREFURUQ6ICdobHNBdWRpb1RyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7ICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19TV0lUQ0g6ICdobHNBdWRpb1RyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogYXVkaW8gdHJhY2sgVVJMICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19MT0FESU5HOiAnaGxzQXVkaW9UcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBBVURJT19UUkFDS19MT0FERUQ6ICdobHNBdWRpb1RyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPQURJTkc6ICdobHNGcmFnTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZH19XG4gIEZSQUdfTE9BRF9QUk9HUkVTUzogJ2hsc0ZyYWdMb2FkUHJvZ3Jlc3MnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGFib3J0aW5nIGZvciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gLSBkYXRhOiB7ZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEOiAnaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGh9fVxuICBGUkFHX0xPQURFRDogJ2hsc0ZyYWdMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBsZXZlbCA6IGxldmVsSWQsIHNuIDogc2VxdWVuY2UgbnVtYmVyLCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudH1cbiAgRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVDogJ2hsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgc2VpIHRleHQgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsICwgbGV2ZWwgOiBsZXZlbElkLCBzbiA6IHNlcXVlbmNlIG51bWJlciwgc2FtcGxlcyA6IFsgc2VpIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfVVNFUkRBVEE6ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgLCBsZXZlbCA6IGxldmVsSWQsIHNuIDogc2VxdWVuY2UgbnVtYmVyLCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19NRVRBREFUQTogJ2hsc0ZyYWdQYXJzaW5nTWV0YWRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgRlJBR19QQVJTSU5HX0RBVEE6ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQ7IGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIH1cbiAgRlJBR19QQVJTRUQ6ICdobHNGcmFnUGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCByZW11eGVkIE1QNCBib3hlcyBoYXZlIGFsbCBiZWVuIGFwcGVuZGVkIGludG8gU291cmNlQnVmZmVyIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCB0cGFyc2VkLCB0YnVmZmVyZWQsIGxlbmd0aH0gfVxuICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0NIQU5HRUQ6ICdobHNGcmFnQ2hhbmdlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7Y3VyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lc31cbiAgRlBTX0RST1A6ICdobHNGcHNEcm9wJyxcbiAgLy90cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7bGV2ZWwsIGRyb3BwZWRsZXZlbH1cbiAgRlBTX0RST1BfTEVWRUxfQ0FQUElORzogJ2hsc0Zwc0Ryb3BMZXZlbENhcHBpbmcnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBlcnJvciBldmVudCAtIGRhdGE6IHsgdHlwZSA6IGVycm9yIHR5cGUsIGRldGFpbHMgOiBlcnJvciBkZXRhaWxzLCBmYXRhbCA6IGlmIHRydWUsIGhscy5qcyBjYW5ub3Qvd2lsbCBub3QgdHJ5IHRvIHJlY292ZXIsIGlmIGZhbHNlLCBobHMuanMgd2lsbCB0cnkgdG8gcmVjb3ZlcixvdGhlciBlcnJvciBzcGVjaWZpYyBkYXRhfVxuICBFUlJPUjogJ2hsc0Vycm9yJyxcbiAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGVcbiAgREVTVFJPWUlORzogJ2hsc0Rlc3Ryb3lpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FESU5HOiAnaGxzS2V5TG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGtleSBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aH19XG4gIEtFWV9MT0FERUQ6ICdobHNLZXlMb2FkZWQnLFxuICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YToge3ByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZX1cbiAgU1RSRUFNX1NUQVRFX1RSQU5TSVRJT046ICdobHNTdHJlYW1TdGF0ZVRyYW5zaXRpb24nXG59O1xuIiwiLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG5cbmNsYXNzIEFBQyB7XG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjaGFubmVsQ291bnQpIHtcbiAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUM7XG4iLCIvKipcbiAqIEJ1ZmZlciBIZWxwZXIgY2xhc3MsIHByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgYnVmZmVyIGxlbmd0aCByZXRyaWV2YWxcbiovXG5cblxuY2xhc3MgQnVmZmVySGVscGVyIHtcblxuICBzdGF0aWMgYnVmZmVySW5mbyhtZWRpYSwgcG9zLG1heEhvbGVEdXJhdGlvbikge1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdmFyIHZidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkLCBidWZmZXJlZCA9IFtdLGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcmVkLnB1c2goe3N0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLHBvcyxtYXhIb2xlRHVyYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge2xlbjogMCwgc3RhcnQ6IDAsIGVuZDogMCwgbmV4dFN0YXJ0IDogdW5kZWZpbmVkfSA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGJ1ZmZlcmVkSW5mbyhidWZmZXJlZCxwb3MsbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgdmFyIGJ1ZmZlcmVkMiA9IFtdLFxuICAgICAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxuICAgICAgICBidWZmZXJMZW4sYnVmZmVyU3RhcnQsIGJ1ZmZlckVuZCxidWZmZXJTdGFydE5leHQsaTtcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgLy8gY29uc2lkZXIgdGhhdCBob2xlcyBzbWFsbGVyIHRoYW4gbWF4SG9sZUR1cmF0aW9uIGFyZSBpcnJlbGV2YW50IGFuZCBidWlsZCBhbm90aGVyXG4gICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBidWYybGVuID0gYnVmZmVyZWQyLmxlbmd0aDtcbiAgICAgIGlmKGJ1ZjJsZW4pIHtcbiAgICAgICAgdmFyIGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcbiAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgaWYoKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCkgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgIGlmKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBidWZmZXJMZW4gPSAwLCBidWZmZXJTdGFydCA9IGJ1ZmZlckVuZCA9IHBvczsgaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0ID0gIGJ1ZmZlcmVkMltpXS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBidWZmZXJlZDJbaV0uZW5kO1xuICAgICAgLy9sb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPCBzdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydCA6IGJ1ZmZlclN0YXJ0TmV4dH07XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJIZWxwZXI7XG4iLCIvKipcbiAqIExldmVsIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4qL1xuXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgTGV2ZWxIZWxwZXIge1xuXG4gIHN0YXRpYyBtZXJnZURldGFpbHMob2xkRGV0YWlscyxuZXdEZXRhaWxzKSB7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgob2xkRGV0YWlscy5zdGFydFNOLG5ld0RldGFpbHMuc3RhcnRTTiktbmV3RGV0YWlscy5zdGFydFNOLFxuICAgICAgICBlbmQgPSBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLG5ld0RldGFpbHMuZW5kU04pLW5ld0RldGFpbHMuc3RhcnRTTixcbiAgICAgICAgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgIG9sZGZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICBuZXdmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgY2NPZmZzZXQgPTAsXG4gICAgICAgIFBUU0ZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgICBpZiAoIGVuZCA8IHN0YXJ0KSB7XG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgICBmb3IodmFyIGkgPSBzdGFydCA7IGkgPD0gZW5kIDsgaSsrKSB7XG4gICAgICB2YXIgb2xkRnJhZyA9IG9sZGZyYWdtZW50c1tkZWx0YStpXSxcbiAgICAgICAgICBuZXdGcmFnID0gbmV3ZnJhZ21lbnRzW2ldO1xuICAgICAgaWYgKG5ld0ZyYWcgJiYgb2xkRnJhZykge1xuICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgICBpZiAoIWlzTmFOKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihjY09mZnNldCkge1xuICAgICAgbG9nZ2VyLmxvZyhgZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50YCk7XG4gICAgICBmb3IoaSA9IDAgOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICBuZXdmcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG4gICAgaWYoUFRTRnJhZykge1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhuZXdEZXRhaWxzLFBUU0ZyYWcuc24sUFRTRnJhZy5zdGFydFBUUyxQVFNGcmFnLmVuZFBUUyxQVFNGcmFnLnN0YXJ0RFRTLFBUU0ZyYWcuZW5kRFRTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZGZyYWdtZW50cyByYW5nZVxuICAgICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgICBpZiAoZGVsdGEgPj0gMCAmJiBkZWx0YSA8IG9sZGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWRqdXN0IHN0YXJ0IGJ5IHNsaWRpbmcgb2Zmc2V0XG4gICAgICAgIHZhciBzbGlkaW5nID0gb2xkZnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcbiAgICAgICAgZm9yKGkgPSAwIDsgaSA8IG5ld2ZyYWdtZW50cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICBuZXdmcmFnbWVudHNbaV0uc3RhcnQgKz0gc2xpZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgaXQgbWVhbnMgd2UgaGF2ZSBmcmFnbWVudHMgb3ZlcmxhcHBpbmcgYmV0d2VlblxuICAgIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXG4gICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG9sZERldGFpbHMuUFRTS25vd247XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscyxzbixzdGFydFBUUyxlbmRQVFMsc3RhcnREVFMsZW5kRFRTKSB7XG4gICAgdmFyIGZyYWdJZHgsIGZyYWdtZW50cywgZnJhZywgaTtcbiAgICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICAgIGlmIChzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gICAgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnSWR4XTtcbiAgICBpZighaXNOYU4oZnJhZy5zdGFydFBUUykpIHtcbiAgICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgICAgbGV0IGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZy5zdGFydFBUUy1zdGFydFBUUyk7XG4gICAgICBpZiAoaXNOYU4oZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLGZyYWcuZGVsdGFQVFMpO1xuICAgICAgfVxuICAgICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUyxmcmFnLnN0YXJ0UFRTKTtcbiAgICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZy5lbmRQVFMpO1xuICAgICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUyxmcmFnLnN0YXJ0RFRTKTtcbiAgICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICAgIH1cblxuICAgIHZhciBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcblxuICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gICAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gICAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICAgIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICAgIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gICAgZm9yKGkgPSBmcmFnSWR4IDsgaSA+IDAgOyBpLS0pIHtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsaSxpLTEpO1xuICAgIH1cblxuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gICAgZm9yKGkgPSBmcmFnSWR4IDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxIDsgaSsrKSB7XG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVQVFMoZnJhZ21lbnRzLGksaSsxKTtcbiAgICB9XG4gICAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XG4gICAgLy9sb2dnZXIubG9nKGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgc3RhcnQvZW5kOiR7c3RhcnRQVFMudG9GaXhlZCgzKX0vJHtlbmRQVFMudG9GaXhlZCgzKX1gKTtcblxuICAgIHJldHVybiBkcmlmdDtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVQVFMoZnJhZ21lbnRzLGZyb21JZHgsIHRvSWR4KSB7XG4gICAgdmFyIGZyYWdGcm9tID0gZnJhZ21lbnRzW2Zyb21JZHhdLGZyYWdUbyA9IGZyYWdtZW50c1t0b0lkeF0sIGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUztcbiAgICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgIGlmKCFpc05hTihmcmFnVG9QVFMpKSB7XG4gICAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgICAgZnJhZ0Zyb20uZHVyYXRpb24gPSBmcmFnVG9QVFMtZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICAgIGlmKGZyYWdGcm9tLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnRnJvbS5zbn0sbGV2ZWwgJHtmcmFnRnJvbS5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgICAgaWYoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnVG8uc259LGxldmVsICR7ZnJhZ1RvLmxldmVsfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExldmVsSGVscGVyO1xuIiwiLyoqXG4gKiBITFMgaW50ZXJmYWNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCBGcmFnbWVudExvYWRlciBmcm9tICcuL2xvYWRlci9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IEFickNvbnRyb2xsZXIgZnJvbSAgICAnLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyJztcbmltcG9ydCBCdWZmZXJDb250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBMZXZlbENvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBUaW1lbGluZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQge2xvZ2dlciwgZW5hYmxlTG9nc30gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuLy9pbXBvcnQgRmV0Y2hMb2FkZXIgZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IEtleUxvYWRlciBmcm9tICcuL2xvYWRlci9rZXktbG9hZGVyJztcbmltcG9ydCBDdWVzIGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5cbmNsYXNzIEhscyB7XG5cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIC8vIHJlcGxhY2VkIHdpdGggYnJvd3NlcmlmeS12ZXJzaW9uaWZ5IHRyYW5zZm9ybVxuICAgIHJldHVybiAnX19WRVJTSU9OX18nO1xuICB9XG5cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAod2luZG93Lk1lZGlhU291cmNlICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnRzKCkge1xuICAgIHJldHVybiBFdmVudDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpIHtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzKCkge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcoKSB7XG4gICAgaWYoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgSGxzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgICAgICAgICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAgICAgICAgIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAgICAgICAgIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gICAgICAgICAgbWF4QnVmZmVySG9sZTogMC41LFxuICAgICAgICAgIG1heFNlZWtIb2xlOiAyLFxuICAgICAgICAgIHNlZWtIb2xlTnVkZ2VEdXJhdGlvbiA6IDAuMDEsXG4gICAgICAgICAgc3RhbGxlZEluQnVmZmVyZWROdWRnZVRocmVzaG9sZDogMTAsXG4gICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA6IDAuMixcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6MyxcbiAgICAgICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LFxuICAgICAgICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsXG4gICAgICAgICAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAgICAgICAgIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAgICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgICAgICAgICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgICAgICAgICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgICAgICAgICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgICAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgICAgICAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgICAgICAgICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICAgICAgICAgIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICAgICAgICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgICAgICAgZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkOiAzLFxuICAgICAgICAgIHN0YXJ0RnJhZ1ByZWZldGNoIDogZmFsc2UsXG4gICAgICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsXG4gICAgICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgICAgICAgICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLFxuICAgICAgICAgIGxvYWRlcjogWGhyTG9hZGVyLFxuICAgICAgICAgIC8vbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgICAgICAgICBmTG9hZGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgcExvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGFickNvbnRyb2xsZXIgOiBBYnJDb250cm9sbGVyLFxuICAgICAgICAgIGJ1ZmZlckNvbnRyb2xsZXIgOiBCdWZmZXJDb250cm9sbGVyLFxuICAgICAgICAgIGNhcExldmVsQ29udHJvbGxlciA6IENhcExldmVsQ29udHJvbGxlcixcbiAgICAgICAgICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXI6IFN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgYXVkaW9TdHJlYW1Db250cm9sbGVyIDogQXVkaW9TdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgIHRpbWVsaW5lQ29udHJvbGxlcjogVGltZWxpbmVDb250cm9sbGVyLFxuICAgICAgICAgIGN1ZUhhbmRsZXI6IEN1ZXMsXG4gICAgICAgICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsXG4gICAgICAgICAgZW5hYmxlTVAyVFBhc3NUaHJvdWdoIDogZmFsc2UsXG4gICAgICAgICAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsXG4gICAgICAgICAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgICAgICAgICBhYnJFd21hRmFzdExpdmU6IDUsXG4gICAgICAgICAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAgICAgICAgIGFickV3bWFGYXN0Vm9EOiA0LFxuICAgICAgICAgIGFickV3bWFTbG93Vm9EOiAxNSxcbiAgICAgICAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzXG4gICAgICAgICAgYWJyQmFuZFdpZHRoRmFjdG9yIDogMC44LFxuICAgICAgICAgIGFickJhbmRXaWR0aFVwRmFjdG9yIDogMC43XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIHN0YXRpYyBzZXQgRGVmYXVsdENvbmZpZyhkZWZhdWx0Q29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB2YXIgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xuXG4gICAgaWYgKChjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpICYmIChjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb25cXCd0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb24nKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgaWYgKHByb3AgaW4gY29uZmlnKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGNvbmZpZ1twcm9wXSA9IGRlZmF1bHRDb25maWdbcHJvcF07XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgICB9XG5cbiAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1Zyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xuICAgICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICAgIH07XG5cbiAgICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gb2JzZXJ2ZXIub24uYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy5vZmYgPSBvYnNlcnZlci5vZmYuYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy50cmlnZ2VyID0gb2JzZXJ2ZXIudHJpZ2dlci5iaW5kKG9ic2VydmVyKTtcbiAgICB0aGlzLnBsYXlsaXN0TG9hZGVyID0gbmV3IFBsYXlsaXN0TG9hZGVyKHRoaXMpO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIodGhpcyk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IGNvbmZpZy5zdHJlYW1Db250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyID0gbmV3IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IEF1ZGlvVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMua2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5ERVNUUk9ZSU5HKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5wbGF5bGlzdExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcHNDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICB0aGlzLm9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNISU5HLCB7bWVkaWE6IG1lZGlhfSk7XG4gIH1cblxuICBkZXRhY2hNZWRpYSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgbG9hZFNvdXJjZSh1cmwpIHtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7dXJsfWApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BRElORywge3VybDogdXJsfSk7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbj0tMSkge1xuICAgIGxvZ2dlci5sb2coJ3N0YXJ0TG9hZCcpO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICB9XG5cbiAgc3RvcExvYWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG5cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gYWxsIHF1YWxpdHkgbGV2ZWxzICoqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gIH1cblxuICAvKiogUmV0dXJuIGN1cnJlbnQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAqKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qIHNldCBxdWFsaXR5IGxldmVsIGltbWVkaWF0ZWx5ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqIFJldHVybiBuZXh0IHBsYXliYWNrIHF1YWxpdHkgbGV2ZWwgKHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBmcmFnbWVudCkgKiovXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBmb3IgbmV4dCBmcmFnbWVudCAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIGN1cnJlbnQvbGFzdCBsb2FkZWQgZnJhZ21lbnQgKiovXG4gIGdldCBsb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG5cbiAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgZm9yIGN1cnJlbnQvbmV4dCBsb2FkZWQgZnJhZ21lbnQgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKiBzZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAqKi9cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWw7XG4gIH1cblxuICAvKiogc2V0IGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAqKi9cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgZmlyc3RMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgKiovXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICB9XG5cbiAgLyoqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgKiovXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiBjaGVjayBpZiB3ZSBhcmUgaW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBtb2RlICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkKCkge1xuICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcbiAgfVxuXG4gIC8qIHJldHVybiBtYW51YWwgbGV2ZWwgKi9cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcztcbiAgfVxuXG4gIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cykgKiovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgcmV0dXJuIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjaztcbiAgfVxuXG4gIC8qKiBzZWxlY3QgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cyoqL1xuICBzZXQgYXVkaW9UcmFjayhhdWRpb1RyYWNrSWQpIHtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIbHM7XG4iLCIvLyBUaGlzIGlzIG1vc3RseSBmb3Igc3VwcG9ydCBvZiB0aGUgZXM2IG1vZHVsZSBleHBvcnRcbi8vIHN5bnRheCB3aXRoIHRoZSBiYWJlbCBjb21waWxlciwgaXQgbG9va3MgbGlrZSBpdCBkb2VzbnQgc3VwcG9ydFxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9obHMuanMnKS5kZWZhdWx0O1xuIiwiLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25GcmFnTG9hZGluZyhkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgZnJhZy5sb2FkZWQgPSAwO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBmcmFnbWVudCBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIGxvYWRlciAgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBmcmFnLmxvYWRlciA9IHR5cGVvZihjb25maWcuZkxvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5mTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuXG4gICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IGZyYWcudXJsLCBmcmFnIDogZnJhZywgcmVzcG9uc2VUeXBlIDogJ2FycmF5YnVmZmVyJywgcHJvZ3Jlc3NEYXRhIDogZmFsc2V9O1xuICAgIGxldCBzdGFydCA9IGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQsIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgIGlmICghaXNOYU4oc3RhcnQpICYmICFpc05hTihlbmQpKSB7XG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBlbmQ7XG4gICAgfVxuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5IDogMCAsIHJldHJ5RGVsYXkgOiAwLCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcbiAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzcyA6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvciA6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0IDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBvblByb2dyZXNzOiB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpfTtcbiAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kYXRhLCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURFRCwge3BheWxvYWQ6IHBheWxvYWQsIGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0c30pO1xuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gIH0gXG5cbiAgbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWd9KTtcbiAgfVxuXG4gIC8vIGRhdGEgd2lsbCBiZSB1c2VkIGZvciBwcm9ncmVzc2l2ZSBwYXJzaW5nXG4gIGxvYWRwcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBmcmFnLmxvYWRlZCA9IHN0YXRzLmxvYWRlZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywge2ZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0c30pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZyYWdtZW50TG9hZGVyO1xuIiwiLypcbiAqIERlY3J5cHQga2V5IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgS2V5TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LktFWV9MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgIHRoaXMuZGVjcnlwdHVybCA9IG51bGw7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGluZyhkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhLFxuICAgICAgICB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgICAgIC8vIGlmIHVyaSBpcyBkaWZmZXJlbnQgZnJvbSBwcmV2aW91cyBvbmUgb3IgaWYgZGVjcnlwdCBrZXkgbm90IHJldHJpZXZlZCB5ZXRcbiAgICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZToke3R5cGV9YCk7XG4gICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5sb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgICAgICB0aGlzLmRlY3J5cHR1cmwgPSB1cmk7XG4gICAgICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG5cbiAgICAgICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmwgOiB1cmksIGZyYWcgOiBmcmFnLCByZXNwb25zZVR5cGUgOiAnYXJyYXlidWZmZXInfTtcbiAgICAgICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSAsIHJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcbiAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XG4gICAgICAgIGZyYWcubG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgbG9hZGVkIHRoaXMga2V5LCByZXR1cm4gaXRcbiAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0gdGhpcy5kZWNyeXB0a2V5O1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHtmcmFnOiBmcmFnfSk7XG4gICAgICB9XG4gIH1cblxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7ZnJhZzogZnJhZ30pO1xuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gIH1cblxuICBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleUxvYWRlcjtcbiIsIi8qKlxuICogUGxheWxpc3QgTG9hZGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBVUkxIZWxwZXIgZnJvbSAnLi4vdXRpbHMvdXJsJztcbmltcG9ydCBBdHRyTGlzdCBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcpO1xuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbWFuaWZlc3QnfSk7XG4gIH1cblxuICBvbkxldmVsTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbGV2ZWwnLCBsZXZlbCA6IGRhdGEubGV2ZWwsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnYXVkaW9UcmFjaycsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgbG9hZCh1cmwsIGNvbnRleHQpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgICByZXRyeSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgcmV0cnlEZWxheSxcbiAgICAgICAgbWF4UmV0cnlEZWxheTtcbiAgICBpZihjb250ZXh0LnR5cGUgPT09ICdtYW5pZmVzdCcpIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVPdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVPdXQ7XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsZXQgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IHVybCkge1xuICAgICAgICBsb2dnZXIud2FybihgcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6JHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXIgID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBjb250ZXh0LmxvYWRlciA9IHR5cGVvZihjb25maWcucExvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5wTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgIGNvbnRleHQudXJsID0gdXJsO1xuICAgIGNvbnRleHQucmVzcG9uc2VUeXBlID0gJyc7XG5cbiAgICBsZXQgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogdGltZW91dCwgbWF4UmV0cnkgOiByZXRyeSAsIHJldHJ5RGVsYXkgOiByZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5IDogbWF4UmV0cnlEZWxheX07XG4gICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcbiAgfVxuXG4gIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgcmV0dXJuIFVSTEhlbHBlci5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCk7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIGxldCBsZXZlbHMgPSBbXSwgcmVzdWx0O1xuXG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbiAgICBjb25zdCByZSA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCl7XG4gICAgICBjb25zdCBsZXZlbCA9IHt9O1xuXG4gICAgICB2YXIgYXR0cnMgPSBsZXZlbC5hdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgbGV2ZWwudXJsID0gdGhpcy5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG5cbiAgICAgIHZhciByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgIGlmKHJlc29sdXRpb24pIHtcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcblxuICAgICAgdmFyIGNvZGVjcyA9IGF0dHJzLkNPREVDUztcbiAgICAgIGlmKGNvZGVjcykge1xuICAgICAgICBjb2RlY3MgPSBjb2RlY3Muc3BsaXQoJywnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IHRoaXMuYXZjMXRvYXZjb3RpKGNvZGVjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IGNvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbHM7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlKSB7XG4gICAgbGV0IHJlc3VsdCwgbWVkaWFzID0gW107XG5cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbSBpcyB5b3VyIGZyaWVuZFxuICAgIGNvbnN0IHJlID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG4gICAgd2hpbGUgKChyZXN1bHQgPSByZS5leGVjKHN0cmluZykpICE9IG51bGwpe1xuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcbiAgICAgIHZhciBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgaWYoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XG4gICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5mb3JjZWQgPSAoYXR0cnMuRk9SQ0VEID09PSAnWUVTJyk7XG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICBtZWRpYS51cmwgPSB0aGlzLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGlmKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgICBtZWRpYS5uYW1lID0gbWVkaWEubGFuZztcbiAgICAgICAgfVxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZWRpYXM7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gY3JlYXRlIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3IgYSBnaXZlbiBzZWdtZW50XG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3IgKHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgdWludDhWaWV3W2ldID0gKHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGdldCBhIGZyYWdtZW50J3MgZGVjcnlwdGlvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBwYXJzZWQgZW5jcnlwdGlvbiBrZXkgZGF0YVxuICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXG4gICAqIEBwYXJhbSBzZWdtZW50TnVtYmVyIC0gdGhlIGZyYWdtZW50J3Mgc2VnbWVudCBudW1iZXJcbiAgICogQHJldHVybnMgeyp9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAqL1xuICBmcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5IChsZXZlbGtleSwgc2VnbWVudE51bWJlcikge1xuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGxldmVsa2V5O1xuXG4gICAgaWYgKGxldmVsa2V5ICYmIGxldmVsa2V5Lm1ldGhvZCAmJiBsZXZlbGtleS51cmkgJiYgIWxldmVsa2V5Lml2KSB7XG4gICAgICBkZWNyeXB0ZGF0YSA9IHRoaXMuY2xvbmVPYmoobGV2ZWxrZXkpO1xuICAgICAgZGVjcnlwdGRhdGEuaXYgPSB0aGlzLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgfVxuXG4gIGF2YzF0b2F2Y290aShjb2RlYykge1xuICAgIHZhciByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29kZWM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjbG9uZU9iaihvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxuXG4gIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlKSB7XG4gICAgdmFyIGN1cnJlbnRTTiA9IDAsXG4gICAgICAgIGZyYWdkZWNyeXB0ZGF0YSxcbiAgICAgICAgdG90YWxkdXJhdGlvbiA9IDAsXG4gICAgICAgIGxldmVsID0ge3R5cGU6IG51bGwsIHZlcnNpb246IG51bGwsIHVybDogYmFzZXVybCwgZnJhZ21lbnRzOiBbXSwgbGl2ZTogdHJ1ZSwgc3RhcnRTTjogMH0sXG4gICAgICAgIGxldmVsa2V5ID0ge21ldGhvZCA6IG51bGwsIGtleSA6IG51bGwsIGl2IDogbnVsbCwgdXJpIDogbnVsbH0sXG4gICAgICAgIGNjID0gMCxcbiAgICAgICAgcHJvZ3JhbURhdGVUaW1lID0gbnVsbCxcbiAgICAgICAgZnJhZyA9IG51bGwsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgcmVnZXhwLFxuICAgICAgICBkdXJhdGlvbiA9IG51bGwsXG4gICAgICAgIHRpdGxlID0gbnVsbCxcbiAgICAgICAgYnl0ZVJhbmdlRW5kT2Zmc2V0ID0gbnVsbCxcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBudWxsLFxuICAgICAgICB0YWdMaXN0ID0gW107XG5cbiAgICByZWdleHAgPSAvKD86KD86IyhFWFRNM1UpKXwoPzojRVhULVgtKFBMQVlMSVNULVRZUEUpOiguKykpfCg/OiNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOihcXGQrKSl8KD86I0VYVC1YLShUQVJHRVREVVJBVElPTik6KFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVChJTkYpOihcXGQrKD86XFwuXFxkKyk/KSg/OiwoLiopKT8pfCg/Oig/ISMpKCkoXFxTLispKXwoPzojRVhULVgtKEJZVEVSQU5HRSk6KFxcZCsoPzpAXFxkKyg/OlxcLlxcZCspPyk/KXwoPzojRVhULVgtKEVORExJU1QpKXwoPzojRVhULVgtKERJUylDT05USU5VSVRZKSl8KD86I0VYVC1YLShQUk9HUkFNLURBVEUtVElNRSk6KC4rKSl8KD86I0VYVC1YLShWRVJTSU9OKTooXFxkKykpfCg/OigjKSguKik6KC4qKSl8KD86KCMpKC4qKSkpKD86LiopXFxyP1xcbj8vZztcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ2V4cC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuc2hpZnQoKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24obikgeyByZXR1cm4gKG4gIT09IHVuZGVmaW5lZCk7IH0pO1xuICAgICAgc3dpdGNoIChyZXN1bHRbMF0pIHtcbiAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgbGV2ZWwudHlwZSA9IHJlc3VsdFsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHJlc3VsdFsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IHBhcnNlRmxvYXQocmVzdWx0WzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHJlc3VsdFsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICBjYysrO1xuICAgICAgICAgIHRhZ0xpc3QucHVzaChyZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdCWVRFUkFOR0UnOlxuICAgICAgICAgIHZhciBwYXJhbXMgPSByZXN1bHRbMV0uc3BsaXQoJ0AnKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnl0ZVJhbmdlRW5kT2Zmc2V0ID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJTkYnOlxuICAgICAgICAgIGR1cmF0aW9uID0gcGFyc2VGbG9hdChyZXN1bHRbMV0pO1xuICAgICAgICAgIHRpdGxlID0gcmVzdWx0WzJdID8gcmVzdWx0WzJdIDogbnVsbDtcbiAgICAgICAgICB0YWdMaXN0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJzogLy8gdXJsXG4gICAgICAgICAgaWYgKCFpc05hTihkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgICAgZnJhZ2RlY3J5cHRkYXRhID0gdGhpcy5mcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5KGxldmVsa2V5LCBzbik7XG4gICAgICAgICAgICB2YXIgdXJsID0gcmVzdWx0WzFdID8gdGhpcy5yZXNvbHZlKHJlc3VsdFsxXSwgYmFzZXVybCkgOiBudWxsO1xuICAgICAgICAgICAgZnJhZyA9IHt1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc246IHNuLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICAgICAgZGVjcnlwdGRhdGEgOiBmcmFnZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW1EYXRlVGltZTogcHJvZ3JhbURhdGVUaW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0OiB0YWdMaXN0fTtcbiAgICAgICAgICAgIC8vIG9ubHkgaW5jbHVkZSBieXRlIHJhbmdlIG9wdGlvbnMgaWYgdXNlZC9uZWVkZWRcbiAgICAgICAgICAgIGlmKGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQgPSBieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC5mcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZHVyYXRpb247XG4gICAgICAgICAgICBkdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aXRsZSA9IG51bGw7XG4gICAgICAgICAgICBieXRlUmFuZ2VTdGFydE9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICBwcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICAgICAgdGFnTGlzdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgIHZhciBkZWNyeXB0cGFyYW1zID0gcmVzdWx0WzFdO1xuICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChkZWNyeXB0cGFyYW1zKTtcbiAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgICBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJLFxuICAgICAgICAgICAgICBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgIGxldmVsa2V5ID0geyBtZXRob2Q6IG51bGwsIGtleTogbnVsbCwgaXY6IG51bGwsIHVyaTogbnVsbCB9O1xuICAgICAgICAgICAgaWYgKChkZWNyeXB0dXJpKSAmJiAoZGVjcnlwdG1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xuICAgICAgICAgICAgICBsZXZlbGtleS5tZXRob2QgPSBkZWNyeXB0bWV0aG9kO1xuICAgICAgICAgICAgICAvLyBVUkkgdG8gZ2V0IHRoZSBrZXlcbiAgICAgICAgICAgICAgbGV2ZWxrZXkudXJpID0gdGhpcy5yZXNvbHZlKGRlY3J5cHR1cmksIGJhc2V1cmwpO1xuICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICBsZXQgc3RhcnRQYXJhbXMgPSByZXN1bHRbMV07XG4gICAgICAgICAgbGV0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRQYXJhbXMpO1xuICAgICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQpIHtcbiAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1BST0dSQU0tREFURS1USU1FJzpcbiAgICAgICAgICBwcm9ncmFtRGF0ZVRpbWUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKHJlc3VsdFsxXSkpO1xuICAgICAgICAgIHRhZ0xpc3QucHVzaChyZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICByZXN1bHQuc2hpZnQoKTtcbiAgICAgICAgICB0YWdMaXN0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy9sb2dnZXIubG9nKCdmb3VuZCAnICsgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCArICcgZnJhZ21lbnRzJyk7XG4gICAgaWYoZnJhZyAmJiAhZnJhZy51cmwpIHtcbiAgICAgIGxldmVsLmZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24tPWZyYWcuZHVyYXRpb247XG4gICAgfVxuICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xuICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgIGxldmVsLmVuZFNOID0gY3VycmVudFNOIC0gMTtcbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cblxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RyaW5nID0gcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgdXJsID0gcmVzcG9uc2UudXJsLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlLFxuICAgICAgICBpZCA9IGNvbnRleHQuaWQsXG4gICAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbCxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG5cbiAgICB0aGlzLmxvYWRlcnNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgLy8gcmVzcG9uc2VVUkwgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzIChpdCBpcyB1c2VkIHRvIGRldGVjdCBVUkwgcmVkaXJlY3Rpb24pXG4gICAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIGluaXRpYWwgVVJMXG4gICAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgICB9XG4gICAgc3RhdHMudGxvYWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvL3N0YXRzLm10aW1lID0gbmV3IERhdGUodGFyZ2V0LmdldFJlc3BvbnNlSGVhZGVyKCdMYXN0LU1vZGlmaWVkJykpO1xuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpID09PSAwKSB7XG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRJTkY6JykgPiAwKSB7XG4gICAgICAgIGxldCBpc0xldmVsID0gKHR5cGUgIT09ICdhdWRpb1RyYWNrJyksXG4gICAgICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLnBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIHVybCwgbGV2ZWwgfHwgaWQgfHwgMCwgaXNMZXZlbCA/ICdtYWluJyA6ICdhdWRpbycpO1xuICAgICAgICAgICAgbGV2ZWxEZXRhaWxzLnRsb2FkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWFuaWZlc3QnKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlcXVlc3QsIHN0cmVhbSBtYW5pZmVzdCAobm8gbWFzdGVyIHBsYXlsaXN0KSwgZmlyZSBtYW5pZmVzdCBsb2FkZWQgZXZlbnQgd2l0aCBsZXZlbCBkZXRhaWxzXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7bGV2ZWxzOiBbe3VybDogdXJsLCBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzfV0sIHVybDogdXJsLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChpc0xldmVsKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBsZXZlbDogbGV2ZWwgfHwgMCwgaWQ6IGlkIHx8IDAsIHN0YXRzOiBzdGF0c30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCwge2RldGFpbHM6IGxldmVsRGV0YWlscywgaWQ6IGlkLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxldmVscyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XG4gICAgICAgIC8vIG11bHRpIGxldmVsIHBsYXlsaXN0LCBwYXJzZSBsZXZlbCBpbmZvXG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGF1ZGlvdHJhY2tzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdBVURJTycpO1xuICAgICAgICAgIGlmIChhdWRpb3RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgICAgICAgbGV0IGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgYXVkaW90cmFja3MuZm9yRWFjaChhdWRpb1RyYWNrID0+IHtcbiAgICAgICAgICAgICAgaWYoIWF1ZGlvVHJhY2sudXJsKSB7XG4gICAgICAgICAgICAgICAgZW1iZWRkZWRBdWRpb0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrXG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkQXVkaW9Gb3VuZCA9PT0gZmFsc2UgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgICAgICAgYXVkaW90cmFja3MudW5zaGlmdCh7IHR5cGUgOiAnbWFpbicsIG5hbWUgOiAnbWFpbid9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7bGV2ZWxzOiBsZXZlbHMsIGF1ZGlvVHJhY2tzIDogYXVkaW90cmFja3MsIHVybDogdXJsLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ25vIEVYVE0zVSBkZWxpbWl0ZXInfSk7XG4gICAgfVxuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGRldGFpbHMsIGZhdGFsLGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIHN3aXRjaChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21hbmlmZXN0JzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGV2ZWwnOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXVkaW9UcmFjayc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGRldGFpbHMsIGZhdGFsOiBmYXRhbCwgdXJsOiBsb2FkZXIudXJsLCBsb2FkZXI6IGxvYWRlciwgcmVzcG9uc2U6IHJlc3BvbnNlLCBjb250ZXh0IDogY29udGV4dH0pO1xuICB9XG5cbiAgbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICB2YXIgZGV0YWlscywgZmF0YWwsIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIHN3aXRjaChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21hbmlmZXN0JzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZXZlbCc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGRldGFpbHMsIGZhdGFsOiBmYXRhbCwgdXJsOiBsb2FkZXIudXJsLCBsb2FkZXI6IGxvYWRlciwgY29udGV4dCA6IGNvbnRleHR9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5bGlzdExvYWRlcjtcbiIsIi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuKi9cblxuLy9pbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgbXZleDogW10sXG4gICAgICBtdmhkOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW1xuICAgICAgICAgIGkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMSksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgzKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgICAweDZmLCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgdmFyIGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLCAweDZmLCAweDc1LCAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG5cbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgICd2aWRlbyc6IHZpZGVvSGRscixcbiAgICAgICdhdWRpbyc6IGF1ZGlvSGRsclxuICAgIH07XG5cbiAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcblxuICAgIHZhciBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcblxuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG5cbiAgICBNUDQuU1RTWiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcblxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOy8vIGVudHJ5X2NvdW50XG5cbiAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsMTE1LDExMSwxMDldKTsgLy8gaXNvbVxuICAgIHZhciBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsMTE4LDk5LDQ5XSk7IC8vIGF2YzFcbiAgICB2YXIgbWlub3JWZXJzaW9uID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcblxuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG5cbiAgc3RhdGljIGJveCh0eXBlKSB7XG4gIHZhclxuICAgIHBheWxvYWQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgIHNpemUgPSA4LFxuICAgIGkgPSBwYXlsb2FkLmxlbmd0aCxcbiAgICBsZW4gPSBpLFxuICAgIHJlc3VsdDtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG5cbiAgc3RhdGljIG1kYXQoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+ICA4KSAmIDB4RkYsXG4gICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgIChkdXJhdGlvbiA+PiAyNCksXG4gICAgICAoZHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgIChkdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxuICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgMHg1NSwgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAgIDB4MDAsIDB4MDBcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgbWRpYSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH1cblxuICBzdGF0aWMgbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAyNCksXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMTYpICYgMHhGRixcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAgOCkgJiAweEZGLFxuICAgICAgc2VxdWVuY2VOdW1iZXIgJiAweEZGLCAvLyBzZXF1ZW5jZV9udW1iZXJcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIG1vb2Yoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICB9XG4vKipcbiAqIEBwYXJhbSB0cmFja3MuLi4gKG9wdGlvbmFsKSB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcbiAqL1xuICBzdGF0aWMgbW9vdih0cmFja3MpIHtcbiAgICB2YXJcbiAgICAgIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgICAgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmV4KHRyYWNrcykge1xuICAgIHZhclxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xuICB9XG5cbiAgc3RhdGljIG12aGQodGltZXNjYWxlLGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24qPXRpbWVzY2FsZTtcbiAgICB2YXJcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAgOCkgJiAweEZGLFxuICAgICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgICAgKGR1cmF0aW9uID4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4gIDgpICYgMHhGRixcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxuICAgICAgICAweDAxLCAweDAwLCAvLyAxLjAgdm9sdW1lXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgICBdKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHNkdHAodHJhY2spIHtcbiAgICB2YXJcbiAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxuICAgICAgZmxhZ3MsXG4gICAgICBpO1xuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSAoZmxhZ3MuZGVwZW5kc09uIDw8IDQpIHxcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyKSB8XG4gICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHN0YmwodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICB9XG5cbiAgc3RhdGljIGF2YzEodHJhY2spIHtcbiAgICB2YXIgc3BzID0gW10sIHBwcyA9IFtdLCBpLCBkYXRhLCBsZW47XG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgc3BzLnB1c2goKGxlbiAmIDB4RkYpKTtcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpOyAvLyBTUFNcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgcHBzLnB1c2goKGxlbiAmIDB4RkYpKTtcbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIHZhciBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMSwgICAvLyB2ZXJzaW9uXG4gICAgICAgICAgICBzcHNbM10sIC8vIHByb2ZpbGVcbiAgICAgICAgICAgIHNwc1s0XSwgLy8gcHJvZmlsZSBjb21wYXRcbiAgICAgICAgICAgIHNwc1s1XSwgLy8gbGV2ZWxcbiAgICAgICAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgICAgICAgICAgMHhFMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICAgICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW1xuICAgICAgICAgICAgdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICAgICAgXSkuY29uY2F0KHBwcykpKSwgLy8gXCJQUFNcIlxuICAgICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgLy9jb25zb2xlLmxvZygnYXZjYzonICsgSGV4LmhleER1bXAoYXZjYykpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICAgIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcbiAgICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICAgIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cbiAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gdmVydHJlc29sdXRpb25cbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcbiAgICAgICAgMHgxMixcbiAgICAgICAgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QywgLy9kYWlseW1vdGlvbi9obHMuanNcbiAgICAgICAgMHg3OSwgMHg2RCwgMHg2RiwgMHg3NCxcbiAgICAgICAgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRixcbiAgICAgICAgMHg2OCwgMHg2QywgMHg3MywgMHgyRSxcbiAgICAgICAgMHg2QSwgMHg3MywgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAgICAgMHgwMCwgMHgxOCwgICAvLyBkZXB0aCA9IDI0XG4gICAgICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgICAgIGF2Y2MsXG4gICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXSkpIC8vIGF2Z0JpdHJhdGVcbiAgICAgICAgICApO1xuICB9XG5cbiAgc3RhdGljIGVzZHModHJhY2spIHtcbiAgICB2YXIgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuXG4gICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MTcrY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4MDAsIDB4MDEsIC8vZXNfaWRcbiAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgICAweDA0LCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MGYrY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4NDAsIC8vY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgICAgMHgxNSwgLy8gc3RyZWFtX3R5cGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gIH1cblxuICBzdGF0aWMgbXA0YSh0cmFjaykge1xuICAgIHZhciBhdWRpb3NhbXBsZXJhdGUgPSB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxuICAgICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgICAgKGF1ZGlvc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXG4gICAgICBhdWRpb3NhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gIH1cblxuICBzdGF0aWMgc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGtoZCh0cmFjaykge1xuICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uKnRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDcsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgKGlkID4+IDI0KSAmIDB4RkYsXG4gICAgICAoaWQgPj4gMTYpICYgMHhGRixcbiAgICAgIChpZCA+PiA4KSAmIDB4RkYsXG4gICAgICBpZCAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgKGR1cmF0aW9uID4+IDI0KSxcbiAgICAgIChkdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGR1cmF0aW9uID4+ICA4KSAmIDB4RkYsXG4gICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGxheWVyXG4gICAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICB3aWR0aCAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwLCAvLyB3aWR0aFxuICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICBoZWlnaHQgJiAweEZGLFxuICAgICAgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgdHJhZih0cmFjayxiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKSxcbiAgICAgICAgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZixcbiAgICAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgICAgICAgICAgIChpZCA+PiAyNCksXG4gICAgICAgICAgICAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAoaWQgPj4gOCkgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAoaWQgJiAweEZGKSAvLyB0cmFja19JRFxuICAgICAgICAgICAgICAgXSkpLFxuICAgICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgPj4yNCksXG4gICAgICAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDBYRkYsXG4gICAgICAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMFhGRixcbiAgICAgICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKSAvLyBiYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgICAgICAgICAgICBdKSksXG4gICAgICAgICAgICAgICBNUDQudHJ1bih0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gdGZoZFxuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIHRmZHRcbiAgICAgICAgICAgICAgICAgICAgOCArICAvLyB0cmFmIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIG1maGRcbiAgICAgICAgICAgICAgICAgICAgOCArICAvLyBtb29mIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICA4KSwgIC8vIG1kYXQgaGVhZGVyXG4gICAgICAgICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcbiAgICovXG4gIHN0YXRpYyB0cmFrKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH1cblxuICBzdGF0aWMgdHJleCh0cmFjaykge1xuICAgIHZhciBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgIChpZCA+PiAyNCksXG4gICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAoaWQgPj4gOCkgJiAwWEZGLFxuICAgICAoaWQgJiAweEZGKSwgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICB2YXIgc2FtcGxlcz0gdHJhY2suc2FtcGxlcyB8fCBbXSxcbiAgICAgICAgbGVuID0gc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgIGFycmF5bGVuID0gMTIgKyAoMTYgKiBsZW4pLFxuICAgICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKSxcbiAgICAgICAgaSxzYW1wbGUsZHVyYXRpb24sc2l6ZSxmbGFncyxjdHM7XG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICBhcnJheS5zZXQoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDBmLCAweDAxLCAvLyBmbGFnc1xuICAgICAgKGxlbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgIChsZW4gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAobGVuID4+PiA4KSAmIDB4RkYsXG4gICAgICBsZW4gJiAweEZGLCAvLyBzYW1wbGVfY291bnRcbiAgICAgIChvZmZzZXQgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAob2Zmc2V0ID4+PiAxNikgJiAweEZGLFxuICAgICAgKG9mZnNldCA+Pj4gOCkgJiAweEZGLFxuICAgICAgb2Zmc2V0ICYgMHhGRiAvLyBkYXRhX29mZnNldFxuICAgIF0sMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW1xuICAgICAgICAoZHVyYXRpb24gPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIGR1cmF0aW9uICYgMHhGRiwgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIChzaXplID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoc2l6ZSA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKHNpemUgPj4+IDgpICYgMHhGRixcbiAgICAgICAgc2l6ZSAmIDB4RkYsIC8vIHNhbXBsZV9zaXplXG4gICAgICAgIChmbGFncy5pc0xlYWRpbmcgPDwgMikgfCBmbGFncy5kZXBlbmRzT24sXG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgNikgfFxuICAgICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQpIHxcbiAgICAgICAgICAoZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcbiAgICAgICAgICBmbGFncy5pc05vblN5bmMsXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweEYwIDw8IDgsXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgKGN0cyA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKGN0cyA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKGN0cyA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBjdHMgJiAweEZGIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwxMisxNippKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbml0U2VnbWVudCh0cmFja3MpIHtcbiAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgTVA0LmluaXQoKTtcbiAgICB9XG4gICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKSwgcmVzdWx0O1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1QNC5GVFlQLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KE1QNC5GVFlQKTtcbiAgICByZXN1bHQuc2V0KG1vdmllLCBNUDQuRlRZUC5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNDtcbiIsIi8qKlxuICogZk1QNCByZW11eGVyXG4qL1xuXG5cbmltcG9ydCBBQUMgZnJvbSAnLi4vaGVscGVyL2FhYyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IE1QNCBmcm9tICcuLi9yZW11eC9tcDQtZ2VuZXJhdG9yJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0ICcuLi91dGlscy9wb2x5ZmlsbCc7XG5cbmNsYXNzIE1QNFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgaWQsIGNvbmZpZykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuUEVTMk1QNFNDQUxFRkFDVE9SID0gNDtcbiAgICB0aGlzLlBFU19USU1FU0NBTEUgPSA5MDAwMDtcbiAgICB0aGlzLk1QNF9USU1FU0NBTEUgPSB0aGlzLlBFU19USU1FU0NBTEUgLyB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUjtcbiAgfVxuXG4gIGdldCBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbiAgaW5zZXJ0RGlzY29udGludWl0eSgpIHtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN3aXRjaExldmVsKCkge1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbXV4KGxldmVsLHNuLGF1ZGlvVHJhY2ssdmlkZW9UcmFjayxpZDNUcmFjayx0ZXh0VHJhY2ssdGltZU9mZnNldCwgY29udGlndW91cykge1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnNuID0gc247XG4gICAgLy8gZ2VuZXJhdGUgSW5pdCBTZWdtZW50IGlmIG5lZWRlZFxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssdmlkZW9UcmFjayx0aW1lT2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEFhY1B0cywgd2hpY2ggaXNcbiAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQUFDIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBhdWRpb1RyYWNrTGVuZ3RoO1xuICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpb0RhdGEuZW5kUFRTIC0gYXVkaW9EYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjayx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMsYXVkaW9UcmFja0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2aWRlb0RhdGE7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZpZGVvRGF0YSA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvRGF0YSAmJiBhdWRpb1RyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgdGhpcy5yZW11eEVtcHR5QXVkaW8oYXVkaW9UcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvL2xvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhJRDMoaWQzVHJhY2ssdGltZU9mZnNldCk7XG4gICAgfVxuICAgIC8vbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjayx0aW1lT2Zmc2V0KTtcbiAgICB9XG4gICAgLy9ub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQsIHsgaWQgOiB0aGlzLmlkICwgbGV2ZWwgOiB0aGlzLmxldmVsLCBzbiA6IHRoaXMuc259KTtcbiAgfVxuXG4gIGdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLFxuICAgICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcyxcbiAgICAgICAgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICB0cmFja3MgPSB7fSxcbiAgICAgICAgZGF0YSA9IHsgaWQgOiB0aGlzLmlkLCBsZXZlbCA6IHRoaXMubGV2ZWwsIHNuIDogdGhpcy5zbiwgdHJhY2tzIDogdHJhY2tzLCB1bmlxdWUgOiBmYWxzZSB9LFxuICAgICAgICBjb21wdXRlUFRTRFRTID0gKHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgIGluaXRQVFMsIGluaXREVFM7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICAvLyBNUDQgZHVyYXRpb24gKHRyYWNrIGR1cmF0aW9uIGluIHNlY29uZHMgbXVsdGlwbGllZCBieSB0aW1lc2NhbGUpIGlzIGNvZGVkIG9uIDMyIGJpdHNcbiAgICAgIC8vIHdlIGtub3cgdGhhdCBlYWNoIEFBQyBzYW1wbGUgY29udGFpbnMgMTAyNCBmcmFtZXMuLi4uXG4gICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBvdmVyZmxvd2luZyB0aGUgMzIgYml0IGNvdW50ZXIgZm9yIGxhcmdlIGR1cmF0aW9uLCB3ZSB1c2Ugc21hbGxlciB0aW1lc2NhbGUgKHRpbWVzY2FsZS9nY2QpXG4gICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW5zdXJlIHRoYXQgQUFDIHNhbXBsZSBkdXJhdGlvbiB3aWxsIHN0aWxsIGJlIGFuIGludGVnZXIgKHdpbGwgYmUgMTAyNC9nY2QpXG4gICAgICBpZiAoYXVkaW9UcmFjay50aW1lc2NhbGUgKiBhdWRpb1RyYWNrLmR1cmF0aW9uID4gTWF0aC5wb3coMiwgMzIpKSB7XG4gICAgICAgIGxldCBncmVhdGVzdENvbW1vbkRpdmlzb3IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZiAoICEgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYik7XG4gICAgICAgIH07XG4gICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUgLyBncmVhdGVzdENvbW1vbkRpdmlzb3IoYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUsMTAyNCk7XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nICgnYXVkaW8gbXA0IHRpbWVzY2FsZSA6JysgYXVkaW9UcmFjay50aW1lc2NhbGUpO1xuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXIgOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWMgOiAgYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgY2hhbm5lbENvdW50IDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTICsgRFRTIC4uLlxuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBwZXNUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IHRoaXMuTVA0X1RJTUVTQ0FMRTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyIDogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjIDogIHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50IDogTVA0LmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhIDoge1xuICAgICAgICAgIHdpZHRoIDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgOiB2aWRlb1RyYWNrLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsdmlkZW9TYW1wbGVzWzBdLnB0cyAtIHBlc1RpbWVTY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUyx2aWRlb1NhbXBsZXNbMF0uZHRzIC0gcGVzVGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxkYXRhKTtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGlkIDogdGhpcy5pZCwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJ30pO1xuICAgIH1cbiAgfVxuXG4gIHJlbXV4VmlkZW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpIHtcbiAgICB2YXIgb2Zmc2V0ID0gOCxcbiAgICAgICAgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICBwZXMybXA0U2NhbGVGYWN0b3IgPSB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUixcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgIG1kYXQsIG1vb2YsXG4gICAgICAgIGZpcnN0UFRTLCBmaXJzdERUUyxcbiAgICAgICAgbmV4dERUUyxcbiAgICAgICAgbGFzdFBUUywgbGFzdERUUyxcbiAgICAgICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcyxcbiAgICAgICAgb3V0cHV0U2FtcGxlcyA9IFtdO1xuXG4gIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcbiAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgbGV0IG5leHRBdmNEdHM7XG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcbiAgICAgIG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgIG5leHRBdmNEdHMgPSB0aW1lT2Zmc2V0KnBlc1RpbWVTY2FsZTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIGZpcnN0IERUUyBhbmQgbGFzdCBEVFMsIG5vcm1hbGl6ZSB0aGVtIGFnYWluc3QgcmVmZXJlbmNlIHZhbHVlXG4gICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcbiAgICBmaXJzdERUUyA9ICBNYXRoLm1heCh0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLmR0cyAtIHRoaXMuX2luaXREVFMsbmV4dEF2Y0R0cyksMCk7XG4gICAgZmlyc3RQVFMgPSAgTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpLDApO1xuXG4gICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgIGxldCBkZWx0YSA9IE1hdGgucm91bmQoKGZpcnN0RFRTIC0gbmV4dEF2Y0R0cykgLyA5MCk7XG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQVZDOiR7ZGVsdGF9IG1zIGhvbGUgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHsoLWRlbHRhKX0gbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgaG9sZS9nYXAgOiBzZXQgRFRTIHRvIG5leHQgZXhwZWN0ZWQgRFRTXG4gICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTICsgdGhpcy5faW5pdERUUztcbiAgICAgICAgLy8gb2Zmc2V0IFBUUyBhcyB3ZWxsLCBlbnN1cmUgdGhhdCBQVFMgaXMgc21hbGxlciBvciBlcXVhbCB0aGFuIG5ldyBEVFNcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChmaXJzdFBUUyAtIGRlbHRhLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTICsgdGhpcy5faW5pdERUUztcbiAgICAgICAgbG9nZ2VyLmxvZyhgVmlkZW8vUFRTL0RUUyBhZGp1c3RlZDogJHtmaXJzdFBUU30vJHtmaXJzdERUU30sZGVsdGE6JHtkZWx0YX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV4dERUUyA9IGZpcnN0RFRTO1xuXG4gICAgLy8gY29tcHV0ZSBsYXN0UFRTL2xhc3REVFNcbiAgICBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aC0xXTtcbiAgICBsYXN0RFRTID0gTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpICwwKTtcbiAgICBsYXN0UFRTID0gTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpICwwKTtcbiAgICBsYXN0UFRTID0gTWF0aC5tYXgobGFzdFBUUywgbGFzdERUUyk7XG5cbiAgICBsZXQgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvciwgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgaXNTYWZhcmkgPSB2ZW5kb3IgJiYgdmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJiB1c2VyQWdlbnQgJiYgIXVzZXJBZ2VudC5tYXRjaCgnQ3JpT1MnKTtcblxuICAgICAgLy8gb24gU2FmYXJpIGxldCdzIHNpZ25hbCB0aGUgc2FtZSBzYW1wbGUgZHVyYXRpb24gZm9yIGFsbCBzYW1wbGVzXG4gICAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMtZmlyc3REVFMpLyhwZXMybXA0U2NhbGVGYWN0b3IqKGlucHV0U2FtcGxlcy5sZW5ndGgtMSkpKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgYWxsIFBUUy9EVFMgbm93IC4uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgIC8vIHNhbXBsZSBEVFMgaXMgY29tcHV0ZWQgdXNpbmcgYSBjb25zdGFudCBkZWNvZGluZyBvZmZzZXQgKG1wNFNhbXBsZUR1cmF0aW9uKSBiZXR3ZWVuIHNhbXBsZXNcbiAgICAgICAgc2FtcGxlLmR0cyA9IGZpcnN0RFRTICsgaSpwZXMybXA0U2NhbGVGYWN0b3IqbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHRoaXMuX1BUU05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gdGhpcy5faW5pdERUUywgbmV4dEF2Y0R0cyksZmlyc3REVFMpO1xuICAgICAgICAvLyBlbnN1cmUgZHRzIGlzIGEgbXVsdGlwbGUgb2Ygc2NhbGUgZmFjdG9yIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlc1xuICAgICAgICBzYW1wbGUuZHRzID0gTWF0aC5yb3VuZChzYW1wbGUuZHRzL3BlczJtcDRTY2FsZUZhY3RvcikqcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgICAgLy8gd2Ugbm9ybWFsaXplIFBUUyBhZ2FpbnN0IG5leHRBdmNEdHMsIHdlIGFsc28gc3Vic3RyYWN0IGluaXREVFMgKHNvbWUgc3RyZWFtcyBkb24ndCBzdGFydCBAIFBUUyBPKVxuICAgICAgLy8gYW5kIHdlIGVuc3VyZSB0aGF0IGNvbXB1dGVkIHZhbHVlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiBzYW1wbGUgRFRTXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0RFRTLG5leHRBdmNEdHMpICwgc2FtcGxlLmR0cyk7XG4gICAgICAvLyBlbnN1cmUgcHRzIGlzIGEgbXVsdGlwbGUgb2Ygc2NhbGUgZmFjdG9yIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlc1xuICAgICAgc2FtcGxlLnB0cyA9IE1hdGgucm91bmQoc2FtcGxlLnB0cy9wZXMybXA0U2NhbGVGYWN0b3IpKnBlczJtcDRTY2FsZUZhY3RvcjtcbiAgICB9XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KHRyYWNrLmxlbiArICg0ICogdHJhY2submJOYWx1KSArIDgpO1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0LmJ5dGVMZW5ndGgpO1xuICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXZjU2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLFxuICAgICAgICAgIG1wNFNhbXBsZUxlbmd0aCA9IDAsXG4gICAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0O1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgd2hpbGUgKGF2Y1NhbXBsZS51bml0cy51bml0cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHVuaXQgPSBhdmNTYW1wbGUudW5pdHMudW5pdHMuc2hpZnQoKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0LmRhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYoIWlzU2FmYXJpKSB7XG4gICAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgICBpZiAoaSA8IGlucHV0U2FtcGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbaSsxXS5kdHMgLSBhdmNTYW1wbGUuZHRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgbGFzdEZyYW1lRHVyYXRpb24gPSBhdmNTYW1wbGUuZHRzIC0gaW5wdXRTYW1wbGVzW2kgPiAwID8gaS0xIDogaV0uZHRzO1xuICAgICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjaykge1xuICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIHRoZSBtaW5pbXVtIG9mIG1heEJ1ZmZlckhvbGUgYW5kXG4gICAgICAgICAgICAvLyBtYXhTZWVrSG9sZS4gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgICAgbGV0IG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSxcbiAgICAgICAgICAgICAgICBtYXhTZWVrSG9sZSA9IGNvbmZpZy5tYXhTZWVrSG9sZSxcbiAgICAgICAgICAgICAgICBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKE1hdGgubWluKG1heEJ1ZmZlckhvbGUsIG1heFNlZWtIb2xlKSAqIHBlc1RpbWVTY2FsZSksXG4gICAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiBwZXNUaW1lU2NhbGUgOiB0aGlzLm5leHRBYWNQdHMpIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUvbWF4U2Vla0hvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZC85MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbi85MH0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gLz0gcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cykgLyBwZXMybXA0U2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5tYXgoMCxtcDRTYW1wbGVEdXJhdGlvbipNYXRoLnJvdW5kKChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cykvKHBlczJtcDRTY2FsZUZhY3RvciptcDRTYW1wbGVEdXJhdGlvbikpKTtcbiAgICAgIH1cblxuXG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXZjU2FtcGxlLnB0c30vJHthdmNTYW1wbGUuZHRzfS8ke3RoaXMuX2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdmNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2goe1xuICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxuICAgICAgICBkdXJhdGlvbjogbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgIGN0czogY29tcG9zaXRpb25UaW1lT2Zmc2V0LFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgIGRlcGVuZHNPbiA6IGF2Y1NhbXBsZS5rZXkgPyAyIDogMSxcbiAgICAgICAgICBpc05vblN5bmMgOiBhdmNTYW1wbGUua2V5ID8gMCA6IDFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbipwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgbGV0IGRyb3BwZWQgPSB0cmFjay5kcm9wcGVkO1xuICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgdHJhY2submJOYWx1ID0gMDtcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICBpZihvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgbGV0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAvLyBjaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTIC8gcGVzMm1wNFNjYWxlRmFjdG9yLCB0cmFjayk7XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuXG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICBsZXZlbCA6IHRoaXMubGV2ZWwsXG4gICAgICBzbiA6IHRoaXMuc24sXG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgZW5kUFRTOiAobGFzdFBUUyArIHBlczJtcDRTY2FsZUZhY3RvciAqIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHBlc1RpbWVTY2FsZSxcbiAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgIGVuZERUUzogdGhpcy5uZXh0QXZjRHRzIC8gcGVzVGltZVNjYWxlLFxuICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQgOiBkcm9wcGVkXG4gICAgfTtcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cykge1xuICAgIGxldCBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgcGVzMm1wNFNjYWxlRmFjdG9yID0gcGVzVGltZVNjYWxlL21wNHRpbWVTY2FsZSxcbiAgICAgICAgZXhwZWN0ZWRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLnRpbWVzY2FsZSAqIDEwMjQgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgdmFyIHZpZXcsXG4gICAgICAgIG9mZnNldCA9IDgsXG4gICAgICAgIGFhY1NhbXBsZSwgbXA0U2FtcGxlLFxuICAgICAgICB1bml0LFxuICAgICAgICBtZGF0LCBtb29mLFxuICAgICAgICBmaXJzdFBUUywgZmlyc3REVFMsIGxhc3REVFMsXG4gICAgICAgIHB0cywgZHRzLCBwdHNub3JtLCBkdHNub3JtLFxuICAgICAgICBzYW1wbGVzID0gW10sXG4gICAgICAgIHNhbXBsZXMwID0gW10sXG4gICAgICAgIGZpbGxGcmFtZSwgbmV3U3RhbXA7XG5cbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cy1iLnB0cyk7XG4gICAgfSk7XG4gICAgc2FtcGxlczAgPSB0cmFjay5zYW1wbGVzO1xuXG4gICAgbGV0IG5leHRBYWNQdHMgPSAoY29udGlndW91cyA/IHRoaXMubmV4dEFhY1B0cyA6IHRpbWVPZmZzZXQqcGVzVGltZVNjYWxlKTtcblxuICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgIC8vIGZyYW1lLlxuICAgIGNvbnN0IHBlc0ZyYW1lRHVyYXRpb24gPSBleHBlY3RlZFNhbXBsZUR1cmF0aW9uICogcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgIGxldCBuZXh0UHRzTm9ybSA9IG5leHRBYWNQdHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzMC5sZW5ndGg7ICkge1xuICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICB2YXIgc2FtcGxlID0gc2FtcGxlczBbaV0sXG4gICAgICAgICAgcHRzTm9ybSA9IHRoaXMuX1BUU05vcm1hbGl6ZShzYW1wbGUucHRzIC0gdGhpcy5faW5pdERUUywgbmV4dEFhY1B0cyksXG4gICAgICAgICAgZGVsdGEgPSBwdHNOb3JtIC0gbmV4dFB0c05vcm07XG5cbiAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBoYWxmIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGVcbiAgICAgIGlmIChkZWx0YSA8ICgtMC41ICogcGVzRnJhbWVEdXJhdGlvbikpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgRHJvcHBpbmcgZnJhbWUgZHVlIHRvICR7TWF0aC5yb3VuZChNYXRoLmFicyhkZWx0YSAvIDkwKSl9IG1zIG92ZXJsYXAuYCk7XG4gICAgICAgIHNhbXBsZXMwLnNwbGljZShpLCAxKTtcbiAgICAgICAgdHJhY2subGVuIC09IHNhbXBsZS51bml0Lmxlbmd0aDtcbiAgICAgICAgLy8gRG9uJ3QgdG91Y2ggbmV4dFB0c05vcm0gb3IgaVxuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGF3YXkgZnJvbSB3aGVyZSB3ZSBzaG91bGQgYmUsIGluc2VydCBtaXNzaW5nIGZyYW1lc1xuICAgICAgZWxzZSBpZiAoZGVsdGEgPiAoMC41ICogcGVzRnJhbWVEdXJhdGlvbikpIHtcbiAgICAgICAgdmFyIG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgIGxvZ2dlci5sb2coYEluamVjdGluZyAke21pc3Npbmd9IGZyYW1lJHttaXNzaW5nID4gMSA/ICdzJyA6ICcnfSBvZiBtaXNzaW5nIGF1ZGlvIGR1ZSB0byAke01hdGgucm91bmQoZGVsdGEgLyA5MCl9IG1zIGdhcC5gKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICBuZXdTdGFtcCA9IHNhbXBsZS5wdHMgLSAobWlzc2luZyAtIGopICogcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICBuZXdTdGFtcCA9IE1hdGgubWF4KG5ld1N0YW1wLCB0aGlzLl9pbml0RFRTKTtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zbGljZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FtcGxlczAuc3BsaWNlKGksIDAsIHt1bml0OiBmaWxsRnJhbWUsIHB0czogbmV3U3RhbXAsIGR0czogbmV3U3RhbXB9KTtcbiAgICAgICAgICB0cmFjay5sZW4gKz0gZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3Qgc2FtcGxlIHRvIG5leHQgZXhwZWN0ZWQgcHRzXG4gICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGVzMFtpIC0gMV0ucHRzICsgcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgbmV4dFB0c05vcm0gPSB0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLnB0cyArIHBlc0ZyYW1lRHVyYXRpb24gLSB0aGlzLl9pbml0RFRTLCBuZXh0QWFjUHRzKTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSB3aXRoaW4gaGFsZiBhIGZyYW1lIGR1cmF0aW9uLCBzbyBqdXN0IGFkanVzdCBwdHNcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gKDAuMSAqIHBlc0ZyYW1lRHVyYXRpb24pKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQocHRzTm9ybSAtIG5leHRQdHNOb3JtICsgcGVzRnJhbWVEdXJhdGlvbil9IGF0IFBUUyAke01hdGgucm91bmQocHRzTm9ybSAvIDkwKX0gKHNob3VsZCBiZSAke01hdGgucm91bmQocGVzRnJhbWVEdXJhdGlvbil9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0UHRzTm9ybSArPSBwZXNGcmFtZUR1cmF0aW9uO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIHNhbXBsZS5wdHMgPSB0aGlzLl9pbml0RFRTICsgbmV4dEFhY1B0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlczBbaSAtIDFdLnB0cyArIHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChzYW1wbGVzMC5sZW5ndGgpIHtcbiAgICAgIGFhY1NhbXBsZSA9IHNhbXBsZXMwLnNoaWZ0KCk7XG4gICAgICB1bml0ID0gYWFjU2FtcGxlLnVuaXQ7XG4gICAgICBwdHMgPSBhYWNTYW1wbGUucHRzIC0gdGhpcy5faW5pdERUUztcbiAgICAgIGR0cyA9IGFhY1NhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTO1xuICAgICAgLy9sb2dnZXIubG9nKGBBdWRpby9QVFM6JHtNYXRoLnJvdW5kKHB0cy85MCl9YCk7XG4gICAgICAvLyBpZiBub3QgZmlyc3Qgc2FtcGxlXG4gICAgICBpZiAobGFzdERUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB0c25vcm0gPSB0aGlzLl9QVFNOb3JtYWxpemUocHRzLCBsYXN0RFRTKTtcbiAgICAgICAgZHRzbm9ybSA9IHRoaXMuX1BUU05vcm1hbGl6ZShkdHMsIGxhc3REVFMpO1xuICAgICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChkdHNub3JtIC0gbGFzdERUUykgLyBwZXMybXA0U2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHRzbm9ybSA9IHRoaXMuX1BUU05vcm1hbGl6ZShwdHMsIG5leHRBYWNQdHMpO1xuICAgICAgICBkdHNub3JtID0gdGhpcy5fUFRTTm9ybWFsaXplKGR0cywgbmV4dEFhY1B0cyk7XG4gICAgICAgIGxldCBkZWx0YSA9IE1hdGgucm91bmQoMTAwMCAqIChwdHNub3JtIC0gbmV4dEFhY1B0cykgLyBwZXNUaW1lU2NhbGUpLFxuICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IDA7XG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgICAgICBpZiAoY29udGlndW91cykge1xuICAgICAgICAgIC8vIGxvZyBkZWx0YVxuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gTWF0aC5yb3VuZCgocHRzbm9ybSAtIG5leHRBYWNQdHMpIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYCR7ZGVsdGF9IG1zIGhvbGUgYmV0d2VlbiBBQUMgc2FtcGxlcyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gbnVtTWlzc2luZ0ZyYW1lcyAqIGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBvdmVybGFwLCBvdmVybGFwcGluZyBmb3IgbW9yZSB0aGFuIGhhbGYgYSBmcmFtZSBkdXJhaW9uXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEyKSB7XG4gICAgICAgICAgICAgIC8vIGRyb3Agb3ZlcmxhcHBpbmcgYXVkaW8gZnJhbWVzLi4uIGJyb3dzZXIgd2lsbCBkZWFsIHdpdGggaXRcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgJHsoLWRlbHRhKX0gbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBBQUMgc2FtcGxlcyBkZXRlY3RlZCwgZHJvcCBmcmFtZWApO1xuICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICAgIHB0c25vcm0gPSBkdHNub3JtID0gbmV4dEFhY1B0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhYWNTYW1wbGVzLCBlbnN1cmUgdmFsdWUgaXMgcG9zaXRpdmVcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heCgwLCBwdHNub3JtKTtcbiAgICAgICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBkdHNub3JtKTtcbiAgICAgICAgaWYodHJhY2subGVuID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheSh0cmFjay5sZW4gKyA4KTtcbiAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0LmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcbiAgICAgICAgICBuZXdTdGFtcCA9IHB0c25vcm0gLSAobnVtTWlzc2luZ0ZyYW1lcyAtIGkpICogcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyB0aGlzIGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnNsaWNlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZGF0LnNldChmaWxsRnJhbWUsIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZpbGxGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIG1wNFNhbXBsZSA9IHtcbiAgICAgICAgICAgIHNpemU6IGZpbGxGcmFtZS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgY3RzOiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDEwMjQsXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgICAgZGVwZW5kc09uOiAxLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgLy9jb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2FhY1NhbXBsZS5wdHN9LyR7YWFjU2FtcGxlLmR0c30vJHt0aGlzLl9pbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYWFjU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICBzaXplOiB1bml0LmJ5dGVMZW5ndGgsXG4gICAgICAgIGN0czogMCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uOiAxLFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICBsYXN0RFRTID0gZHRzbm9ybTtcbiAgICB9XG4gICAgdmFyIGxhc3RTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmFyIG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgIC8vc2V0IGxhc3Qgc2FtcGxlIGR1cmF0aW9uIGFzIGJlaW5nIGlkZW50aWNhbCB0byBwcmV2aW91cyBzYW1wbGVcbiAgICBpZiAobmJTYW1wbGVzID49IDIpIHtcbiAgICAgIGxhc3RTYW1wbGVEdXJhdGlvbiA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMl0uZHVyYXRpb247XG4gICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgfVxuICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgIC8vIG5leHQgYWFjIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgICB0aGlzLm5leHRBYWNQdHMgPSBwdHNub3JtICsgcGVzMm1wNFNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgLy9sb2dnZXIubG9nKCdBdWRpby9QVFMvUFRTZW5kOicgKyBhYWNTYW1wbGUucHRzLnRvRml4ZWQoMCkgKyAnLycgKyB0aGlzLm5leHRBYWNEdHMudG9GaXhlZCgwKSk7XG4gICAgICB0cmFjay5sZW4gPSAwO1xuICAgICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMgLyBwZXMybXA0U2NhbGVGYWN0b3IsIHRyYWNrKTtcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgIGxldCBhdWRpb0RhdGEgPSB7XG4gICAgICAgIGlkIDogdGhpcy5pZCxcbiAgICAgICAgbGV2ZWwgOiB0aGlzLmxldmVsLFxuICAgICAgICBzbiA6IHRoaXMuc24sXG4gICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICBlbmRQVFM6IHRoaXMubmV4dEFhY1B0cyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICBlbmREVFM6IChkdHNub3JtICsgcGVzMm1wNFNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uKSAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgbmI6IG5iU2FtcGxlc1xuICAgICAgfTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgYXVkaW9EYXRhKTtcbiAgICAgIHJldHVybiBhdWRpb0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICBsZXQgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGUgPyB0cmFjay50aW1lc2NhbGUgOiB0cmFjay5hdWRpb3NhbXBsZXJhdGUsXG4gICAgICAgIHBlczJtcDRTY2FsZUZhY3RvciA9IHBlc1RpbWVTY2FsZS9tcDR0aW1lU2NhbGUsXG5cbiAgICAgICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXG4gICAgICAgIHN0YXJ0RFRTID0gdmlkZW9EYXRhLnN0YXJ0RFRTICogcGVzVGltZVNjYWxlICsgdGhpcy5faW5pdERUUyxcbiAgICAgICAgZW5kRFRTID0gdmlkZW9EYXRhLmVuZERUUyAqIHBlc1RpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsXG5cbiAgICAgICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gMTAyNCxcbiAgICAgICAgZnJhbWVEdXJhdGlvbiA9IHBlczJtcDRTY2FsZUZhY3RvciAqIHNhbXBsZUR1cmF0aW9uLFxuXG4gICAgICAgIC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cbiAgICAgICAgbmJTYW1wbGVzID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKSxcblxuICAgICAgICAvLyBzaWxlbnQgZnJhbWVcbiAgICAgICAgc2lsZW50RnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcblxuICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHNhbXBsZXMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIHZhciBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goe3VuaXQ6IHNpbGVudEZyYW1lLnNsaWNlKDApLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfSk7XG4gICAgICB0cmFjay5sZW4gKz0gc2lsZW50RnJhbWUubGVuZ3RoO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcblxuICAgIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cyk7XG4gIH1cblxuICByZW11eElEMyh0cmFjayx0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgaWYobGVuZ3RoKSB7XG4gICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gdGhpcy5faW5pdFBUUykgLyB0aGlzLlBFU19USU1FU0NBTEUpO1xuICAgICAgICBzYW1wbGUuZHRzID0gKChzYW1wbGUuZHRzIC0gdGhpcy5faW5pdERUUykgLyB0aGlzLlBFU19USU1FU0NBTEUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwge1xuICAgICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICAgIGxldmVsIDogdGhpcy5sZXZlbCxcbiAgICAgICAgc24gOiB0aGlzLnNuLFxuICAgICAgICBzYW1wbGVzOnRyYWNrLnNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgfVxuXG4gIHJlbXV4VGV4dCh0cmFjayx0aW1lT2Zmc2V0KSB7XG4gICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYS5wdHMtYi5wdHMpO1xuICAgIH0pO1xuXG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgaWYobGVuZ3RoKSB7XG4gICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIHRoaXMuX2luaXRQVFMpIC8gdGhpcy5QRVNfVElNRVNDQUxFKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHtcbiAgICAgICAgaWQgOiB0aGlzLmlkLFxuICAgICAgICBsZXZlbCA6IHRoaXMubGV2ZWwsXG4gICAgICAgIHNuIDogdGhpcy5zbixcbiAgICAgICAgc2FtcGxlczp0cmFjay5zYW1wbGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gIH1cblxuICBfUFRTTm9ybWFsaXplKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgICB2YXIgb2Zmc2V0O1xuICAgIGlmIChyZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAgIC8vIC0gMl4zM1xuICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICsgMl4zM1xuICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICB9XG4gICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNFJlbXV4ZXI7XG4iLCIvKipcbiAqIHBhc3N0aHJvdWdoIHJlbXV4ZXJcbiovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsaWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxuICBpbnNlcnREaXNjb250aW51aXR5KCkge1xuICB9XG5cbiAgc3dpdGNoTGV2ZWwoKSB7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgcmVtdXgoYXVkaW9UcmFjayx2aWRlb1RyYWNrLGlkM1RyYWNrLHRleHRUcmFjayx0aW1lT2Zmc2V0LHJhd0RhdGEpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIC8vIGdlbmVyYXRlIEluaXQgU2VnbWVudCBpZiBuZWVkZWRcbiAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIHZhciB0cmFja3MgPSB7fSxcbiAgICAgICAgICBkYXRhID0geyBpZCA6IHRoaXMuaWQsIHRyYWNrcyA6IHRyYWNrcywgdW5pcXVlIDogdHJ1ZSB9LFxuICAgICAgICAgIHRyYWNrID0gdmlkZW9UcmFjayxcbiAgICAgICAgICBjb2RlYyA9IHRyYWNrLmNvZGVjO1xuXG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgZGF0YS50cmFja3MudmlkZW8gPSB7XG4gICAgICAgICAgY29udGFpbmVyIDogdHJhY2suY29udGFpbmVyLFxuICAgICAgICAgIGNvZGVjIDogIGNvZGVjLFxuICAgICAgICAgIG1ldGFkYXRhIDoge1xuICAgICAgICAgICAgd2lkdGggOiB0cmFjay53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA6IHRyYWNrLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdHJhY2sgPSBhdWRpb1RyYWNrO1xuICAgICAgY29kZWMgPSB0cmFjay5jb2RlYztcbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBkYXRhLnRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgICBjb250YWluZXIgOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgY29kZWMgOiAgY29kZWMsXG4gICAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgICBjaGFubmVsQ291bnQgOiB0cmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxkYXRhKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwge1xuICAgICAgaWQgOiB0aGlzLmlkLFxuICAgICAgZGF0YTE6IHJhd0RhdGEsXG4gICAgICBzdGFydFBUUzogdGltZU9mZnNldCxcbiAgICAgIHN0YXJ0RFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgdHlwZTogJ2F1ZGlvdmlkZW8nLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkIDogMFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NUaHJvdWdoUmVtdXhlcjtcbiIsIlxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuY2xhc3MgQXR0ckxpc3Qge1xuXG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIGZvcih2YXIgYXR0ciBpbiBhdHRycyl7XG4gICAgICBpZihhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxKSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cblxuICBkZWNpbWFsRmxvYXRpbmdQb2ludChhdHRyTmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfVxuXG4gIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XG4gIH1cblxuICBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZSkge1xuICAgIGNvbnN0IHJlcyA9IC9eKFxcZCspeChcXGQrKSQvLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUF0dHJMaXN0KGlucHV0KSB7XG4gICAgY29uc3QgcmUgPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7XG4gICAgdmFyIG1hdGNoLCBhdHRycyA9IHt9O1xuICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdLCBxdW90ZSA9ICdcIic7XG5cbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxuICAgICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gKHZhbHVlLmxlbmd0aC0xKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBdHRyTGlzdDtcbiIsInZhciBCaW5hcnlTZWFyY2ggPSB7XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmlzb25GdW5jdGlvblxuICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBvYmplY3QgaWYgaXQgaXMgZm91bmQgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VhcmNoOiBmdW5jdGlvbihsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgXG4gICAgICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRnVuY3Rpb24oY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5U2VhcmNoO1xuIiwiLyoqXG4gKlxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gKlxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxuICpcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcbiAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcbiAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbiAgICAvKipcbiAgICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAgICAgKi9cblxudmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAgIDB4MmEgOiAweGUxLCAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gICAgMHg1YyA6IDB4ZTksIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVlIDogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAgIDB4NWYgOiAweGYzLCAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gICAgMHg2MCA6IDB4ZmEsIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgICAweDdiIDogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gICAgMHg3YyA6IDB4ZjcsIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAgIDB4N2QgOiAweGQxLCAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAgIDB4N2UgOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAgIDB4N2YgOiAweDI1ODgsIC8vIEZ1bGwgYmxvY2tcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAxNiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAgIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgICAweDgwIDogMHhhZSwgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gICAgMHg4MSA6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXG4gICAgMHg4MiA6IDB4YmQsIC8vIDEvMiBzeW1ib2xcbiAgICAweDgzIDogMHhiZiwgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgICAweDg0IDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgICAweDg1IDogMHhhMiwgLy8gQ2VudHMgc3ltYm9sXG4gICAgMHg4NiA6IDB4YTMsIC8vIFBvdW5kcyBzdGVybGluZ1xuICAgIDB4ODcgOiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxuICAgIDB4ODggOiAweGUwLCAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4OSA6IDB4MjAsIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAgIDB4OGEgOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4YiA6IDB4ZTIsIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGMgOiAweGVhLCAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhkIDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZSA6IDB4ZjQsIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGYgOiAweGZiLCAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4OTAgOiAweGMxLCAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgICAweDkxIDogMHhjOSwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gICAgMHg5MiA6IDB4ZDMsIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAgIDB4OTMgOiAweGRhLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgICAweDk0IDogMHhkYywgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gICAgMHg5NSA6IDB4ZmMsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAgIDB4OTYgOiAweDIwMTgsIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gICAgMHg5NyA6IDB4YTEsIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgICAweDk4IDogMHgyYSwgLy8gYXN0ZXJpc2tcbiAgICAweDk5IDogMHgyMDE5LCAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAgIDB4OWEgOiAweDI1MDEsIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gICAgMHg5YiA6IDB4YTksIC8vIGNvcHlyaWdodCBzaWduXG4gICAgMHg5YyA6IDB4MjEyMCwgLy8gU2VydmljZSBtYXJrXG4gICAgMHg5ZCA6IDB4MjAyMiwgLy8gKHJvdW5kKSBidWxsZXRcbiAgICAweDllIDogMHgyMDFjLCAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4OWYgOiAweDIwMWQsIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4YTAgOiAweGMwLCAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhMSA6IDB4YzIsIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gICAgMHhhMiA6IDB4YzcsIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAgIDB4YTMgOiAweGM4LCAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhNCA6IDB4Y2EsIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gICAgMHhhNSA6IDB4Y2IsIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTYgOiAweGViLCAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTcgOiAweGNlLCAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAgIDB4YTggOiAweGNmLCAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTkgOiAweGVmLCAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YWEgOiAweGQ0LCAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAgIDB4YWIgOiAweGQ5LCAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhYyA6IDB4ZjksIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgICAweGFkIDogMHhkYiwgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgICAweGFlIDogMHhhYiwgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweGFmIDogMHhiYiwgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgICAweGIwIDogMHhjMywgLy8gVXBwZXJjYXNlIEEsIHRpbGRlXG4gICAgMHhiMSA6IDB4ZTMsIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxuICAgIDB4YjIgOiAweGNkLCAvLyBVcHBlcmNhc2UgSSwgYWN1dGUgYWNjZW50XG4gICAgMHhiMyA6IDB4Y2MsIC8vIFVwcGVyY2FzZSBJLCBncmF2ZSBhY2NlbnRcbiAgICAweGI0IDogMHhlYywgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxuICAgIDB4YjUgOiAweGQyLCAvLyBVcHBlcmNhc2UgTywgZ3JhdmUgYWNjZW50XG4gICAgMHhiNiA6IDB4ZjIsIC8vIExvd2VyY2FzZSBvLCBncmF2ZSBhY2NlbnRcbiAgICAweGI3IDogMHhkNSwgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXG4gICAgMHhiOCA6IDB4ZjUsIC8vIExvd2VyY2FzZSBvLCB0aWxkZVxuICAgIDB4YjkgOiAweDdiLCAvLyBPcGVuIGN1cmx5IGJyYWNlXG4gICAgMHhiYSA6IDB4N2QsIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcbiAgICAweGJiIDogMHg1YywgLy8gQmFja3NsYXNoXG4gICAgMHhiYyA6IDB4NWUsIC8vIENhcmV0XG4gICAgMHhiZCA6IDB4NWYsIC8vIFVuZGVyc2NvcmVcbiAgICAweGJlIDogMHg3YywgLy8gUGlwZSAodmVydGljYWwgbGluZSlcbiAgICAweGJmIDogMHgyMjNjLCAvLyBUaWxkZSBvcGVyYXRvclxuICAgIDB4YzAgOiAweGM0LCAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XG4gICAgMHhjMSA6IDB4ZTQsIC8vIExvd2VyY2FzZSBBLCB1bWxhdXRcbiAgICAweGMyIDogMHhkNiwgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxuICAgIDB4YzMgOiAweGY2LCAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XG4gICAgMHhjNCA6IDB4ZGYsIC8vIEVzc3pldHQgKHNoYXJwIFMpXG4gICAgMHhjNSA6IDB4YTUsIC8vIFllbiBzeW1ib2xcbiAgICAweGM2IDogMHhhNCwgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXG4gICAgMHhjNyA6IDB4MjUwMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHZlcnRpY2FsXG4gICAgMHhjOCA6IDB4YzUsIC8vIFVwcGVyY2FzZSBBLCByaW5nXG4gICAgMHhjOSA6IDB4ZTUsIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gICAgMHhjYSA6IDB4ZDgsIC8vIFVwcGVyY2FzZSBPLCBzdHJva2VcbiAgICAweGNiIDogMHhmOCwgLy8gTG93ZXJjYXNlIG8sIHN0cm9rXG4gICAgMHhjYyA6IDB4MjUwZiwgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XG4gICAgMHhjZCA6IDB4MjUxMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIGxlZnRcbiAgICAweGNlIDogMHgyNTE3LCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIHJpZ2h0XG4gICAgMHhjZiA6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24oYnl0ZSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGJ5dGU7XG4gICAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5cbnZhciBOUl9ST1dTID0gMTUsXG4gICAgTlJfQ09MUyA9IDMyO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbnZhciByb3dzTG93Q2gxID0gezB4MTEgOiAxLCAweDEyIDogMywgMHgxNSA6IDUsIDB4MTYgOiA3LCAweDE3IDogOSwgMHgxMCA6IDExLCAweDEzIDogMTIsIDB4MTQgOiAxNH07XG52YXIgcm93c0hpZ2hDaDEgPSB7MHgxMSA6IDIsIDB4MTIgOiA0LCAweDE1IDogNiwgMHgxNiA6IDgsIDB4MTcgOiAxMCwgMHgxMyA6IDEzLCAweDE0IDogMTV9O1xudmFyIHJvd3NMb3dDaDIgPSB7MHgxOSA6IDEsIDB4MUEgOiAzLCAweDFEIDogNSwgMHgxRSA6IDcsIDB4MUYgOiA5LCAweDE4IDogMTEsIDB4MUIgOiAxMiwgMHgxQyA6IDE0fTtcbnZhciByb3dzSGlnaENoMiA9IHsweDE5IDogMiwgMHgxQSA6IDQsIDB4MUQgOiA2LCAweDFFIDogOCwgMHgxRiA6IDEwLCAweDFCIDogMTMsIDB4MUMgOiAxNX07XG5cbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG5cbi8qKlxuICogU2ltcGxlIGxvZ2dlciBjbGFzcyB0byBiZSBhYmxlIHRvIHdyaXRlIHdpdGggdGltZS1zdGFtcHMgYW5kIGZpbHRlciBvbiBsZXZlbC5cbiAqL1xudmFyIGxvZ2dlciA9IHtcbiAgICB2ZXJib3NlRmlsdGVyIDogeydEQVRBJyA6IDMsICdERUJVRycgOiAzLCAnSU5GTycgOiAyLCAnV0FSTklORycgOiAyLCAnVEVYVCcgOiAxLCAnRVJST1InIDogMH0sXG4gICAgdGltZSA6IG51bGwsXG4gICAgdmVyYm9zZUxldmVsIDogMCwgLy8gT25seSB3cml0ZSBlcnJvcnNcbiAgICBzZXRUaW1lIDogZnVuY3Rpb24obmV3VGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSBuZXdUaW1lO1xuICAgIH0sXG4gICAgbG9nIDogZnVuY3Rpb24oc2V2ZXJpdHksIG1zZykge1xuICAgICAgICB2YXIgbWluTGV2ZWwgPSB0aGlzLnZlcmJvc2VGaWx0ZXJbc2V2ZXJpdHldO1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGltZSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uKG51bUFycmF5KSB7XG4gICAgdmFyIGhleEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhBcnJheTtcbn07XG5cbmNsYXNzIFBlblN0YXRlIHtcblxuICAgIGNvbnN0cnVjdG9yKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZCB8fCAnd2hpdGUnO1xuICAgICAgICB0aGlzLnVuZGVybGluZSA9IHVuZGVybGluZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCAnYmxhY2snO1xuICAgICAgICB0aGlzLmZsYXNoID0gZmxhc2ggfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0U3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2gpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKCAodGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcykgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoKSApO1xuICAgIH1cblxuICAgIGNvcHkobmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgK1xuICAgICAgICAgICAgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2gpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXJcbntcblxuICAgIGNvbnN0cnVjdG9yKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSB1Y2hhciB8fCAnICc7IC8vIHVuaWNvZGUgY2hhcmFjdGVyXG4gICAgICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICAgIH1cblxuICAgIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgICB9XG5cbiAgICBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGNvcHkobmV3Q2hhcikge1xuICAgICAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBSb3cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTOyBpICsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cblxuICAgIGNvcHkob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAgICovXG4gICAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgICAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgICAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wb3MrMTsgaSA8IG5ld1BvcysxIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGJhY2tTcGFjZSgpIHtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9XG5cbiAgICBpbnNlcnRDaGFyKGJ5dGUpIHtcbiAgICAgICAgaWYgKGJ5dGUgPj0gMHg5MCkgeyAvL0V4dGVuZGVkIGNoYXJcbiAgICAgICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ0Nhbm5vdCBpbnNlcnQgJyArIGJ5dGUudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihjaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgICB9XG5cbiAgICBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0UG9zIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICAgIH1cblxuICAgIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICAgICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICAgIH1cblxuICAgIGdldFRleHRTdHJpbmcoKSB7XG4gICAgICAgIHZhciBjaGFycyA9IFtdO1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICAgICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICB2YXIgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICAgICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuKi9cbmNsYXNzIENhcHRpb25TY3JlZW4ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCAgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KCkpOyAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgICAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cblxuICAgIGNvcHkob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICBiYWNrU3BhY2UoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LmJhY2tTcGFjZSgpO1xuICAgIH1cblxuICAgIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICAgKi9cbiAgICBpbnNlcnRDaGFyKGNoYXIpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuaW5zZXJ0Q2hhcihjaGFyKTtcbiAgICB9XG5cbiAgICBzZXRQZW4oc3R5bGVzKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xuICAgIH1cblxuICAgIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcbiAgICB9XG5cbiAgICBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XG4gICAgfVxuXG4gICAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICAgICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXdSb3cgPSB0aGlzLm5yUm9sbFVwUm93cy0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgICAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50LTEsIDApO1xuICAgICAgICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmb3JlZ3JvdW5kIDogcGFjRGF0YS5jb2xvciwgdW5kZXJsaW5lIDogcGFjRGF0YS51bmRlcmxpbmUsIGl0YWxpY3MgOiBwYWNEYXRhLml0YWxpY3MsIGJhY2tncm91bmQgOiAnYmxhY2snLCBmbGFzaCA6IGZhbHNlfTtcbiAgICAgICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICovXG4gICAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG5cbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy9TcGFjZVxuICAgIH1cblxuICAgIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XG4gICAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICAgIH1cblxuICAgIHJvbGxVcCgpIHtcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcbiAgICAgICAgICAgIHJldHVybjsgLy9Ob3QgcHJvcGVybHkgc2V0dXBcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICAgICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgICB2YXIgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XG4gICAgICAgIHRvcFJvdy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSb2xsaW5nIHVwJyk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYWxsIG5vbi1lbXB0eSByb3dzIHdpdGggYXMgdW5pY29kZSB0ZXh0LlxuICAgICovXG4gICAgZ2V0RGlzcGxheVRleHQoYXNPbmVSb3cpIHtcbiAgICAgICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGRpc3BsYXlUZXh0ID0gW107XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciByb3dOciA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICAgICAgICAgIHJvd05yID0gaSsxO1xuICAgICAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgJzogXFwnJyArIHJvd1RleHQgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzO1xuICAgIH1cbn1cblxuLy92YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xuXG5jbGFzcyBDZWE2MDhDaGFubmVsXG57XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XG5cbiAgICAgICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MtMV07XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTLTFdO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q3VlRW5kVGltZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICAgIH1cblxuICAgIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gICAgfVxuXG4gICAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICB9XG5cbiAgICBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICAgICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB9XG5cbiAgICBpbnNlcnRDaGFycyhjaGFycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBjaGFycy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjY1JDTCgpIHsgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICAgIH1cblxuICAgIGNjQlMoKSB7IC8vIEJhY2tTcGFjZVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNjQU9GKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2NBT04oKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNjREVSKCkgeyAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NSVShuclJvd3MpIHsgLy9Sb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsnKSAtIFJvbGwgVXAnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgICB9XG5cbiAgICBjY0ZPTigpIHsgLy9GbGFzaCBPblxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0ZPTiAtIEZsYXNoIE9uJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtmbGFzaCA6IHRydWV9KTtcbiAgICB9XG5cbiAgICBjY1JEQygpIHsgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgICB9XG5cbiAgICBjY1RSKCkgeyAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RSJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gICAgfVxuXG4gICAgY2NSVEQoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JURCcpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH1cblxuICAgIGNjRURNKCkgeyAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBjY0NSKCkgeyAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICAgICAgbG9nZ2VyLmxvZygnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NFTk0oKSB7IC8vRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIH1cblxuICAgIGNjRU9DKCkgeyAvL0VuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNjVE8obnJDb2xzKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICAgIH1cblxuICAgIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHsgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmbGFzaCA6IGZhbHNlfTtcbiAgICAgICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgICAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUvMikgLSAweDEwO1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICBvdXRwdXREYXRhVXBkYXRlKCkge1xuICAgICAgICB2YXIgdCA9IGxvZ2dlci50aW1lO1xuICAgICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENlYTYwOFBhcnNlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7J3BhZGRpbmcnIDogMCwgJ2NoYXInIDogMCwgJ2NtZCcgOiAwLCAnb3RoZXInIDogMH07XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xuICAgIH1cblxuICAgIHNldEhhbmRsZXIoaW5kZXgsIG5ld0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAgICovXG4gICAgYWRkRGF0YSh0LCBieXRlTGlzdCkge1xuICAgICAgICB2YXIgY21kRm91bmQsIGEsIGIsXG4gICAgICAgIGNoYXJzRm91bmQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gdDtcbiAgICAgICAgbG9nZ2VyLnNldFRpbWUodCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYnl0ZUxpc3QubGVuZ3RoIDsgaSs9Mikge1xuICAgICAgICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgICAgICAgIGIgPSBieXRlTGlzdFtpKzFdICYgMHg3ZjtcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RBVEEnLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpKzFdXSkgKyddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnItMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jaGFyICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2krMV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICovXG4gICAgcGFyc2VDbWQoYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MkYpO1xuICAgICAgICB2YXIgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFGKSAmJiAoMHgyMSA8PSBiICYmIGIgPD0gMHgyMyk7XG4gICAgICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hOciA9IDI7IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG5cbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJCKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJDKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkUpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgcGFyc2VNaWRyb3coYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgaWYgKCAoKGEgPT09IDB4MTEpIHx8IChhID09PSAweDE5KSkgJiYgMHgyMCA8PSBiICYmIGIgPD0gMHgyZikge1xuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBjaE5yID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgIGNoTnIgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VyckNoTnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnItMV07XG4gICAgICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgKi9cbiAgICBwYXJzZVBBQyhhLCBiKSB7XG5cbiAgICAgICB2YXIgY2hOciA9IG51bGw7XG4gICAgICAgdmFyIHJvdyA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKCgweDExIDw9IGEgICYmIGEgPD0gMHgxNykgfHwgKDB4MTkgPD0gYSAmJiBhIDw9IDB4MUYpKSAmJiAoMHg0MCA8PSBiICYmIGIgPD0gMHg3Rik7XG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKTtcbiAgICAgICAgaWYgKCEgKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNoTnIgPSAoYSA8PSAweDE3KSA/IDEgOiAyO1xuXG4gICAgICAgIGlmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKSB7XG4gICAgICAgICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICAgICAgfSBlbHNlIHsgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY0RhdGEgPSB0aGlzLmludGVycHJldFBBQyhyb3csIGIpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRQQUMocGFjRGF0YSk7XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgaW50ZXJwcmV0UEFDKHJvdywgYnl0ZSkge1xuICAgICAgICB2YXIgcGFjSW5kZXggPSBieXRlO1xuICAgICAgICB2YXIgcGFjRGF0YSA9IHtjb2xvciA6IG51bGwsIGl0YWxpY3MgOiBmYWxzZSwgaW5kZW50IDogbnVsbCwgdW5kZXJsaW5lIDogZmFsc2UsIHJvdyA6IHJvd307XG5cbiAgICAgICAgaWYgKGJ5dGUgPiAweDVGKSB7XG4gICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICAgICAgfVxuICAgICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgICAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleC8yKV07XG4gICAgICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICAgICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleC0weDEwKS8yKSkqNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXJzZUNoYXJzKGEsIGIpIHtcblxuICAgICAgIHZhciAgY2hhbm5lbE5yID0gbnVsbCxcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IG51bGwsXG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBudWxsO1xuXG4gICAgICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGlmICgweDExIDw9IGNoYXJDb2RlMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBvbmVDb2RlID0gYjtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgICAgICB9IGVsc2UgaWYgKDB4MjAgPD0gYSAmJiBhIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IChiID09PSAwKSA/IFthXSA6IFthLCBiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICAgICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFyQ29kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAqL1xuICAgIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgICAgIHZhciAgYmtnRGF0YSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY2hOcixcbiAgICAgICAgICAgIGNoYW5uZWw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MmYpO1xuICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAoMHgyZCA8PWIgJiYgYiA8PSAweDJmKTtcbiAgICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYmtnRGF0YSA9IHt9O1xuICAgICAgICBpZiAoYSAgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiLTB4MjApLzIpO1xuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hOciA9IChhIDwgMHgxOCkgPyAxIDogMjtcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBmb3IgKHZhciBpPTAgOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wIDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0uY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlYTYwOFBhcnNlcjtcbiIsInZhciBDdWVzID0ge1xuXG4gIG5ld0N1ZTogZnVuY3Rpb24odHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgY2FwdGlvblNjcmVlbikge1xuICAgIHZhciByb3c7XG4gICAgdmFyIGN1ZTtcbiAgICB2YXIgaW5kZW50aW5nO1xuICAgIHZhciBpbmRlbnQ7XG4gICAgdmFyIHRleHQ7XG4gICAgdmFyIFZUVEN1ZSA9IHdpbmRvdy5WVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcblxuICAgIGZvciAodmFyIHI9MDsgcjxjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspXG4gICAge1xuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICB0ZXh0ID0gJyc7XG5cbiAgICAgIGlmICghcm93LmlzRW1wdHkoKSlcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgYz0wOyBjPHJvdy5jaGFycy5sZW5ndGg7IGMrKylcbiAgICAgICAge1xuICAgICAgICAgIGlmIChyb3cuY2hhcnNbY10udWNoYXIubWF0Y2goL1xccy8pICYmIGluZGVudGluZylcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0LnRyaW0oKSk7XG5cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNilcbiAgICAgICAge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVlRUQ3VlLmxpbmUgZ2V0J3MgZmxha2V5IHdoZW4gdXNpbmcgY29udHJvbHMsIHNvIGxldCdzIG5vdyBpbmNsdWRlIGxpbmUgMTMmMTRcbiAgICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykpXG4gICAgICAgIHtcbiAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGN1ZS5saW5lID0gKHIgPiA3ID8gciAtIDIgOiByICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICBjdWUucG9zaXRpb24gPSAxMDAgKiAoaW5kZW50IC8gMzIpICsgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSA/IDUwIDogMCk7XG4gICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1ZXM7XG4iLCIvKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuXG4gLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IoaGFsZkxpZmUpIHtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IDA7XG4gIH1cblxuICBzYW1wbGUod2VpZ2h0LHZhbHVlKSB7XG4gICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH1cblxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVXTUE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5cbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8vbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuXG5mdW5jdGlvbiBmb3JtYXRNc2codHlwZSwgbXNnKSB7XG4gIG1zZyA9ICdbJyArICB0eXBlICsgJ10gPiAnICsgbXNnO1xuICByZXR1cm4gbXNnO1xufVxuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XG4gIGNvbnN0IGZ1bmMgPSB3aW5kb3cuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgaWYoYXJnc1swXSkge1xuICAgICAgICBhcmdzWzBdID0gZm9ybWF0TXNnKHR5cGUsIGFyZ3NbMF0pO1xuICAgICAgfVxuICAgICAgZnVuYy5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBlbmFibGVMb2dzID0gZnVuY3Rpb24oZGVidWdDb25maWcpIHtcbiAgaWYgKGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsXG4gICAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgICAgLy8ndHJhY2UnLFxuICAgICAgJ2RlYnVnJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3dhcm4nLFxuICAgICAgJ2Vycm9yJ1xuICAgICk7XG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIHRyeSB7XG4gICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuIiwiaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIUFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSkge1xuICBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcyk7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSB0aGF0Lmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihlbmQgLSBzdGFydCk7XG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRBcnJheVtpXSA9IHRoYXRbaSArIHN0YXJ0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAhVWludDhBcnJheS5wcm90b3R5cGUuY29uY2F0KSB7XG4gIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICguLi5hcnJheXMpIHtcbiAgICBsZXQgdGhhdCA9IHRoaXM7XG4gICAgbGV0IHRvdGFsTGVuZ3RoID0gdGhhdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgYXJyIG9mIGFycmF5cykge1xuICAgICAgdG90YWxMZW5ndGggKz0gYXJyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgcmVzdWx0LnNldCh0aGF0LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB0aGF0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgICByZXN1bHQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhcnIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbiIsIi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbmNsYXNzIFRpbWVSYW5nZXMge1xuICBzdGF0aWMgdG9TdHJpbmcocikge1xuICAgIHZhciBsb2cgPSAnJywgbGVuID0gci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKSArICcsJyArIHIuZW5kKGkpICsgJ10nO1xuICAgIH1cbiAgICByZXR1cm4gbG9nO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVSYW5nZXM7XG4iLCJ2YXIgVVJMSGVscGVyID0ge1xuICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBVUkwgZnJvbSBhIHJlbGF0aXZlIG9uZSB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZVVSTFxuICAvLyBpZiByZWxhdGl2ZVVSTCBpcyBhbiBhYnNvbHV0ZSBVUkwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpcy5cbiAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24oYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuICAgIGlmICgvXlthLXpdKzovaS50ZXN0KHJlbGF0aXZlVVJMKSkge1xuICAgICAgLy8gY29tcGxldGUgdXJsLCBub3QgcmVsYXRpdmVcbiAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICB9XG5cbiAgICB2YXIgcmVsYXRpdmVVUkxRdWVyeSA9IG51bGw7XG4gICAgdmFyIHJlbGF0aXZlVVJMSGFzaCA9IG51bGw7XG5cbiAgICB2YXIgcmVsYXRpdmVVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhyZWxhdGl2ZVVSTCk7XG4gICAgaWYgKHJlbGF0aXZlVVJMSGFzaFNwbGl0KSB7XG4gICAgICByZWxhdGl2ZVVSTEhhc2ggPSByZWxhdGl2ZVVSTEhhc2hTcGxpdFsyXTtcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkxIYXNoU3BsaXRbMV07XG4gICAgfVxuICAgIHZhciByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXQgPSAvXihbXlxcP10qKSguKikkLy5leGVjKHJlbGF0aXZlVVJMKTtcbiAgICBpZiAocmVsYXRpdmVVUkxRdWVyeVNwbGl0KSB7XG4gICAgICByZWxhdGl2ZVVSTFF1ZXJ5ID0gcmVsYXRpdmVVUkxRdWVyeVNwbGl0WzJdO1xuICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXRbMV07XG4gICAgfVxuXG4gICAgdmFyIGJhc2VVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhiYXNlVVJMKTtcbiAgICBpZiAoYmFzZVVSTEhhc2hTcGxpdCkge1xuICAgICAgYmFzZVVSTCA9IGJhc2VVUkxIYXNoU3BsaXRbMV07XG4gICAgfVxuICAgIHZhciBiYXNlVVJMUXVlcnlTcGxpdCA9IC9eKFteXFw/XSopKC4qKSQvLmV4ZWMoYmFzZVVSTCk7XG4gICAgaWYgKGJhc2VVUkxRdWVyeVNwbGl0KSB7XG4gICAgICBiYXNlVVJMID0gYmFzZVVSTFF1ZXJ5U3BsaXRbMV07XG4gICAgfVxuXG4gICAgdmFyIGJhc2VVUkxEb21haW5TcGxpdCA9IC9eKChbYS16XSs6KT9cXC9cXC9bYS16MC05XFwuXFwtX35dKyg6WzAtOV0rKT8pPyhcXC8uKikkL2kuZXhlYyhiYXNlVVJMKTtcbiAgICBpZiAoIWJhc2VVUkxEb21haW5TcGxpdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIGUuZy4gJ2h0dHA6JywgJ2h0dHBzOicsICcnXG4gICAgdmFyIGJhc2VVUkxQcm90b2NvbCA9IGJhc2VVUkxEb21haW5TcGxpdFsyXSB8fCAnJztcbiAgICAvLyBlLmcuICdodHRwOi8vZXhhbXBsZS5jb20nLCAnLy9leGFtcGxlLmNvbScsICcnXG4gICAgdmFyIGJhc2VVUkxQcm90b2NvbERvbWFpbiA9IGJhc2VVUkxEb21haW5TcGxpdFsxXSB8fCAnJztcbiAgICAvLyBlLmcuICcvYS9iL2MvcGxheWxpc3QubTN1OCdcbiAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlVVJMRG9tYWluU3BsaXRbNF07XG5cbiAgICB2YXIgYnVpbHRVUkwgPSBudWxsO1xuICAgIGlmICgvXlxcL1xcLy8udGVzdChyZWxhdGl2ZVVSTCkpIHtcbiAgICAgIC8vIHJlbGF0aXZlIHVybCBzdGFydHMgd3RoICcvLycgc28gY29weSBwcm90b2NvbCAod2hpY2ggbWF5IGJlICcnIGlmIGJhc2VVcmwgZGlkbid0IHByb3ZpZGUgb25lKVxuICAgICAgYnVpbHRVUkwgPSBiYXNlVVJMUHJvdG9jb2wrJy8vJytVUkxIZWxwZXIuYnVpbGRBYnNvbHV0ZVBhdGgoJycsIHJlbGF0aXZlVVJMLnN1YnN0cmluZygyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFwvLy50ZXN0KHJlbGF0aXZlVVJMKSkge1xuICAgICAgLy8gcmVsYXRpdmUgdXJsIHN0YXJ0cyB3aXRoICcvJyBzbyBzdGFydCBmcm9tIHJvb3Qgb2YgZG9tYWluXG4gICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbERvbWFpbisnLycrVVJMSGVscGVyLmJ1aWxkQWJzb2x1dGVQYXRoKCcnLCByZWxhdGl2ZVVSTC5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJ1aWx0VVJMID0gVVJMSGVscGVyLmJ1aWxkQWJzb2x1dGVQYXRoKGJhc2VVUkxQcm90b2NvbERvbWFpbitiYXNlVVJMUGF0aCwgcmVsYXRpdmVVUkwpO1xuICAgIH1cblxuICAgIC8vIHB1dCB0aGUgcXVlcnkgYW5kIGhhc2ggcGFydHMgYmFja1xuICAgIGlmIChyZWxhdGl2ZVVSTFF1ZXJ5KSB7XG4gICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTFF1ZXJ5O1xuICAgIH1cbiAgICBpZiAocmVsYXRpdmVVUkxIYXNoKSB7XG4gICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTEhhc2g7XG4gICAgfVxuICAgIHJldHVybiBidWlsdFVSTDtcbiAgfSxcblxuICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBwYXRoIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlUGF0aFxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2RvY3VtZW50L2Nvb2tpZSNVc2luZ19yZWxhdGl2ZV9VUkxzX2luX3RoZV9wYXRoX3BhcmFtZXRlclxuICAvLyB0aGlzIGRvZXMgbm90IGhhbmRsZSB0aGUgY2FzZSB3aGVyZSByZWxhdGl2ZVBhdGggaXMgXCIvXCIgb3IgXCIvL1wiLiBUaGVzZSBjYXNlcyBzaG91bGQgYmUgaGFuZGxlZCBvdXRzaWRlIHRoaXMuXG4gIGJ1aWxkQWJzb2x1dGVQYXRoOiBmdW5jdGlvbihiYXNlUGF0aCwgcmVsYXRpdmVQYXRoKSB7XG4gICAgdmFyIHNSZWxQYXRoID0gcmVsYXRpdmVQYXRoO1xuICAgIHZhciBuVXBMbiwgc0RpciA9ICcnLCBzUGF0aCA9IGJhc2VQYXRoLnJlcGxhY2UoL1teXFwvXSokLywgc1JlbFBhdGgucmVwbGFjZSgvKFxcL3xeKSg/OlxcLj9cXC8rKSsvZywgJyQxJykpO1xuICAgIGZvciAodmFyIG5FbmQsIG5TdGFydCA9IDA7IG5FbmQgPSBzUGF0aC5pbmRleE9mKCcvLi4vJywgblN0YXJ0KSwgbkVuZCA+IC0xOyBuU3RhcnQgPSBuRW5kICsgblVwTG4pIHtcbiAgICAgIG5VcExuID0gL15cXC8oPzpcXC5cXC5cXC8pKi8uZXhlYyhzUGF0aC5zbGljZShuRW5kKSlbMF0ubGVuZ3RoO1xuICAgICAgc0RpciA9IChzRGlyICsgc1BhdGguc3Vic3RyaW5nKG5TdGFydCwgbkVuZCkpLnJlcGxhY2UobmV3IFJlZ0V4cCgnKD86XFxcXFxcLytbXlxcXFxcXC9dKil7MCwnICsgKChuVXBMbiAtIDEpIC8gMykgKyAnfSQnKSwgJy8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNEaXIgKyBzUGF0aC5zdWJzdHIoblN0YXJ0KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVUkxIZWxwZXI7XG4iLCIvKipcbiAqIFhIUiBiYXNlZCBsb2dnZXJcbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBYaHJMb2FkZXIge1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLnhoclNldHVwKSB7XG4gICAgICB0aGlzLnhoclNldHVwID0gY29uZmlnLnhoclNldHVwO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyICYmIGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gbnVsbDtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG51bGw7XG4gIH1cblxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnN0YXRzID0ge3RyZXF1ZXN0OiBwZXJmb3JtYW5jZS5ub3coKSwgcmV0cnk6IDB9O1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5O1xuICAgIHRoaXMubG9hZEludGVybmFsKCk7XG4gIH1cblxuICBsb2FkSW50ZXJuYWwoKSB7XG4gICAgdmFyIHhociwgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuXG4gICAgeGhyLm9ubG9hZGVuZCA9IHRoaXMubG9hZGVuZC5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG5cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kLTEpKTtcbiAgICB9XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xuICAgIGxldCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMudGZpcnN0ID0gMDtcbiAgICBzdGF0cy5sb2FkZWQgPSAwO1xuICAgIGlmICh0aGlzLnhoclNldHVwKSB7XG4gICAgICB0aGlzLnhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgIH1cbiAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgbG9hZGVuZChldmVudCkge1xuICAgIHZhciB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBzdGF0dXMgPSB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMsXG4gICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW4gYW55IGNhc2UgY2xlYXIgdGhlIGN1cnJlbnQgeGhycyB0aW1lb3V0XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcblxuICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApICB7XG4gICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCxwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICBsZXQgZGF0YSxsZW47XG4gICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICBsZXQgcmVzcG9uc2UgPSB7IHVybCA6IHhoci5yZXNwb25zZVVSTCwgZGF0YSA6IGRhdGEgfTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgaWYgKHN0YXRzLnJldHJ5ID49IGNvbmZpZy5tYXhSZXRyeSB8fCAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH1gICk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlIDogc3RhdHVzLCB0ZXh0IDogeGhyLnN0YXR1c1RleHR9LCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXRyeVxuICAgICAgICBsb2dnZXIud2FybihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH0sIHJldHJ5aW5nIGluICR7dGhpcy5yZXRyeURlbGF5fS4uLmApO1xuICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICB0aGlzLnJldHJ5RGVsYXkgPSBNYXRoLm1pbigyICogdGhpcy5yZXRyeURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XG4gICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCApO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBpZiAoc3RhdHMudGZpcnN0ID09PSAwKSB7XG4gICAgICBzdGF0cy50Zmlyc3QgPSBNYXRoLm1heChwZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMudHJlcXVlc3QpO1xuICAgIH1cbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICAgIGxldCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgLy8gbGFzdCBhcmdzIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xuIl19
